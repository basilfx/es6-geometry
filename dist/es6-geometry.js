/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Vector = exports.Rectangle = exports.Point = exports.Circle = undefined;\n\nvar _Circle = __webpack_require__(1);\n\nvar _Circle2 = _interopRequireDefault(_Circle);\n\nvar _Point = __webpack_require__(2);\n\nvar _Point2 = _interopRequireDefault(_Point);\n\nvar _Rectangle = __webpack_require__(5);\n\nvar _Rectangle2 = _interopRequireDefault(_Rectangle);\n\nvar _Vector = __webpack_require__(4);\n\nvar _Vector2 = _interopRequireDefault(_Vector);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.Circle = _Circle2.default;\nexports.Point = _Point2.default;\nexports.Rectangle = _Rectangle2.default;\nexports.Vector = _Vector2.default;//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9pbmRleC5qcz9jODcyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5WZWN0b3IgPSBleHBvcnRzLlJlY3RhbmdsZSA9IGV4cG9ydHMuUG9pbnQgPSBleHBvcnRzLkNpcmNsZSA9IHVuZGVmaW5lZDtcblxudmFyIF9DaXJjbGUgPSByZXF1aXJlKCcuL0NpcmNsZScpO1xuXG52YXIgX0NpcmNsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DaXJjbGUpO1xuXG52YXIgX1BvaW50ID0gcmVxdWlyZSgnLi9Qb2ludCcpO1xuXG52YXIgX1BvaW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1BvaW50KTtcblxudmFyIF9SZWN0YW5nbGUgPSByZXF1aXJlKCcuL1JlY3RhbmdsZScpO1xuXG52YXIgX1JlY3RhbmdsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9SZWN0YW5nbGUpO1xuXG52YXIgX1ZlY3RvciA9IHJlcXVpcmUoJy4vVmVjdG9yJyk7XG5cbnZhciBfVmVjdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1ZlY3Rvcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuQ2lyY2xlID0gX0NpcmNsZTIuZGVmYXVsdDtcbmV4cG9ydHMuUG9pbnQgPSBfUG9pbnQyLmRlZmF1bHQ7XG5leHBvcnRzLlJlY3RhbmdsZSA9IF9SZWN0YW5nbGUyLmRlZmF1bHQ7XG5leHBvcnRzLlZlY3RvciA9IF9WZWN0b3IyLmRlZmF1bHQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Point = __webpack_require__(2);\n\nvar _Point2 = _interopRequireDefault(_Point);\n\nvar _Rectangle = __webpack_require__(5);\n\nvar _Rectangle2 = _interopRequireDefault(_Rectangle);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Immutable circle class.\n */\n\nvar Circle = function () {\n    /**\n     * Construct a new circle using center point `A` and radius `r`.\n     *\n     * @param {Point} a Center point `A`.\n     * @param {number} r The radius `r`.\n     * @return {void}\n     */\n\n    function Circle(a, r) {\n        _classCallCheck(this, Circle);\n\n        this._a = a;\n        this._r = r;\n    }\n\n    /**\n     * Get the circle center point.\n     *\n     * @return {Point} Center point.\n     */\n\n\n    _createClass(Circle, [{\n        key: 'toRectangle',\n\n\n        /**\n         * Convert this circle to a rectangle that contains this circle exactly.\n         *\n         * @return {Rectangle} Converted rectangle.\n         */\n        value: function toRectangle() {\n            var a = new _Point2.default(this._a._x - this.radius, this._a._y - this.radius);\n            var b = new _Point2.default(this._a._x + this.radius, this._a._y + this.radius);\n\n            return new _Rectangle2.default(a, b);\n        }\n\n        /**\n         * Convert this circle into an object.\n         *\n         * @return {object} Object representation (x, y, r).\n         */\n\n    }, {\n        key: 'toObject',\n        value: function toObject() {\n            return {\n                x: this._a._x,\n                y: this._a._y,\n                r: this._r\n            };\n        }\n\n        /**\n         * Convert this circle into an array.\n         *\n         * @return {Array} Array representation (x, y, r).\n         */\n\n    }, {\n        key: 'toArray',\n        value: function toArray() {\n            return [this._a._x, this._a._y, this._r];\n        }\n\n        /**\n         * Convert this circle into a string representation.\n         *\n         * @return {string} String representation (x, y, r).\n         */\n\n    }, {\n        key: 'toString',\n        value: function toString() {\n            return '(' + this._a._x + ', ' + this._a._y + ', ' + this._r + ')';\n        }\n\n        /**\n         * Create a shallow copy of this instance.\n         *\n         * @return {Circle} Cloned instance.\n         */\n\n    }, {\n        key: 'clone',\n        value: function clone() {\n            return new Circle(this._a, this._r);\n        }\n\n        /**\n         * Return true if this circle is equal to another circle. Two circles are\n         * equal if and only if the center point and radius are equal.\n         *\n         * @param {object} that Other instance to compare to.\n         * @return {boolean} True if both circles are equal, false otherwise.\n         */\n\n    }, {\n        key: 'equals',\n        value: function equals(that) {\n            return this.constructor.name === that.constructor.name && this._a.equals(that._a) && this._r === that._r;\n        }\n\n        /**\n         * Return true if the circle is defined, finite and valid.\n         *\n         * @return {Boolean} True if the circle is fully defined, finite and valid.\n         */\n\n    }, {\n        key: 'isValid',\n        value: function isValid() {\n            return this._a.isValid() && typeof this._r === 'number' && isFinite(this._r) && this._r >= 0;\n        }\n    }, {\n        key: 'a',\n        get: function get() {\n            return this._a;\n        }\n\n        /**\n         * Get the circle center x coordinate. Shortcut for `this.a.x`.\n         *\n         * @return {number} Circle center x coordinate.\n         */\n\n    }, {\n        key: 'x',\n        get: function get() {\n            return this._a._x;\n        }\n\n        /**\n         * Get the circle center y coordinate. Shortcut for `this.a.y`.\n         *\n         * @return {number} Circle center y coordinate.\n         */\n\n    }, {\n        key: 'y',\n        get: function get() {\n            return this._a._y;\n        }\n\n        /**\n         * Get the circle radius.\n         *\n         * @return {number} Circle radius.\n         */\n\n    }, {\n        key: 'r',\n        get: function get() {\n            return this._r;\n        }\n\n        /**\n         * Get the diameter. This is a shortcut for `this.r * 2`.\n         *\n         * @return {number} The circle diameter.\n         */\n\n    }, {\n        key: 'd',\n        get: function get() {\n            return this._r * 2;\n        }\n    }]);\n\n    return Circle;\n}();\n\nexports.default = Circle;//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9DaXJjbGUuanM/NTU2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9Qb2ludCA9IHJlcXVpcmUoJy4vUG9pbnQnKTtcblxudmFyIF9Qb2ludDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Qb2ludCk7XG5cbnZhciBfUmVjdGFuZ2xlID0gcmVxdWlyZSgnLi9SZWN0YW5nbGUnKTtcblxudmFyIF9SZWN0YW5nbGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUmVjdGFuZ2xlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBJbW11dGFibGUgY2lyY2xlIGNsYXNzLlxuICovXG5cbnZhciBDaXJjbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IGNpcmNsZSB1c2luZyBjZW50ZXIgcG9pbnQgYEFgIGFuZCByYWRpdXMgYHJgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQb2ludH0gYSBDZW50ZXIgcG9pbnQgYEFgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByIFRoZSByYWRpdXMgYHJgLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBDaXJjbGUoYSwgcikge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2lyY2xlKTtcblxuICAgICAgICB0aGlzLl9hID0gYTtcbiAgICAgICAgdGhpcy5fciA9IHI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjaXJjbGUgY2VudGVyIHBvaW50LlxuICAgICAqXG4gICAgICogQHJldHVybiB7UG9pbnR9IENlbnRlciBwb2ludC5cbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKENpcmNsZSwgW3tcbiAgICAgICAga2V5OiAndG9SZWN0YW5nbGUnLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnQgdGhpcyBjaXJjbGUgdG8gYSByZWN0YW5nbGUgdGhhdCBjb250YWlucyB0aGlzIGNpcmNsZSBleGFjdGx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtSZWN0YW5nbGV9IENvbnZlcnRlZCByZWN0YW5nbGUuXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9SZWN0YW5nbGUoKSB7XG4gICAgICAgICAgICB2YXIgYSA9IG5ldyBfUG9pbnQyLmRlZmF1bHQodGhpcy5fYS5feCAtIHRoaXMucmFkaXVzLCB0aGlzLl9hLl95IC0gdGhpcy5yYWRpdXMpO1xuICAgICAgICAgICAgdmFyIGIgPSBuZXcgX1BvaW50Mi5kZWZhdWx0KHRoaXMuX2EuX3ggKyB0aGlzLnJhZGl1cywgdGhpcy5fYS5feSArIHRoaXMucmFkaXVzKTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBfUmVjdGFuZ2xlMi5kZWZhdWx0KGEsIGIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnQgdGhpcyBjaXJjbGUgaW50byBhbiBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uICh4LCB5LCByKS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvT2JqZWN0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvT2JqZWN0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiB0aGlzLl9hLl94LFxuICAgICAgICAgICAgICAgIHk6IHRoaXMuX2EuX3ksXG4gICAgICAgICAgICAgICAgcjogdGhpcy5fclxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0IHRoaXMgY2lyY2xlIGludG8gYW4gYXJyYXkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5fSBBcnJheSByZXByZXNlbnRhdGlvbiAoeCwgeSwgcikuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b0FycmF5JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvQXJyYXkoKSB7XG4gICAgICAgICAgICByZXR1cm4gW3RoaXMuX2EuX3gsIHRoaXMuX2EuX3ksIHRoaXMuX3JdO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnQgdGhpcyBjaXJjbGUgaW50byBhIHN0cmluZyByZXByZXNlbnRhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gKHgsIHksIHIpLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9TdHJpbmcnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gJygnICsgdGhpcy5fYS5feCArICcsICcgKyB0aGlzLl9hLl95ICsgJywgJyArIHRoaXMuX3IgKyAnKSc7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgc2hhbGxvdyBjb3B5IG9mIHRoaXMgaW5zdGFuY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0NpcmNsZX0gQ2xvbmVkIGluc3RhbmNlLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2xvbmUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENpcmNsZSh0aGlzLl9hLCB0aGlzLl9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGlzIGNpcmNsZSBpcyBlcXVhbCB0byBhbm90aGVyIGNpcmNsZS4gVHdvIGNpcmNsZXMgYXJlXG4gICAgICAgICAqIGVxdWFsIGlmIGFuZCBvbmx5IGlmIHRoZSBjZW50ZXIgcG9pbnQgYW5kIHJhZGl1cyBhcmUgZXF1YWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGF0IE90aGVyIGluc3RhbmNlIHRvIGNvbXBhcmUgdG8uXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYm90aCBjaXJjbGVzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZXF1YWxzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVxdWFscyh0aGF0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lID09PSB0aGF0LmNvbnN0cnVjdG9yLm5hbWUgJiYgdGhpcy5fYS5lcXVhbHModGhhdC5fYSkgJiYgdGhpcy5fciA9PT0gdGhhdC5fcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgY2lyY2xlIGlzIGRlZmluZWQsIGZpbml0ZSBhbmQgdmFsaWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIGNpcmNsZSBpcyBmdWxseSBkZWZpbmVkLCBmaW5pdGUgYW5kIHZhbGlkLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaXNWYWxpZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc1ZhbGlkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2EuaXNWYWxpZCgpICYmIHR5cGVvZiB0aGlzLl9yID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh0aGlzLl9yKSAmJiB0aGlzLl9yID49IDA7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2EnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY2lyY2xlIGNlbnRlciB4IGNvb3JkaW5hdGUuIFNob3J0Y3V0IGZvciBgdGhpcy5hLnhgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IENpcmNsZSBjZW50ZXIgeCBjb29yZGluYXRlLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAneCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2EuX3g7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjaXJjbGUgY2VudGVyIHkgY29vcmRpbmF0ZS4gU2hvcnRjdXQgZm9yIGB0aGlzLmEueWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn0gQ2lyY2xlIGNlbnRlciB5IGNvb3JkaW5hdGUuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd5JyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYS5feTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGNpcmNsZSByYWRpdXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn0gQ2lyY2xlIHJhZGl1cy5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3InLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgZGlhbWV0ZXIuIFRoaXMgaXMgYSBzaG9ydGN1dCBmb3IgYHRoaXMuciAqIDJgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBjaXJjbGUgZGlhbWV0ZXIuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdkJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fciAqIDI7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQ2lyY2xlO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBDaXJjbGU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9DaXJjbGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Vector = __webpack_require__(4);\n\nvar _Vector2 = _interopRequireDefault(_Vector);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Immutable point class.\n *\n * A point is an absolute place in space, at a given x and y coordinate.\n * \n * The difference between a Point and a vector is explained in this source:\n * http://math.stackexchange.com/a/645827\n */\n\nvar Point = function () {\n    /**\n     * Construct a new point, using a x and y coordinate.\n     *\n     * An point is immutable. All subsequent operations will return a new point\n     * instance.\n     *\n     * @param {number} x The x coordinate.\n     * @param {number} y The y coordinate.\n     * @return {void}\n     */\n\n    function Point(x, y) {\n        _classCallCheck(this, Point);\n\n        this._x = x;\n        this._y = y;\n    }\n\n    /**\n     * Create a new point from an array. The first index is considered the x\n     * coordinate, the second index is considered the y coordinate.\n     *\n     * @param {Array} array Input array with at least two values.\n     * @return {Point} Resulting point.\n     */\n\n\n    _createClass(Point, [{\n        key: 'add',\n\n\n        /**\n         * Add a vector to a point.\n         *\n         * Note that addition of two points is undefined.\n         * \n         * @param {Vector} vector Vector to add to this point.\n         * @return {Point} Point with the vector added to it. \n         */\n        value: function add(vector) {\n            if (vector instanceof Point) {\n                throw new Error('Addition of two points is undefined.');\n            }\n\n            return new Point(this._x + vector._x, this._y + vector._y);\n        }\n\n        /**\n         * Subtract a Point or a Vector.\n         * \n         * @param {Point|Vector} that Point or vector to subtract.\n         * @return {Point} If `that` is a Vector, it will return the new point.\n         * @return {Vector} If `that` is a Point, it will return the displacement.\n         */\n\n    }, {\n        key: 'subtract',\n        value: function subtract(that) {\n            if (that instanceof Point) {\n                return this.toVector().subtract(that);\n            }\n\n            return new Point(this._x - that._x, this._y - that._y);\n        }\n\n        /**\n         * Invert the x and y coordinate, relative to (0, 0).\n         * \n         * @return {Point} Inverted point.\n         */\n\n    }, {\n        key: 'invert',\n        value: function invert() {\n            return new Point(-this._x, -this._y);\n        }\n\n        /**\n         * @return {Point}\n         */\n\n    }, {\n        key: 'multiply',\n        value: function multiply(scalar) {\n            return new Point(this._x * scalar, this._y * scalar);\n        }\n\n        /**\n         * @return {Point}\n         */\n\n    }, {\n        key: 'multiplyXY',\n        value: function multiplyXY(scalarX, scalarY) {\n            return new Point(this._x * scalarX, this._y * scalarY);\n        }\n\n        /**\n         * @return {Point}\n         */\n\n    }, {\n        key: 'divide',\n        value: function divide(scalar) {\n            return new Point(this._x / scalar, this._y / scalar);\n        }\n\n        /**\n         * @return {Point}\n         */\n\n    }, {\n        key: 'divideXY',\n        value: function divideXY(scalarX, scalarY) {\n            return new Point(this._x / scalarX, this._y / scalarY);\n        }\n\n        /**\n         * @return {Point}\n         */\n\n    }, {\n        key: 'mix',\n        value: function mix(that) {\n            var amount = arguments.length <= 1 || arguments[1] === undefined ? 0.5 : arguments[1];\n\n            return this.multiply(1 - amount).add(that.multiply(amount));\n        }\n\n        /**\n         * @return {Point}\n         */\n\n    }, {\n        key: 'perpendicular',\n        value: function perpendicular() {\n            return new Point(-this._y, this._x);\n        }\n\n        /**\n         * @return {Point}\n         */\n\n    }, {\n        key: 'snap',\n        value: function snap(to) {\n            var round = function round(val) {\n                return Math.round(val / to) * to;\n            };\n\n            return new Point(round(this._x), round(this._y));\n        }\n\n        /**\n         * @return {number}\n         */\n\n    }, {\n        key: 'dot',\n        value: function dot(that) {\n            return this._x * that._x + this._y * that._y;\n        }\n\n        /**\n         * @return {number}\n         */\n\n    }, {\n        key: 'angle',\n        value: function angle() {\n            return Math.atan2(this._y, this._x);\n        }\n\n        /**\n         * @return {number}\n         */\n\n    }, {\n        key: 'angleDeg',\n        value: function angleDeg() {\n            return Math.atan2(this._y, this._x) * 180 / Math.PI;\n        }\n\n        /**\n         * @return {number}\n         */\n\n    }, {\n        key: 'slope',\n        value: function slope() {\n            return this._y / this._x;\n        }\n\n        /**\n         * Calculate the squared distance between two points.\n         *\n         * If the exact distance doesn't matter, this method is slightly faster\n         * than `this.distance`.\n         *\n         * @param {Point} point The other point.\n         * @return {number} The distance between both points.\n         */\n\n    }, {\n        key: 'distanceSq',\n        value: function distanceSq(point) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (!(point instanceof Point)) {\n                    throw new Error('Must be a point.');\n                }\n            }\n\n            var dX = this._x - point._x;\n            var dY = this._y - point._y;\n\n            return dX * dX + dY * dY;\n        }\n\n        /**\n         * Calculate the distance between two points.\n         *\n         * @param {Point} point The other point.\n         * @return {number} The distance between both points.\n         */\n\n    }, {\n        key: 'distance',\n        value: function distance(point) {\n            return Math.sqrt(this.distanceSq(point));\n        }\n\n        /**\n         * Convert point into a vector.\n         *\n         * Note: this is an utility method. A proper conversion does not exist.\n         *\n         * @return {Vector} The point converted as vector.\n         */\n\n    }, {\n        key: 'toVector',\n        value: function toVector() {\n            return new _Vector2.default(this._x, this._y);\n        }\n\n        /**\n         * Convert this point into an array.\n         *\n         * @return {Array} Array representation (x, y).\n         */\n\n    }, {\n        key: 'toArray',\n        value: function toArray() {\n            return [this._x, this._y];\n        }\n\n        /**\n         * Convert this point into an object.\n         *\n         * @return {object} Object representation (x, y).\n         */\n\n    }, {\n        key: 'toObject',\n        value: function toObject() {\n            return { x: this._x, y: this._y };\n        }\n\n        /**\n         * Convert this point into a string representation.\n         *\n         * @return {string} String representation (x, y).\n         */\n\n    }, {\n        key: 'toString',\n        value: function toString() {\n            return '(' + this._x + ', ' + this._y + ')';\n        }\n\n        /**\n         * Convert this point into a string representation, using a fixed number of\n         * digits for displaying.\n         *\n         * @param {number} digits Number of digits to use for representation.\n         * @return {string} String representation (x, y).\n         */\n\n    }, {\n        key: 'toFixed',\n        value: function toFixed(digits) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (typeof digits !== 'number') {\n                    throw new Error('Number of digits must be a number.');\n                }\n            }\n\n            return '(' + this._x.toFixed(digits) + ', ' + this._y.toFixed(digits) + ')';\n        }\n\n        /**\n         * Create a shallow copy of this instance.\n         *\n         * @return {Point} Cloned instance.\n         */\n\n    }, {\n        key: 'clone',\n        value: function clone() {\n            return new Point(this._x, this._y);\n        }\n\n        /**\n         * Return true if this point is equal to another point. Two points are\n         * equal when both x and y coordinates are equal.\n         *\n         * @param {object} that Other instance to compare to.\n         * @return {boolean} True if both points are equal, false otherwise.\n         */\n\n    }, {\n        key: 'equals',\n        value: function equals(that) {\n            return this.constructor.name === that.constructor.name && this._x === that._x && this._y === that._y;\n        }\n\n        /**\n         * Return true if the point is defined and finite.\n         *\n         * @return {Boolean} True if point is fully defined and valid.\n         */\n\n    }, {\n        key: 'isValid',\n        value: function isValid() {\n            return typeof this._x === 'number' && isFinite(this._x) && typeof this._y === 'number' && isFinite(this._y);\n        }\n    }, {\n        key: 'x',\n\n\n        /**\n         * Get the x coordinate.\n         *\n         * @return {number} The x coordinate.\n         */\n        get: function get() {\n            return this._x;\n        }\n\n        /**\n         * Get the y coordinate.\n         *\n         * @return {number} The y coordinate.\n         */\n\n    }, {\n        key: 'y',\n        get: function get() {\n            return this._y;\n        }\n    }], [{\n        key: 'fromArray',\n        value: function fromArray(array) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (!Array.isArray(array) || array.length < 2) {\n                    throw new Error('Expected an array with at least two values.');\n                }\n            }\n\n            return new Point(array[0], array[1]);\n        }\n\n        /**\n         * Create a new point from an object. The object should have an x and y\n         * property.\n         *\n         * @param {object} object Input object with x and y property.\n         * @return {Point} Resulting point.\n         */\n\n    }, {\n        key: 'fromObject',\n        value: function fromObject(object) {\n            if (process.env.NODE_ENV !== 'production') {\n                if ((typeof object === 'undefined' ? 'undefined' : _typeof(object)) !== 'object') {\n                    throw new Error('Expected an object.');\n                }\n            }\n\n            return new Point(object.x, object.y);\n        }\n    }]);\n\n    return Point;\n}();\n\nexports.default = Point;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9Qb2ludC5qcz8zNzYxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9WZWN0b3IgPSByZXF1aXJlKCcuL1ZlY3RvcicpO1xuXG52YXIgX1ZlY3RvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9WZWN0b3IpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIEltbXV0YWJsZSBwb2ludCBjbGFzcy5cbiAqXG4gKiBBIHBvaW50IGlzIGFuIGFic29sdXRlIHBsYWNlIGluIHNwYWNlLCBhdCBhIGdpdmVuIHggYW5kIHkgY29vcmRpbmF0ZS5cbiAqIFxuICogVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBhIFBvaW50IGFuZCBhIHZlY3RvciBpcyBleHBsYWluZWQgaW4gdGhpcyBzb3VyY2U6XG4gKiBodHRwOi8vbWF0aC5zdGFja2V4Y2hhbmdlLmNvbS9hLzY0NTgyN1xuICovXG5cbnZhciBQb2ludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgcG9pbnQsIHVzaW5nIGEgeCBhbmQgeSBjb29yZGluYXRlLlxuICAgICAqXG4gICAgICogQW4gcG9pbnQgaXMgaW1tdXRhYmxlLiBBbGwgc3Vic2VxdWVudCBvcGVyYXRpb25zIHdpbGwgcmV0dXJuIGEgbmV3IHBvaW50XG4gICAgICogaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCBUaGUgeCBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IFRoZSB5IGNvb3JkaW5hdGUuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFBvaW50KHgsIHkpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBvaW50KTtcblxuICAgICAgICB0aGlzLl94ID0geDtcbiAgICAgICAgdGhpcy5feSA9IHk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHBvaW50IGZyb20gYW4gYXJyYXkuIFRoZSBmaXJzdCBpbmRleCBpcyBjb25zaWRlcmVkIHRoZSB4XG4gICAgICogY29vcmRpbmF0ZSwgdGhlIHNlY29uZCBpbmRleCBpcyBjb25zaWRlcmVkIHRoZSB5IGNvb3JkaW5hdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBJbnB1dCBhcnJheSB3aXRoIGF0IGxlYXN0IHR3byB2YWx1ZXMuXG4gICAgICogQHJldHVybiB7UG9pbnR9IFJlc3VsdGluZyBwb2ludC5cbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKFBvaW50LCBbe1xuICAgICAgICBrZXk6ICdhZGQnLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBhIHZlY3RvciB0byBhIHBvaW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlIHRoYXQgYWRkaXRpb24gb2YgdHdvIHBvaW50cyBpcyB1bmRlZmluZWQuXG4gICAgICAgICAqIFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3Rvcn0gdmVjdG9yIFZlY3RvciB0byBhZGQgdG8gdGhpcyBwb2ludC5cbiAgICAgICAgICogQHJldHVybiB7UG9pbnR9IFBvaW50IHdpdGggdGhlIHZlY3RvciBhZGRlZCB0byBpdC4gXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKHZlY3Rvcikge1xuICAgICAgICAgICAgaWYgKHZlY3RvciBpbnN0YW5jZW9mIFBvaW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBZGRpdGlvbiBvZiB0d28gcG9pbnRzIGlzIHVuZGVmaW5lZC4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLl94ICsgdmVjdG9yLl94LCB0aGlzLl95ICsgdmVjdG9yLl95KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdWJ0cmFjdCBhIFBvaW50IG9yIGEgVmVjdG9yLlxuICAgICAgICAgKiBcbiAgICAgICAgICogQHBhcmFtIHtQb2ludHxWZWN0b3J9IHRoYXQgUG9pbnQgb3IgdmVjdG9yIHRvIHN1YnRyYWN0LlxuICAgICAgICAgKiBAcmV0dXJuIHtQb2ludH0gSWYgYHRoYXRgIGlzIGEgVmVjdG9yLCBpdCB3aWxsIHJldHVybiB0aGUgbmV3IHBvaW50LlxuICAgICAgICAgKiBAcmV0dXJuIHtWZWN0b3J9IElmIGB0aGF0YCBpcyBhIFBvaW50LCBpdCB3aWxsIHJldHVybiB0aGUgZGlzcGxhY2VtZW50LlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc3VidHJhY3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc3VidHJhY3QodGhhdCkge1xuICAgICAgICAgICAgaWYgKHRoYXQgaW5zdGFuY2VvZiBQb2ludCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvVmVjdG9yKCkuc3VidHJhY3QodGhhdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy5feCAtIHRoYXQuX3gsIHRoaXMuX3kgLSB0aGF0Ll95KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnZlcnQgdGhlIHggYW5kIHkgY29vcmRpbmF0ZSwgcmVsYXRpdmUgdG8gKDAsIDApLlxuICAgICAgICAgKiBcbiAgICAgICAgICogQHJldHVybiB7UG9pbnR9IEludmVydGVkIHBvaW50LlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaW52ZXJ0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGludmVydCgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoLXRoaXMuX3gsIC10aGlzLl95KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtQb2ludH1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ211bHRpcGx5JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG11bHRpcGx5KHNjYWxhcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLl94ICogc2NhbGFyLCB0aGlzLl95ICogc2NhbGFyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtQb2ludH1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ211bHRpcGx5WFknLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbXVsdGlwbHlYWShzY2FsYXJYLCBzY2FsYXJZKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMuX3ggKiBzY2FsYXJYLCB0aGlzLl95ICogc2NhbGFyWSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7UG9pbnR9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdkaXZpZGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGl2aWRlKHNjYWxhcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLl94IC8gc2NhbGFyLCB0aGlzLl95IC8gc2NhbGFyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtQb2ludH1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2RpdmlkZVhZJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpdmlkZVhZKHNjYWxhclgsIHNjYWxhclkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy5feCAvIHNjYWxhclgsIHRoaXMuX3kgLyBzY2FsYXJZKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtQb2ludH1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ21peCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtaXgodGhhdCkge1xuICAgICAgICAgICAgdmFyIGFtb3VudCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IDAuNSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHkoMSAtIGFtb3VudCkuYWRkKHRoYXQubXVsdGlwbHkoYW1vdW50KSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7UG9pbnR9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdwZXJwZW5kaWN1bGFyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBlcnBlbmRpY3VsYXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KC10aGlzLl95LCB0aGlzLl94KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtQb2ludH1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NuYXAnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc25hcCh0bykge1xuICAgICAgICAgICAgdmFyIHJvdW5kID0gZnVuY3Rpb24gcm91bmQodmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQodmFsIC8gdG8pICogdG87XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHJvdW5kKHRoaXMuX3gpLCByb3VuZCh0aGlzLl95KSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZG90JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRvdCh0aGF0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5feCAqIHRoYXQuX3ggKyB0aGlzLl95ICogdGhhdC5feTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdhbmdsZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhbmdsZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmF0YW4yKHRoaXMuX3ksIHRoaXMuX3gpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2FuZ2xlRGVnJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFuZ2xlRGVnKCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIodGhpcy5feSwgdGhpcy5feCkgKiAxODAgLyBNYXRoLlBJO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3Nsb3BlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNsb3BlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3kgLyB0aGlzLl94O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGN1bGF0ZSB0aGUgc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHRoZSBleGFjdCBkaXN0YW5jZSBkb2Vzbid0IG1hdHRlciwgdGhpcyBtZXRob2QgaXMgc2xpZ2h0bHkgZmFzdGVyXG4gICAgICAgICAqIHRoYW4gYHRoaXMuZGlzdGFuY2VgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludCBUaGUgb3RoZXIgcG9pbnQuXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGRpc3RhbmNlIGJldHdlZW4gYm90aCBwb2ludHMuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdkaXN0YW5jZVNxJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlU3EocG9pbnQpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEocG9pbnQgaW5zdGFuY2VvZiBQb2ludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IGJlIGEgcG9pbnQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZFggPSB0aGlzLl94IC0gcG9pbnQuX3g7XG4gICAgICAgICAgICB2YXIgZFkgPSB0aGlzLl95IC0gcG9pbnQuX3k7XG5cbiAgICAgICAgICAgIHJldHVybiBkWCAqIGRYICsgZFkgKiBkWTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnQgVGhlIG90aGVyIHBvaW50LlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBkaXN0YW5jZSBiZXR3ZWVuIGJvdGggcG9pbnRzLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZGlzdGFuY2UnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2UocG9pbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5kaXN0YW5jZVNxKHBvaW50KSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydCBwb2ludCBpbnRvIGEgdmVjdG9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlOiB0aGlzIGlzIGFuIHV0aWxpdHkgbWV0aG9kLiBBIHByb3BlciBjb252ZXJzaW9uIGRvZXMgbm90IGV4aXN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtWZWN0b3J9IFRoZSBwb2ludCBjb252ZXJ0ZWQgYXMgdmVjdG9yLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9WZWN0b3InLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9WZWN0b3IoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IF9WZWN0b3IyLmRlZmF1bHQodGhpcy5feCwgdGhpcy5feSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydCB0aGlzIHBvaW50IGludG8gYW4gYXJyYXkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5fSBBcnJheSByZXByZXNlbnRhdGlvbiAoeCwgeSkuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b0FycmF5JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvQXJyYXkoKSB7XG4gICAgICAgICAgICByZXR1cm4gW3RoaXMuX3gsIHRoaXMuX3ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnQgdGhpcyBwb2ludCBpbnRvIGFuIG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gKHgsIHkpLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9PYmplY3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9PYmplY3QoKSB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiB0aGlzLl94LCB5OiB0aGlzLl95IH07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydCB0aGlzIHBvaW50IGludG8gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gU3RyaW5nIHJlcHJlc2VudGF0aW9uICh4LCB5KS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuICcoJyArIHRoaXMuX3ggKyAnLCAnICsgdGhpcy5feSArICcpJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0IHRoaXMgcG9pbnQgaW50byBhIHN0cmluZyByZXByZXNlbnRhdGlvbiwgdXNpbmcgYSBmaXhlZCBudW1iZXIgb2ZcbiAgICAgICAgICogZGlnaXRzIGZvciBkaXNwbGF5aW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZGlnaXRzIE51bWJlciBvZiBkaWdpdHMgdG8gdXNlIGZvciByZXByZXNlbnRhdGlvbi5cbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gKHgsIHkpLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9GaXhlZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0ZpeGVkKGRpZ2l0cykge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRpZ2l0cyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOdW1iZXIgb2YgZGlnaXRzIG11c3QgYmUgYSBudW1iZXIuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gJygnICsgdGhpcy5feC50b0ZpeGVkKGRpZ2l0cykgKyAnLCAnICsgdGhpcy5feS50b0ZpeGVkKGRpZ2l0cykgKyAnKSc7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgc2hhbGxvdyBjb3B5IG9mIHRoaXMgaW5zdGFuY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1BvaW50fSBDbG9uZWQgaW5zdGFuY2UuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjbG9uZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy5feCwgdGhpcy5feSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIHRydWUgaWYgdGhpcyBwb2ludCBpcyBlcXVhbCB0byBhbm90aGVyIHBvaW50LiBUd28gcG9pbnRzIGFyZVxuICAgICAgICAgKiBlcXVhbCB3aGVuIGJvdGggeCBhbmQgeSBjb29yZGluYXRlcyBhcmUgZXF1YWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGF0IE90aGVyIGluc3RhbmNlIHRvIGNvbXBhcmUgdG8uXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYm90aCBwb2ludHMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdlcXVhbHMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZXF1YWxzKHRoYXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgPT09IHRoYXQuY29uc3RydWN0b3IubmFtZSAmJiB0aGlzLl94ID09PSB0aGF0Ll94ICYmIHRoaXMuX3kgPT09IHRoYXQuX3k7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHBvaW50IGlzIGRlZmluZWQgYW5kIGZpbml0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiBwb2ludCBpcyBmdWxseSBkZWZpbmVkIGFuZCB2YWxpZC5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2lzVmFsaWQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNWYWxpZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5feCA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodGhpcy5feCkgJiYgdHlwZW9mIHRoaXMuX3kgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHRoaXMuX3kpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd4JyxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHggY29vcmRpbmF0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgeCBjb29yZGluYXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5feDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHkgY29vcmRpbmF0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgeSBjb29yZGluYXRlLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAneScsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3k7XG4gICAgICAgIH1cbiAgICB9XSwgW3tcbiAgICAgICAga2V5OiAnZnJvbUFycmF5JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21BcnJheShhcnJheSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpIHx8IGFycmF5Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhbiBhcnJheSB3aXRoIGF0IGxlYXN0IHR3byB2YWx1ZXMuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KGFycmF5WzBdLCBhcnJheVsxXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IHBvaW50IGZyb20gYW4gb2JqZWN0LiBUaGUgb2JqZWN0IHNob3VsZCBoYXZlIGFuIHggYW5kIHlcbiAgICAgICAgICogcHJvcGVydHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3QgSW5wdXQgb2JqZWN0IHdpdGggeCBhbmQgeSBwcm9wZXJ0eS5cbiAgICAgICAgICogQHJldHVybiB7UG9pbnR9IFJlc3VsdGluZyBwb2ludC5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Zyb21PYmplY3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKCh0eXBlb2Ygb2JqZWN0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvYmplY3QpKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhbiBvYmplY3QuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KG9iamVjdC54LCBvYmplY3QueSk7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gUG9pbnQ7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFBvaW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvUG9pbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 3 */
/***/ function(module, exports) {

	eval("// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vcHJvY2Vzcy9icm93c2VyLmpzPzgyZTQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9wcm9jZXNzL2Jyb3dzZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Point = __webpack_require__(2);\n\nvar _Point2 = _interopRequireDefault(_Point);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Immutable vector class.\n *\n * A vector represents a displacement, using a x an y component to represent\n * the length (magnitude) and direction.\n * \n * The difference between a Vector and a Point is explained in this source:\n * http://math.stackexchange.com/a/645827\n */\n\nvar Vector = function () {\n\n    /**\n     * Construct a new vector, using a x and y component to represent the\n     * length (magnitude) and direction relative to (0, 0).\n     *\n     * An vector is immutable. All subsequent operations will return a new\n     * vector instance.\n     *\n     * @param {number} x The x component.\n     * @param {number} y The y component.\n     * @return {void}\n     */\n\n    function Vector(x, y) {\n        _classCallCheck(this, Vector);\n\n        this._x = x;\n        this._y = y;\n    }\n\n    /**\n     * Create a new vector from an array. The first index is considered the x\n     * component, the second index is considered the y component.\n     *\n     * @param {Array} array Input array with at least two values.\n     * @return {Vector} Resulting vector.\n     */\n\n    /**\n     * Definition of the unit vector.\n     */\n\n\n    _createClass(Vector, [{\n        key: 'add',\n\n\n        /**\n         * Add another vector or point to this vector.\n         *\n         * If the input is a point, the result will be a point with this vector\n         * as offset.\n         *\n         * @param {Point|Vector} that Point or vector to add.\n         * @return {Point|Vector} New Vector if adding vector, point otherwise.\n         */\n        value: function add(that) {\n            if (that instanceof _Point2.default) {\n                return that.add(this);\n            }\n\n            return new Vector(this._x + that._x, this._y + that._y);\n        }\n\n        /**\n         * @return {Vector}\n         */\n\n    }, {\n        key: 'subtract',\n        value: function subtract(that) {\n            return new Vector(this._x - that._x, this._y - that._y);\n        }\n\n        /**\n         * @return {Vector}\n         */\n\n    }, {\n        key: 'invert',\n        value: function invert() {\n            return new Vector(-this._x, -this._y);\n        }\n\n        /**\n         * @return {Vector}\n         */\n\n    }, {\n        key: 'multiply',\n        value: function multiply(scalar) {\n            return new Vector(this._x * scalar, this._y * scalar);\n        }\n\n        /**\n         * @return {Vector}\n         */\n\n    }, {\n        key: 'multiplyXY',\n        value: function multiplyXY(scalarX, scalarY) {\n            return new Vector(this._x * scalarX, this._y * scalarY);\n        }\n\n        /**\n         * @return {Vector}\n         */\n\n    }, {\n        key: 'divide',\n        value: function divide(scalar) {\n            return new Vector(this._x / scalar, this._y / scalar);\n        }\n\n        /**\n         * @return {Vector}\n         */\n\n    }, {\n        key: 'divideXY',\n        value: function divideXY(scalarX, scalarY) {\n            return new Vector(this._x / scalarX, this._y / scalarY);\n        }\n\n        /**\n         * @return {Vector}\n         */\n\n    }, {\n        key: 'mix',\n        value: function mix(that) {\n            var amount = arguments.length <= 1 || arguments[1] === undefined ? 0.5 : arguments[1];\n\n            return this.multiply(1 - amount).add(that.multiply(amount));\n        }\n\n        /**\n         * @return {Vector}\n         */\n\n    }, {\n        key: 'perpendicular',\n        value: function perpendicular() {\n            return new Vector(-this._y, this._x);\n        }\n\n        /**\n         * @return {Vector}\n         */\n\n    }, {\n        key: 'snap',\n        value: function snap(to) {\n            var round = function round(val) {\n                return Math.round(val / to) * to;\n            };\n\n            return new Vector(round(this._x), round(this._y));\n        }\n\n        /**\n         * @return {number}\n         */\n\n    }, {\n        key: 'dot',\n        value: function dot(that) {\n            return this._x * that._x + this._y * that._y;\n        }\n\n        /**\n         * @return {number}\n         */\n\n    }, {\n        key: 'angle',\n        value: function angle() {\n            return Math.atan2(this._y, this._x);\n        }\n\n        /**\n         * @return {number}\n         */\n\n    }, {\n        key: 'angleDeg',\n        value: function angleDeg() {\n            return Math.atan2(this._y, this._x) * 180 / Math.PI;\n        }\n\n        /**\n         * @return {number}\n         */\n\n    }, {\n        key: 'slope',\n        value: function slope() {\n            return this._y / this._x;\n        }\n\n        /**\n         * Calculate the squared length of this vector.\n         *\n         * If the exact length doesn't matter, this method is slightly faster\n         * than `this.length`.\n         *\n         * @return {number} The squared length of this vector.\n         */\n\n    }, {\n        key: 'lengthSq',\n        value: function lengthSq() {\n            return this._x * this._x + this._y * this._y;\n        }\n\n        /**\n         * Calculate the length (magnitude) of the vector.\n         *\n         * @return {number} The length of the vector.\n         */\n\n    }, {\n        key: 'length',\n        value: function length() {\n            return Math.sqrt(this.lengthSq());\n        }\n\n        /**\n         * [minLength description]\n         * @param {[type]} length [description]\n         * @return {[type]}\n         */\n\n    }, {\n        key: 'minLength',\n        value: function minLength(length) {\n            return this.length() < length ? this.normalize(length) : this;\n        }\n    }, {\n        key: 'maxLength',\n        value: function maxLength(length) {\n            return this.length() > length ? this.normalize(length) : this;\n        }\n    }, {\n        key: 'normalize',\n        value: function normalize() {\n            var scalar = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];\n\n            return this.divide(this.length()).multiply(scalar);\n        }\n    }, {\n        key: 'projectOnto',\n        value: function projectOnto(that) {\n            return that.multiply(this.dot(that) / that.lengthSq());\n        }\n\n        /**\n         * Convert vector into a point.\n         *\n         * Note: this is an utility method. A proper conversion does not exist.\n         *\n         * @return {Point} The vector converted as point.\n         */\n\n    }, {\n        key: 'toPoint',\n        value: function toPoint() {\n            return new _Point2.default(this._x, this._y);\n        }\n\n        /**\n         * Convert this vector into an array.\n         *\n         * @return {Array} Array representation (x, y).\n         */\n\n    }, {\n        key: 'toArray',\n        value: function toArray() {\n            return [this._x, this._y];\n        }\n\n        /**\n         * Convert this vector into an object.\n         *\n         * @return {object} Object representation (x, y).\n         */\n\n    }, {\n        key: 'toObject',\n        value: function toObject() {\n            return { x: this._x, y: this._y };\n        }\n\n        /**\n         * Convert this vector into a string representation.\n         *\n         * @return {string} String representation (x, y).\n         */\n\n    }, {\n        key: 'toString',\n        value: function toString() {\n            return '(' + this._x + ', ' + this._y + ')';\n        }\n\n        /**\n         * Convert this vector into a string representation, using a fixed number\n         * of digits for displaying.\n         *\n         * @param {number} digits Number of digits to use for representation.\n         * @return {string} String representation (x, y).\n         */\n\n    }, {\n        key: 'toFixed',\n        value: function toFixed(digits) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (typeof digits !== 'number') {\n                    throw new Error('Number of digits must be a number.');\n                }\n            }\n\n            return '(' + this._x.toFixed(digits) + ', ' + this._y.toFixed(digits) + ')';\n        }\n\n        /**\n         * Create a shallow copy of this instance.\n         *\n         * @return {Vector} Cloned instance.\n         */\n\n    }, {\n        key: 'clone',\n        value: function clone() {\n            return new Vector(this._x, this._y);\n        }\n\n        /**\n         * Return true if this vector is equal to another vector. Two vectors are\n         * equal when both x and y components are equal.\n         *\n         * @param {object} that Other instance to compare to.\n         * @return {boolean} True if both points are equal, false otherwise.\n         */\n\n    }, {\n        key: 'equals',\n        value: function equals(that) {\n            return this.constructor.name === that.constructor.name && this._x === that._x && this._y === that._y;\n        }\n\n        /**\n         * Return true if the vector is defined and finite.\n         *\n         * @return {Boolean} True if vector is fully defined and valid.\n         */\n\n    }, {\n        key: 'isValid',\n        value: function isValid() {\n            return typeof this._x === 'number' && isFinite(this._x) && typeof this._y === 'number' && isFinite(this._y);\n        }\n    }, {\n        key: 'x',\n\n\n        /**\n         * Get the x component.\n         *\n         * @return {number} The x component.\n         */\n        get: function get() {\n            return this._x;\n        }\n\n        /**\n         * Get the y component.\n         *\n         * @return {number} The y component.\n         */\n\n    }, {\n        key: 'y',\n        get: function get() {\n            return this._y;\n        }\n    }], [{\n        key: 'fromArray',\n        value: function fromArray(array) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (!Array.isArray(array) || array.length < 2) {\n                    throw new Error('Expected an array with at least two values.');\n                }\n            }\n\n            return new Vector(array[0], array[1]);\n        }\n\n        /**\n         * Create a new vector from an object. The object should have an x and y\n         * property.\n         *\n         * @param {object} object Input object with x and y property.\n         * @return {Vector} Resulting vector.\n         */\n\n    }, {\n        key: 'fromObject',\n        value: function fromObject(object) {\n            if (process.env.NODE_ENV !== 'production') {\n                if ((typeof object === 'undefined' ? 'undefined' : _typeof(object)) !== 'object') {\n                    throw new Error('Expected an object.');\n                }\n            }\n\n            return new Vector(object.x, object.y);\n        }\n    }]);\n\n    return Vector;\n}();\n\nVector.Unit = new Vector(1, 1);\nexports.default = Vector;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9WZWN0b3IuanM/MGIxZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfUG9pbnQgPSByZXF1aXJlKCcuL1BvaW50Jyk7XG5cbnZhciBfUG9pbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUG9pbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIEltbXV0YWJsZSB2ZWN0b3IgY2xhc3MuXG4gKlxuICogQSB2ZWN0b3IgcmVwcmVzZW50cyBhIGRpc3BsYWNlbWVudCwgdXNpbmcgYSB4IGFuIHkgY29tcG9uZW50IHRvIHJlcHJlc2VudFxuICogdGhlIGxlbmd0aCAobWFnbml0dWRlKSBhbmQgZGlyZWN0aW9uLlxuICogXG4gKiBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGEgVmVjdG9yIGFuZCBhIFBvaW50IGlzIGV4cGxhaW5lZCBpbiB0aGlzIHNvdXJjZTpcbiAqIGh0dHA6Ly9tYXRoLnN0YWNrZXhjaGFuZ2UuY29tL2EvNjQ1ODI3XG4gKi9cblxudmFyIFZlY3RvciA9IGZ1bmN0aW9uICgpIHtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyB2ZWN0b3IsIHVzaW5nIGEgeCBhbmQgeSBjb21wb25lbnQgdG8gcmVwcmVzZW50IHRoZVxuICAgICAqIGxlbmd0aCAobWFnbml0dWRlKSBhbmQgZGlyZWN0aW9uIHJlbGF0aXZlIHRvICgwLCAwKS5cbiAgICAgKlxuICAgICAqIEFuIHZlY3RvciBpcyBpbW11dGFibGUuIEFsbCBzdWJzZXF1ZW50IG9wZXJhdGlvbnMgd2lsbCByZXR1cm4gYSBuZXdcbiAgICAgKiB2ZWN0b3IgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCBUaGUgeCBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgVGhlIHkgY29tcG9uZW50LlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBWZWN0b3IoeCwgeSkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVmVjdG9yKTtcblxuICAgICAgICB0aGlzLl94ID0geDtcbiAgICAgICAgdGhpcy5feSA9IHk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHZlY3RvciBmcm9tIGFuIGFycmF5LiBUaGUgZmlyc3QgaW5kZXggaXMgY29uc2lkZXJlZCB0aGUgeFxuICAgICAqIGNvbXBvbmVudCwgdGhlIHNlY29uZCBpbmRleCBpcyBjb25zaWRlcmVkIHRoZSB5IGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IElucHV0IGFycmF5IHdpdGggYXQgbGVhc3QgdHdvIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJuIHtWZWN0b3J9IFJlc3VsdGluZyB2ZWN0b3IuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBEZWZpbml0aW9uIG9mIHRoZSB1bml0IHZlY3Rvci5cbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKFZlY3RvciwgW3tcbiAgICAgICAga2V5OiAnYWRkJyxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgYW5vdGhlciB2ZWN0b3Igb3IgcG9pbnQgdG8gdGhpcyB2ZWN0b3IuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHRoZSBpbnB1dCBpcyBhIHBvaW50LCB0aGUgcmVzdWx0IHdpbGwgYmUgYSBwb2ludCB3aXRoIHRoaXMgdmVjdG9yXG4gICAgICAgICAqIGFzIG9mZnNldC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtQb2ludHxWZWN0b3J9IHRoYXQgUG9pbnQgb3IgdmVjdG9yIHRvIGFkZC5cbiAgICAgICAgICogQHJldHVybiB7UG9pbnR8VmVjdG9yfSBOZXcgVmVjdG9yIGlmIGFkZGluZyB2ZWN0b3IsIHBvaW50IG90aGVyd2lzZS5cbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQodGhhdCkge1xuICAgICAgICAgICAgaWYgKHRoYXQgaW5zdGFuY2VvZiBfUG9pbnQyLmRlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5hZGQodGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMuX3ggKyB0aGF0Ll94LCB0aGlzLl95ICsgdGhhdC5feSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7VmVjdG9yfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc3VidHJhY3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc3VidHJhY3QodGhhdCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy5feCAtIHRoYXQuX3gsIHRoaXMuX3kgLSB0aGF0Ll95KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtWZWN0b3J9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdpbnZlcnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaW52ZXJ0KCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoLXRoaXMuX3gsIC10aGlzLl95KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtWZWN0b3J9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdtdWx0aXBseScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtdWx0aXBseShzY2FsYXIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMuX3ggKiBzY2FsYXIsIHRoaXMuX3kgKiBzY2FsYXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge1ZlY3Rvcn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ211bHRpcGx5WFknLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbXVsdGlwbHlYWShzY2FsYXJYLCBzY2FsYXJZKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLl94ICogc2NhbGFyWCwgdGhpcy5feSAqIHNjYWxhclkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge1ZlY3Rvcn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2RpdmlkZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXZpZGUoc2NhbGFyKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLl94IC8gc2NhbGFyLCB0aGlzLl95IC8gc2NhbGFyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtWZWN0b3J9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdkaXZpZGVYWScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXZpZGVYWShzY2FsYXJYLCBzY2FsYXJZKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLl94IC8gc2NhbGFyWCwgdGhpcy5feSAvIHNjYWxhclkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge1ZlY3Rvcn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ21peCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtaXgodGhhdCkge1xuICAgICAgICAgICAgdmFyIGFtb3VudCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IDAuNSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHkoMSAtIGFtb3VudCkuYWRkKHRoYXQubXVsdGlwbHkoYW1vdW50KSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7VmVjdG9yfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncGVycGVuZGljdWxhcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwZXJwZW5kaWN1bGFyKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoLXRoaXMuX3ksIHRoaXMuX3gpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge1ZlY3Rvcn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NuYXAnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc25hcCh0bykge1xuICAgICAgICAgICAgdmFyIHJvdW5kID0gZnVuY3Rpb24gcm91bmQodmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQodmFsIC8gdG8pICogdG87XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcihyb3VuZCh0aGlzLl94KSwgcm91bmQodGhpcy5feSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2RvdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkb3QodGhhdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ggKiB0aGF0Ll94ICsgdGhpcy5feSAqIHRoYXQuX3k7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYW5nbGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYW5nbGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hdGFuMih0aGlzLl95LCB0aGlzLl94KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdhbmdsZURlZycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhbmdsZURlZygpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmF0YW4yKHRoaXMuX3ksIHRoaXMuX3gpICogMTgwIC8gTWF0aC5QSTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzbG9wZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzbG9wZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl95IC8gdGhpcy5feDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxjdWxhdGUgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIHRoaXMgdmVjdG9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGUgZXhhY3QgbGVuZ3RoIGRvZXNuJ3QgbWF0dGVyLCB0aGlzIG1ldGhvZCBpcyBzbGlnaHRseSBmYXN0ZXJcbiAgICAgICAgICogdGhhbiBgdGhpcy5sZW5ndGhgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzcXVhcmVkIGxlbmd0aCBvZiB0aGlzIHZlY3Rvci5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2xlbmd0aFNxJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxlbmd0aFNxKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ggKiB0aGlzLl94ICsgdGhpcy5feSAqIHRoaXMuX3k7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsY3VsYXRlIHRoZSBsZW5ndGggKG1hZ25pdHVkZSkgb2YgdGhlIHZlY3Rvci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbGVuZ3RoIG9mIHRoZSB2ZWN0b3IuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdsZW5ndGgnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbGVuZ3RoKCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmxlbmd0aFNxKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFttaW5MZW5ndGggZGVzY3JpcHRpb25dXG4gICAgICAgICAqIEBwYXJhbSB7W3R5cGVdfSBsZW5ndGggW2Rlc2NyaXB0aW9uXVxuICAgICAgICAgKiBAcmV0dXJuIHtbdHlwZV19XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdtaW5MZW5ndGgnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbWluTGVuZ3RoKGxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoKCkgPCBsZW5ndGggPyB0aGlzLm5vcm1hbGl6ZShsZW5ndGgpIDogdGhpcztcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbWF4TGVuZ3RoJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1heExlbmd0aChsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCgpID4gbGVuZ3RoID8gdGhpcy5ub3JtYWxpemUobGVuZ3RoKSA6IHRoaXM7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ25vcm1hbGl6ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBub3JtYWxpemUoKSB7XG4gICAgICAgICAgICB2YXIgc2NhbGFyID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gMSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGl2aWRlKHRoaXMubGVuZ3RoKCkpLm11bHRpcGx5KHNjYWxhcik7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3Byb2plY3RPbnRvJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByb2plY3RPbnRvKHRoYXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGF0Lm11bHRpcGx5KHRoaXMuZG90KHRoYXQpIC8gdGhhdC5sZW5ndGhTcSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0IHZlY3RvciBpbnRvIGEgcG9pbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGU6IHRoaXMgaXMgYW4gdXRpbGl0eSBtZXRob2QuIEEgcHJvcGVyIGNvbnZlcnNpb24gZG9lcyBub3QgZXhpc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1BvaW50fSBUaGUgdmVjdG9yIGNvbnZlcnRlZCBhcyBwb2ludC5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvUG9pbnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9Qb2ludCgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgX1BvaW50Mi5kZWZhdWx0KHRoaXMuX3gsIHRoaXMuX3kpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnQgdGhpcyB2ZWN0b3IgaW50byBhbiBhcnJheS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IHJlcHJlc2VudGF0aW9uICh4LCB5KS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvQXJyYXknLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy5feCwgdGhpcy5feV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydCB0aGlzIHZlY3RvciBpbnRvIGFuIG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gKHgsIHkpLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9PYmplY3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9PYmplY3QoKSB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiB0aGlzLl94LCB5OiB0aGlzLl95IH07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydCB0aGlzIHZlY3RvciBpbnRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbiAoeCwgeSkuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiAnKCcgKyB0aGlzLl94ICsgJywgJyArIHRoaXMuX3kgKyAnKSc7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydCB0aGlzIHZlY3RvciBpbnRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uLCB1c2luZyBhIGZpeGVkIG51bWJlclxuICAgICAgICAgKiBvZiBkaWdpdHMgZm9yIGRpc3BsYXlpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaWdpdHMgTnVtYmVyIG9mIGRpZ2l0cyB0byB1c2UgZm9yIHJlcHJlc2VudGF0aW9uLlxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbiAoeCwgeSkuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b0ZpeGVkJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvRml4ZWQoZGlnaXRzKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGlnaXRzICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ051bWJlciBvZiBkaWdpdHMgbXVzdCBiZSBhIG51bWJlci4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAnKCcgKyB0aGlzLl94LnRvRml4ZWQoZGlnaXRzKSArICcsICcgKyB0aGlzLl95LnRvRml4ZWQoZGlnaXRzKSArICcpJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBzaGFsbG93IGNvcHkgb2YgdGhpcyBpbnN0YW5jZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7VmVjdG9yfSBDbG9uZWQgaW5zdGFuY2UuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjbG9uZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMuX3gsIHRoaXMuX3kpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybiB0cnVlIGlmIHRoaXMgdmVjdG9yIGlzIGVxdWFsIHRvIGFub3RoZXIgdmVjdG9yLiBUd28gdmVjdG9ycyBhcmVcbiAgICAgICAgICogZXF1YWwgd2hlbiBib3RoIHggYW5kIHkgY29tcG9uZW50cyBhcmUgZXF1YWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGF0IE90aGVyIGluc3RhbmNlIHRvIGNvbXBhcmUgdG8uXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYm90aCBwb2ludHMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdlcXVhbHMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZXF1YWxzKHRoYXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgPT09IHRoYXQuY29uc3RydWN0b3IubmFtZSAmJiB0aGlzLl94ID09PSB0aGF0Ll94ICYmIHRoaXMuX3kgPT09IHRoYXQuX3k7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZlY3RvciBpcyBkZWZpbmVkIGFuZCBmaW5pdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdmVjdG9yIGlzIGZ1bGx5IGRlZmluZWQgYW5kIHZhbGlkLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaXNWYWxpZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc1ZhbGlkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLl94ID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh0aGlzLl94KSAmJiB0eXBlb2YgdGhpcy5feSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodGhpcy5feSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3gnLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgeCBjb21wb25lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHggY29tcG9uZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5feDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHkgY29tcG9uZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB5IGNvbXBvbmVudC5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3knLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl95O1xuICAgICAgICB9XG4gICAgfV0sIFt7XG4gICAgICAgIGtleTogJ2Zyb21BcnJheScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tQXJyYXkoYXJyYXkpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSB8fCBhcnJheS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYW4gYXJyYXkgd2l0aCBhdCBsZWFzdCB0d28gdmFsdWVzLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoYXJyYXlbMF0sIGFycmF5WzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgdmVjdG9yIGZyb20gYW4gb2JqZWN0LiBUaGUgb2JqZWN0IHNob3VsZCBoYXZlIGFuIHggYW5kIHlcbiAgICAgICAgICogcHJvcGVydHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3QgSW5wdXQgb2JqZWN0IHdpdGggeCBhbmQgeSBwcm9wZXJ0eS5cbiAgICAgICAgICogQHJldHVybiB7VmVjdG9yfSBSZXN1bHRpbmcgdmVjdG9yLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZnJvbU9iamVjdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHR5cGVvZiBvYmplY3QgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9iamVjdCkpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGFuIG9iamVjdC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKG9iamVjdC54LCBvYmplY3QueSk7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gVmVjdG9yO1xufSgpO1xuXG5WZWN0b3IuVW5pdCA9IG5ldyBWZWN0b3IoMSwgMSk7XG5leHBvcnRzLmRlZmF1bHQgPSBWZWN0b3I7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9WZWN0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Point = __webpack_require__(2);\n\nvar _Point2 = _interopRequireDefault(_Point);\n\nvar _Vector = __webpack_require__(4);\n\nvar _Vector2 = _interopRequireDefault(_Vector);\n\nvar _Circle = __webpack_require__(1);\n\nvar _Circle2 = _interopRequireDefault(_Circle);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Immutable rectangle class.\n */\n\nvar Rectangle = function () {\n    /**\n     * Construct a new immutable rectangle of two points.\n     *\n     * @param {Point} a The `A` point..\n     * @param {Point} b The `B` point.\n     * @return {void}\n     */\n\n    function Rectangle(a, b) {\n        _classCallCheck(this, Rectangle);\n\n        this._a = a;\n        this._b = b;\n    }\n\n    /**\n     * Create a new rectangle from an array. The first index should be point\n     * `A` and the second index should be point `B`.\n     *\n     * @param {Array} array Input array with at least two values.\n     * @return {Rectangle} Resulting rectangle.\n     */\n\n\n    _createClass(Rectangle, [{\n        key: 'center',\n\n\n        /**\n         * Calculate the center point of this rectangle.\n         *\n         * @return {Point} Center of this rectangle.\n         */\n        value: function center() {\n            var x = (this._a._x + this._b._x) / 2;\n            var y = (this._a._y + this._b._y) / 2;\n\n            return new _Point2.default(x, y);\n        }\n\n        /**\n         * Calculate the center point offset.\n         *\n         * @return {Vector} Relative center point offset of this rectangle.\n         */\n\n    }, {\n        key: 'centerOffset',\n        value: function centerOffset() {\n            return this.center().subtract(this._a);\n        }\n\n        /**\n         * Merge two rectangles, taking the bouding box that contains both\n         * rectangles.\n         *\n         * @param {Rectangle} rectangle Other rectangle to merge with.\n         * @return {Rectangle} New rectangle containing both rectangles.\n         */\n\n    }, {\n        key: 'merge',\n        value: function merge(rectangle) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (!(rectangle instanceof Rectangle)) {\n                    throw new Error('Must merge with another rectangle.');\n                }\n            }\n\n            var a = new _Point2.default(Math.min(this._a._x, this._b._x, rectangle._a._x, rectangle._b._x), Math.min(this._a._y, this._b._y, rectangle._a._y, rectangle._b._y));\n            var b = new _Point2.default(Math.max(this._a._x, this._b._x, rectangle._a._x, rectangle._b._x), Math.max(this._a._y, this._b._y, rectangle._a._y, rectangle._b._y));\n\n            return new Rectangle(a, b);\n        }\n\n        /**\n         * Move the rectangle by applying an offset to the points `a` and `b`.\n         *\n         * @param {Vector} vector Offset vector.\n         * @return {Rectangle} Moved rectangle.\n         */\n\n    }, {\n        key: 'move',\n        value: function move(vector) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (!(vector instanceof _Vector2.default)) {\n                    throw new Error('Offset must be a vector.');\n                }\n            }\n\n            return new Rectangle(this._a.add(vector), this._b.add(vector));\n        }\n\n        /**\n         * Move the `a` point and `b` point of this rectangle individually.\n         *\n         * @param {Vector} vectorA Offset vector for `a` point.\n         * @param {Vector} vectorB Offset vector for `b` point.\n         * @return {Rectangle} Moved rectangle.\n         */\n\n    }, {\n        key: 'moveAB',\n        value: function moveAB(vectorA, vectorB) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (!(vectorA instanceof _Vector2.default) || !(vectorB instanceof _Vector2.default)) {\n                    throw new Error('Offset must be a vector.');\n                }\n            }\n\n            return new Rectangle(this._a.add(vectorA), this._b.add(vectorB));\n        }\n\n        /**\n         * Returns true if a given point is on this rectangle.\n         *\n         * @param {Point} point Point to test with.\n         * @return {boolean} True if point is within rectangle.\n         */\n\n    }, {\n        key: 'containsPoint',\n        value: function containsPoint(point) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (!(point instanceof _Point2.default)) {\n                    throw new Error('Must be a point.');\n                }\n            }\n\n            return (point._x >= this._a._x && point._x <= this._b._x || point._x >= this._b._x && point._x <= this._a._x) && (point._y >= this._a._y && point._y <= this._b._y || point._y >= this._b._y && point._y <= this._a._y);\n        }\n\n        /**\n         * Returns true if a given rectangle is within this rectangle. That is,\n         * both point `A` and `B` are within this rectangle.\n         *\n         * @param {Rectangle} rectangle The rectangle to check for.\n         * @return {booleam} True if the rectangle is within this rectangle.\n         */\n\n    }, {\n        key: 'containsRectangle',\n        value: function containsRectangle(rectangle) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (!(rectangle instanceof Rectangle)) {\n                    throw new Error('Must be a rectangle.');\n                }\n            }\n\n            return this.containsPoint(rectangle.a) && this.containsPoint(rectangle.b);\n        }\n\n        /**\n         * Returns true if a given rectangle collides with this rectangle.\n         *\n         * @param {Rectangle} rectangle Other rectangle to compare with.\n         * @return {boolean} True if the given rectangle collides with this one.\n         */\n\n    }, {\n        key: 'collidesRectangle',\n        value: function collidesRectangle(rectangle) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (!(rectangle instanceof Rectangle)) {\n                    throw new Error('Must be a rectangle.');\n                }\n            }\n\n            return this._a._x < rectangle._b._x && this._b._x > rectangle._a._x && this._a._y < rectangle._b._y && this._b._y > rectangle._a._y;\n        }\n\n        /**\n         * Returns true if a given circle collides with this rectangle.\n         *\n         * @param {Circle} circle Other circle to compare with.\n         * @return {boolean} True if the given circles collides with this one.\n         */\n\n    }, {\n        key: 'collidesCircle',\n        value: function collidesCircle(circle) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (!(circle instanceof _Circle2.default)) {\n                    throw new Error('Must be a circle.');\n                }\n            }\n\n            var clamp = function clamp(value, min, max) {\n                return Math.max(min, Math.min(max, value));\n            };\n\n            var closest = new _Point2.default(clamp(circle._a._x, this._a._x, this._b._x), clamp(circle._a._y, this._a._y, this._b._y));\n\n            return closest.distanceSq(circle._a) < circle._r * circle._r;\n        }\n\n        /**\n         * Calculate the area of the given rectangle.\n         *\n         * @return {number} The rectangle area.\n         */\n\n    }, {\n        key: 'area',\n        value: function area() {\n            return (this._b._x - this._a._x) * (this._b._y - this._a._y);\n        }\n\n        /**\n         * Return an array representation of this instance.\n         *\n         * @return {Array} Array representation ([a, b]).\n         */\n\n    }, {\n        key: 'toArray',\n        value: function toArray() {\n            return [this._a.toArray(), this._b.toArray()];\n        }\n\n        /**\n         * Return an object representation of this instance.\n         *\n         * @return {object} Object representation (a, b).\n         */\n\n    }, {\n        key: 'toObject',\n        value: function toObject() {\n            return {\n                a: this._a.toObject(),\n                b: this._b.toObject()\n            };\n        }\n\n        /**\n         * Return a string representation of this rectangle.\n         *\n         * @return {string} String representation.\n         */\n\n    }, {\n        key: 'toString',\n        value: function toString() {\n            return '(' + this._a.toString() + ', ' + this._b.toString() + ')';\n        }\n\n        /**\n         * Create a shallow copy of this instance.\n         *\n         * @return {Rectangle} Cloned instance.\n         */\n\n    }, {\n        key: 'clone',\n        value: function clone() {\n            return new Rectangle(this._a, this._b);\n        }\n\n        /**\n         * Return a normalize rectangle, with the `A` point in the top-left\n         * position and the `B` point in the bottom-right position.\n         *\n         * @return {Rectangle} The normalized rectangle.\n         */\n\n    }, {\n        key: 'normalize',\n        value: function normalize() {\n            return new Rectangle(new _Point2.default(this.left, this.top), new _Point2.default(this.right, this.bottom));\n        }\n\n        /**\n         * Return true if this rectangle is equal to another rectangle. Two\n         * rectangles are equal if and only if both points are equal. This means\n         * if two rectangles have the same left, right, top and bottom, they\n         * may not be equal, becaus they can be defined from different points.\n         *\n         * @param {object} that Other instance to compare to.\n         * @return {boolean} True if both rectangles are equal, false otherwise.\n         */\n\n    }, {\n        key: 'equals',\n        value: function equals(that) {\n            return this.constructor.name === that.constructor.name && this._a.equals(that._b) && this._b.equals(that._b);\n        }\n\n        /**\n         * Return true if the rectangle is defined and finite.\n         *\n         * @return {Boolean} True if rectangle is valid.\n         */\n\n    }, {\n        key: 'isValid',\n        value: function isValid() {\n            return this._a.isValid() && this._b.isValid();\n        }\n    }, {\n        key: 'a',\n\n\n        /**\n         * Return point `A`.\n         *\n         * @return {Point} Point `A`.\n         */\n        get: function get() {\n            return this._a;\n        }\n\n        /**\n         * Return point `B`.\n         *\n         * @return {Point} Point `B`.\n         */\n\n    }, {\n        key: 'b',\n        get: function get() {\n            return this._b;\n        }\n\n        /**\n         * Return the left x coordinate.\n         *\n         * @return {number} Left x coordinate.\n         */\n\n    }, {\n        key: 'left',\n        get: function get() {\n            //return Math.min(this._a._x, this._b._x);\n            return this._a._x;\n        }\n\n        /**\n         * Return the right x coordinate.\n         *\n         * @return {number} Right x coordinate.\n         */\n\n    }, {\n        key: 'right',\n        get: function get() {\n            //return Math.max(this._a._x, this._b._x);\n            return this._b._x;\n        }\n\n        /**\n         * Return the top y coordinate.\n         *\n         * @return {number} Top y coordinate.\n         */\n\n    }, {\n        key: 'top',\n        get: function get() {\n            //return Math.min(this._a._y, this._b._y);\n            return this._a._y;\n        }\n\n        /**\n         * Return the bottom y coordinate.\n         *\n         * @return {number} Bottom y coordinate.\n         */\n\n    }, {\n        key: 'bottom',\n        get: function get() {\n            //return Math.max(this._a._y, this._b._y);\n            return this._b._y;\n        }\n\n        /**\n         * Return the width of this rectangle, which is the difference between\n         * `this.right` and `this.left`.\n         *\n         * @return {number} Width of the rectangle.\n         */\n\n    }, {\n        key: 'width',\n        get: function get() {\n            return this.right - this.left;\n        }\n\n        /**\n         * Return the height of this rectangle, which is the difference between\n         * `this.bottom` and `this.top`.\n         *\n         * @return {number} Height of the rectangle.\n         */\n\n    }, {\n        key: 'height',\n        get: function get() {\n            return this.bottom - this.top;\n        }\n    }], [{\n        key: 'fromArray',\n        value: function fromArray(array) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (!Array.isArray(array) || array.length < 2) {\n                    throw new Error('Expected an array with at least two values.');\n                }\n            }\n\n            return new Rectangle(_Point2.default.fromArray(array[0]), _Point2.default.fromArray(array[1]));\n        }\n\n        /**\n         * Create a new rectangle from an object. The object should have an `a` and\n         * `b` property.\n         *\n         * @param {object} object Input object with `a` and `b` property.\n         * @return {Vector} Resulting rectangle.\n         */\n\n    }, {\n        key: 'fromObject',\n        value: function fromObject(object) {\n            if (process.env.NODE_ENV !== 'production') {\n                if ((typeof object === 'undefined' ? 'undefined' : _typeof(object)) !== 'object') {\n                    throw new Error('Expected an object.');\n                }\n            }\n\n            return new Rectangle(_Point2.default.fromObject(object.a), _Point2.default.fromObject(object.b));\n        }\n    }]);\n\n    return Rectangle;\n}();\n\nexports.default = Rectangle;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9SZWN0YW5nbGUuanM/NmMzOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfUG9pbnQgPSByZXF1aXJlKCcuL1BvaW50Jyk7XG5cbnZhciBfUG9pbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUG9pbnQpO1xuXG52YXIgX1ZlY3RvciA9IHJlcXVpcmUoJy4vVmVjdG9yJyk7XG5cbnZhciBfVmVjdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1ZlY3Rvcik7XG5cbnZhciBfQ2lyY2xlID0gcmVxdWlyZSgnLi9DaXJjbGUnKTtcblxudmFyIF9DaXJjbGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2lyY2xlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBJbW11dGFibGUgcmVjdGFuZ2xlIGNsYXNzLlxuICovXG5cbnZhciBSZWN0YW5nbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IGltbXV0YWJsZSByZWN0YW5nbGUgb2YgdHdvIHBvaW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IGEgVGhlIGBBYCBwb2ludC4uXG4gICAgICogQHBhcmFtIHtQb2ludH0gYiBUaGUgYEJgIHBvaW50LlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBSZWN0YW5nbGUoYSwgYikge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVjdGFuZ2xlKTtcblxuICAgICAgICB0aGlzLl9hID0gYTtcbiAgICAgICAgdGhpcy5fYiA9IGI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHJlY3RhbmdsZSBmcm9tIGFuIGFycmF5LiBUaGUgZmlyc3QgaW5kZXggc2hvdWxkIGJlIHBvaW50XG4gICAgICogYEFgIGFuZCB0aGUgc2Vjb25kIGluZGV4IHNob3VsZCBiZSBwb2ludCBgQmAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBJbnB1dCBhcnJheSB3aXRoIGF0IGxlYXN0IHR3byB2YWx1ZXMuXG4gICAgICogQHJldHVybiB7UmVjdGFuZ2xlfSBSZXN1bHRpbmcgcmVjdGFuZ2xlLlxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoUmVjdGFuZ2xlLCBbe1xuICAgICAgICBrZXk6ICdjZW50ZXInLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGN1bGF0ZSB0aGUgY2VudGVyIHBvaW50IG9mIHRoaXMgcmVjdGFuZ2xlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtQb2ludH0gQ2VudGVyIG9mIHRoaXMgcmVjdGFuZ2xlLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNlbnRlcigpIHtcbiAgICAgICAgICAgIHZhciB4ID0gKHRoaXMuX2EuX3ggKyB0aGlzLl9iLl94KSAvIDI7XG4gICAgICAgICAgICB2YXIgeSA9ICh0aGlzLl9hLl95ICsgdGhpcy5fYi5feSkgLyAyO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IF9Qb2ludDIuZGVmYXVsdCh4LCB5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxjdWxhdGUgdGhlIGNlbnRlciBwb2ludCBvZmZzZXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1ZlY3Rvcn0gUmVsYXRpdmUgY2VudGVyIHBvaW50IG9mZnNldCBvZiB0aGlzIHJlY3RhbmdsZS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NlbnRlck9mZnNldCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjZW50ZXJPZmZzZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jZW50ZXIoKS5zdWJ0cmFjdCh0aGlzLl9hKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXJnZSB0d28gcmVjdGFuZ2xlcywgdGFraW5nIHRoZSBib3VkaW5nIGJveCB0aGF0IGNvbnRhaW5zIGJvdGhcbiAgICAgICAgICogcmVjdGFuZ2xlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtSZWN0YW5nbGV9IHJlY3RhbmdsZSBPdGhlciByZWN0YW5nbGUgdG8gbWVyZ2Ugd2l0aC5cbiAgICAgICAgICogQHJldHVybiB7UmVjdGFuZ2xlfSBOZXcgcmVjdGFuZ2xlIGNvbnRhaW5pbmcgYm90aCByZWN0YW5nbGVzLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbWVyZ2UnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbWVyZ2UocmVjdGFuZ2xlKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGlmICghKHJlY3RhbmdsZSBpbnN0YW5jZW9mIFJlY3RhbmdsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IG1lcmdlIHdpdGggYW5vdGhlciByZWN0YW5nbGUuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYSA9IG5ldyBfUG9pbnQyLmRlZmF1bHQoTWF0aC5taW4odGhpcy5fYS5feCwgdGhpcy5fYi5feCwgcmVjdGFuZ2xlLl9hLl94LCByZWN0YW5nbGUuX2IuX3gpLCBNYXRoLm1pbih0aGlzLl9hLl95LCB0aGlzLl9iLl95LCByZWN0YW5nbGUuX2EuX3ksIHJlY3RhbmdsZS5fYi5feSkpO1xuICAgICAgICAgICAgdmFyIGIgPSBuZXcgX1BvaW50Mi5kZWZhdWx0KE1hdGgubWF4KHRoaXMuX2EuX3gsIHRoaXMuX2IuX3gsIHJlY3RhbmdsZS5fYS5feCwgcmVjdGFuZ2xlLl9iLl94KSwgTWF0aC5tYXgodGhpcy5fYS5feSwgdGhpcy5fYi5feSwgcmVjdGFuZ2xlLl9hLl95LCByZWN0YW5nbGUuX2IuX3kpKTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUoYSwgYik7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogTW92ZSB0aGUgcmVjdGFuZ2xlIGJ5IGFwcGx5aW5nIGFuIG9mZnNldCB0byB0aGUgcG9pbnRzIGBhYCBhbmQgYGJgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3Rvcn0gdmVjdG9yIE9mZnNldCB2ZWN0b3IuXG4gICAgICAgICAqIEByZXR1cm4ge1JlY3RhbmdsZX0gTW92ZWQgcmVjdGFuZ2xlLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbW92ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlKHZlY3Rvcikge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpZiAoISh2ZWN0b3IgaW5zdGFuY2VvZiBfVmVjdG9yMi5kZWZhdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09mZnNldCBtdXN0IGJlIGEgdmVjdG9yLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUodGhpcy5fYS5hZGQodmVjdG9yKSwgdGhpcy5fYi5hZGQodmVjdG9yKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogTW92ZSB0aGUgYGFgIHBvaW50IGFuZCBgYmAgcG9pbnQgb2YgdGhpcyByZWN0YW5nbGUgaW5kaXZpZHVhbGx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3Rvcn0gdmVjdG9yQSBPZmZzZXQgdmVjdG9yIGZvciBgYWAgcG9pbnQuXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yfSB2ZWN0b3JCIE9mZnNldCB2ZWN0b3IgZm9yIGBiYCBwb2ludC5cbiAgICAgICAgICogQHJldHVybiB7UmVjdGFuZ2xlfSBNb3ZlZCByZWN0YW5nbGUuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdtb3ZlQUInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZUFCKHZlY3RvckEsIHZlY3RvckIpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEodmVjdG9yQSBpbnN0YW5jZW9mIF9WZWN0b3IyLmRlZmF1bHQpIHx8ICEodmVjdG9yQiBpbnN0YW5jZW9mIF9WZWN0b3IyLmRlZmF1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT2Zmc2V0IG11c3QgYmUgYSB2ZWN0b3IuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLl9hLmFkZCh2ZWN0b3JBKSwgdGhpcy5fYi5hZGQodmVjdG9yQikpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiBhIGdpdmVuIHBvaW50IGlzIG9uIHRoaXMgcmVjdGFuZ2xlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludCBQb2ludCB0byB0ZXN0IHdpdGguXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgcG9pbnQgaXMgd2l0aGluIHJlY3RhbmdsZS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NvbnRhaW5zUG9pbnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29udGFpbnNQb2ludChwb2ludCkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShwb2ludCBpbnN0YW5jZW9mIF9Qb2ludDIuZGVmYXVsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IGJlIGEgcG9pbnQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gKHBvaW50Ll94ID49IHRoaXMuX2EuX3ggJiYgcG9pbnQuX3ggPD0gdGhpcy5fYi5feCB8fCBwb2ludC5feCA+PSB0aGlzLl9iLl94ICYmIHBvaW50Ll94IDw9IHRoaXMuX2EuX3gpICYmIChwb2ludC5feSA+PSB0aGlzLl9hLl95ICYmIHBvaW50Ll95IDw9IHRoaXMuX2IuX3kgfHwgcG9pbnQuX3kgPj0gdGhpcy5fYi5feSAmJiBwb2ludC5feSA8PSB0aGlzLl9hLl95KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgYSBnaXZlbiByZWN0YW5nbGUgaXMgd2l0aGluIHRoaXMgcmVjdGFuZ2xlLiBUaGF0IGlzLFxuICAgICAgICAgKiBib3RoIHBvaW50IGBBYCBhbmQgYEJgIGFyZSB3aXRoaW4gdGhpcyByZWN0YW5nbGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0YW5nbGUgVGhlIHJlY3RhbmdsZSB0byBjaGVjayBmb3IuXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW19IFRydWUgaWYgdGhlIHJlY3RhbmdsZSBpcyB3aXRoaW4gdGhpcyByZWN0YW5nbGUuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjb250YWluc1JlY3RhbmdsZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb250YWluc1JlY3RhbmdsZShyZWN0YW5nbGUpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEocmVjdGFuZ2xlIGluc3RhbmNlb2YgUmVjdGFuZ2xlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgYmUgYSByZWN0YW5nbGUuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250YWluc1BvaW50KHJlY3RhbmdsZS5hKSAmJiB0aGlzLmNvbnRhaW5zUG9pbnQocmVjdGFuZ2xlLmIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiBhIGdpdmVuIHJlY3RhbmdsZSBjb2xsaWRlcyB3aXRoIHRoaXMgcmVjdGFuZ2xlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gcmVjdGFuZ2xlIE90aGVyIHJlY3RhbmdsZSB0byBjb21wYXJlIHdpdGguXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGdpdmVuIHJlY3RhbmdsZSBjb2xsaWRlcyB3aXRoIHRoaXMgb25lLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY29sbGlkZXNSZWN0YW5nbGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29sbGlkZXNSZWN0YW5nbGUocmVjdGFuZ2xlKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGlmICghKHJlY3RhbmdsZSBpbnN0YW5jZW9mIFJlY3RhbmdsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IGJlIGEgcmVjdGFuZ2xlLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2EuX3ggPCByZWN0YW5nbGUuX2IuX3ggJiYgdGhpcy5fYi5feCA+IHJlY3RhbmdsZS5fYS5feCAmJiB0aGlzLl9hLl95IDwgcmVjdGFuZ2xlLl9iLl95ICYmIHRoaXMuX2IuX3kgPiByZWN0YW5nbGUuX2EuX3k7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIGEgZ2l2ZW4gY2lyY2xlIGNvbGxpZGVzIHdpdGggdGhpcyByZWN0YW5nbGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7Q2lyY2xlfSBjaXJjbGUgT3RoZXIgY2lyY2xlIHRvIGNvbXBhcmUgd2l0aC5cbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZ2l2ZW4gY2lyY2xlcyBjb2xsaWRlcyB3aXRoIHRoaXMgb25lLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY29sbGlkZXNDaXJjbGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29sbGlkZXNDaXJjbGUoY2lyY2xlKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGlmICghKGNpcmNsZSBpbnN0YW5jZW9mIF9DaXJjbGUyLmRlZmF1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBiZSBhIGNpcmNsZS4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjbGFtcCA9IGZ1bmN0aW9uIGNsYW1wKHZhbHVlLCBtaW4sIG1heCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgdmFsdWUpKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBjbG9zZXN0ID0gbmV3IF9Qb2ludDIuZGVmYXVsdChjbGFtcChjaXJjbGUuX2EuX3gsIHRoaXMuX2EuX3gsIHRoaXMuX2IuX3gpLCBjbGFtcChjaXJjbGUuX2EuX3ksIHRoaXMuX2EuX3ksIHRoaXMuX2IuX3kpKTtcblxuICAgICAgICAgICAgcmV0dXJuIGNsb3Nlc3QuZGlzdGFuY2VTcShjaXJjbGUuX2EpIDwgY2lyY2xlLl9yICogY2lyY2xlLl9yO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGN1bGF0ZSB0aGUgYXJlYSBvZiB0aGUgZ2l2ZW4gcmVjdGFuZ2xlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSByZWN0YW5nbGUgYXJlYS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2FyZWEnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXJlYSgpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5fYi5feCAtIHRoaXMuX2EuX3gpICogKHRoaXMuX2IuX3kgLSB0aGlzLl9hLl95KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gYW4gYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBpbnN0YW5jZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IHJlcHJlc2VudGF0aW9uIChbYSwgYl0pLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9BcnJheScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0FycmF5KCkge1xuICAgICAgICAgICAgcmV0dXJuIFt0aGlzLl9hLnRvQXJyYXkoKSwgdGhpcy5fYi50b0FycmF5KCldO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybiBhbiBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBpbnN0YW5jZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gKGEsIGIpLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9PYmplY3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9PYmplY3QoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGE6IHRoaXMuX2EudG9PYmplY3QoKSxcbiAgICAgICAgICAgICAgICBiOiB0aGlzLl9iLnRvT2JqZWN0KClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcmVjdGFuZ2xlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbi5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuICcoJyArIHRoaXMuX2EudG9TdHJpbmcoKSArICcsICcgKyB0aGlzLl9iLnRvU3RyaW5nKCkgKyAnKSc7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgc2hhbGxvdyBjb3B5IG9mIHRoaXMgaW5zdGFuY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1JlY3RhbmdsZX0gQ2xvbmVkIGluc3RhbmNlLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2xvbmUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLl9hLCB0aGlzLl9iKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gYSBub3JtYWxpemUgcmVjdGFuZ2xlLCB3aXRoIHRoZSBgQWAgcG9pbnQgaW4gdGhlIHRvcC1sZWZ0XG4gICAgICAgICAqIHBvc2l0aW9uIGFuZCB0aGUgYEJgIHBvaW50IGluIHRoZSBib3R0b20tcmlnaHQgcG9zaXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1JlY3RhbmdsZX0gVGhlIG5vcm1hbGl6ZWQgcmVjdGFuZ2xlLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbm9ybWFsaXplJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG5vcm1hbGl6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKG5ldyBfUG9pbnQyLmRlZmF1bHQodGhpcy5sZWZ0LCB0aGlzLnRvcCksIG5ldyBfUG9pbnQyLmRlZmF1bHQodGhpcy5yaWdodCwgdGhpcy5ib3R0b20pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGlzIHJlY3RhbmdsZSBpcyBlcXVhbCB0byBhbm90aGVyIHJlY3RhbmdsZS4gVHdvXG4gICAgICAgICAqIHJlY3RhbmdsZXMgYXJlIGVxdWFsIGlmIGFuZCBvbmx5IGlmIGJvdGggcG9pbnRzIGFyZSBlcXVhbC4gVGhpcyBtZWFuc1xuICAgICAgICAgKiBpZiB0d28gcmVjdGFuZ2xlcyBoYXZlIHRoZSBzYW1lIGxlZnQsIHJpZ2h0LCB0b3AgYW5kIGJvdHRvbSwgdGhleVxuICAgICAgICAgKiBtYXkgbm90IGJlIGVxdWFsLCBiZWNhdXMgdGhleSBjYW4gYmUgZGVmaW5lZCBmcm9tIGRpZmZlcmVudCBwb2ludHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGF0IE90aGVyIGluc3RhbmNlIHRvIGNvbXBhcmUgdG8uXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYm90aCByZWN0YW5nbGVzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZXF1YWxzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVxdWFscyh0aGF0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lID09PSB0aGF0LmNvbnN0cnVjdG9yLm5hbWUgJiYgdGhpcy5fYS5lcXVhbHModGhhdC5fYikgJiYgdGhpcy5fYi5lcXVhbHModGhhdC5fYik7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHJlY3RhbmdsZSBpcyBkZWZpbmVkIGFuZCBmaW5pdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgcmVjdGFuZ2xlIGlzIHZhbGlkLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaXNWYWxpZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc1ZhbGlkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2EuaXNWYWxpZCgpICYmIHRoaXMuX2IuaXNWYWxpZCgpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdhJyxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gcG9pbnQgYEFgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtQb2ludH0gUG9pbnQgYEFgLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gcG9pbnQgYEJgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtQb2ludH0gUG9pbnQgYEJgLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYicsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2I7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIHRoZSBsZWZ0IHggY29vcmRpbmF0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfSBMZWZ0IHggY29vcmRpbmF0ZS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2xlZnQnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIC8vcmV0dXJuIE1hdGgubWluKHRoaXMuX2EuX3gsIHRoaXMuX2IuX3gpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2EuX3g7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIHRoZSByaWdodCB4IGNvb3JkaW5hdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn0gUmlnaHQgeCBjb29yZGluYXRlLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmlnaHQnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIC8vcmV0dXJuIE1hdGgubWF4KHRoaXMuX2EuX3gsIHRoaXMuX2IuX3gpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2IuX3g7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIHRoZSB0b3AgeSBjb29yZGluYXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRvcCB5IGNvb3JkaW5hdGUuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b3AnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIC8vcmV0dXJuIE1hdGgubWluKHRoaXMuX2EuX3ksIHRoaXMuX2IuX3kpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2EuX3k7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIHRoZSBib3R0b20geSBjb29yZGluYXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IEJvdHRvbSB5IGNvb3JkaW5hdGUuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdib3R0b20nLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIC8vcmV0dXJuIE1hdGgubWF4KHRoaXMuX2EuX3ksIHRoaXMuX2IuX3kpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2IuX3k7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIHRoZSB3aWR0aCBvZiB0aGlzIHJlY3RhbmdsZSwgd2hpY2ggaXMgdGhlIGRpZmZlcmVuY2UgYmV0d2VlblxuICAgICAgICAgKiBgdGhpcy5yaWdodGAgYW5kIGB0aGlzLmxlZnRgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFdpZHRoIG9mIHRoZSByZWN0YW5nbGUuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd3aWR0aCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmlnaHQgLSB0aGlzLmxlZnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIHRoZSBoZWlnaHQgb2YgdGhpcyByZWN0YW5nbGUsIHdoaWNoIGlzIHRoZSBkaWZmZXJlbmNlIGJldHdlZW5cbiAgICAgICAgICogYHRoaXMuYm90dG9tYCBhbmQgYHRoaXMudG9wYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfSBIZWlnaHQgb2YgdGhlIHJlY3RhbmdsZS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2hlaWdodCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm90dG9tIC0gdGhpcy50b3A7XG4gICAgICAgIH1cbiAgICB9XSwgW3tcbiAgICAgICAga2V5OiAnZnJvbUFycmF5JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21BcnJheShhcnJheSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpIHx8IGFycmF5Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhbiBhcnJheSB3aXRoIGF0IGxlYXN0IHR3byB2YWx1ZXMuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZShfUG9pbnQyLmRlZmF1bHQuZnJvbUFycmF5KGFycmF5WzBdKSwgX1BvaW50Mi5kZWZhdWx0LmZyb21BcnJheShhcnJheVsxXSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyByZWN0YW5nbGUgZnJvbSBhbiBvYmplY3QuIFRoZSBvYmplY3Qgc2hvdWxkIGhhdmUgYW4gYGFgIGFuZFxuICAgICAgICAgKiBgYmAgcHJvcGVydHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3QgSW5wdXQgb2JqZWN0IHdpdGggYGFgIGFuZCBgYmAgcHJvcGVydHkuXG4gICAgICAgICAqIEByZXR1cm4ge1ZlY3Rvcn0gUmVzdWx0aW5nIHJlY3RhbmdsZS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Zyb21PYmplY3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKCh0eXBlb2Ygb2JqZWN0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvYmplY3QpKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhbiBvYmplY3QuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZShfUG9pbnQyLmRlZmF1bHQuZnJvbU9iamVjdChvYmplY3QuYSksIF9Qb2ludDIuZGVmYXVsdC5mcm9tT2JqZWN0KG9iamVjdC5iKSk7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gUmVjdGFuZ2xlO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBSZWN0YW5nbGU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9SZWN0YW5nbGUuanNcbiAqKiBtb2R1bGUgaWQgPSA1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }
/******/ ]);