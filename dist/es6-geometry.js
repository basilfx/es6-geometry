/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Vector = exports.Rectangle = exports.Point = exports.LineSegment = exports.Line = exports.Circle = undefined;\n\nvar _Circle = __webpack_require__(\"./src/Circle.js\");\n\nvar _Circle2 = _interopRequireDefault(_Circle);\n\nvar _Line = __webpack_require__(\"./src/Line.js\");\n\nvar _Line2 = _interopRequireDefault(_Line);\n\nvar _LineSegment = __webpack_require__(\"./src/LineSegment.js\");\n\nvar _LineSegment2 = _interopRequireDefault(_LineSegment);\n\nvar _Point = __webpack_require__(\"./src/Point.js\");\n\nvar _Point2 = _interopRequireDefault(_Point);\n\nvar _Rectangle = __webpack_require__(\"./src/Rectangle.js\");\n\nvar _Rectangle2 = _interopRequireDefault(_Rectangle);\n\nvar _Vector = __webpack_require__(\"./src/Vector.js\");\n\nvar _Vector2 = _interopRequireDefault(_Vector);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.Circle = _Circle2.default;\nexports.Line = _Line2.default;\nexports.LineSegment = _LineSegment2.default;\nexports.Point = _Point2.default;\nexports.Rectangle = _Rectangle2.default;\nexports.Vector = _Vector2.default;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9pbmRleC5qcz9jODcyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5WZWN0b3IgPSBleHBvcnRzLlJlY3RhbmdsZSA9IGV4cG9ydHMuUG9pbnQgPSBleHBvcnRzLkxpbmVTZWdtZW50ID0gZXhwb3J0cy5MaW5lID0gZXhwb3J0cy5DaXJjbGUgPSB1bmRlZmluZWQ7XG5cbnZhciBfQ2lyY2xlID0gcmVxdWlyZSgnLi9DaXJjbGUnKTtcblxudmFyIF9DaXJjbGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2lyY2xlKTtcblxudmFyIF9MaW5lID0gcmVxdWlyZSgnLi9MaW5lJyk7XG5cbnZhciBfTGluZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9MaW5lKTtcblxudmFyIF9MaW5lU2VnbWVudCA9IHJlcXVpcmUoJy4vTGluZVNlZ21lbnQnKTtcblxudmFyIF9MaW5lU2VnbWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9MaW5lU2VnbWVudCk7XG5cbnZhciBfUG9pbnQgPSByZXF1aXJlKCcuL1BvaW50Jyk7XG5cbnZhciBfUG9pbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUG9pbnQpO1xuXG52YXIgX1JlY3RhbmdsZSA9IHJlcXVpcmUoJy4vUmVjdGFuZ2xlJyk7XG5cbnZhciBfUmVjdGFuZ2xlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JlY3RhbmdsZSk7XG5cbnZhciBfVmVjdG9yID0gcmVxdWlyZSgnLi9WZWN0b3InKTtcblxudmFyIF9WZWN0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVmVjdG9yKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5DaXJjbGUgPSBfQ2lyY2xlMi5kZWZhdWx0O1xuZXhwb3J0cy5MaW5lID0gX0xpbmUyLmRlZmF1bHQ7XG5leHBvcnRzLkxpbmVTZWdtZW50ID0gX0xpbmVTZWdtZW50Mi5kZWZhdWx0O1xuZXhwb3J0cy5Qb2ludCA9IF9Qb2ludDIuZGVmYXVsdDtcbmV4cG9ydHMuUmVjdGFuZ2xlID0gX1JlY3RhbmdsZTIuZGVmYXVsdDtcbmV4cG9ydHMuVmVjdG9yID0gX1ZlY3RvcjIuZGVmYXVsdDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },

/***/ "./src/Circle.js":
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Point = __webpack_require__(\"./src/Point.js\");\n\nvar _Point2 = _interopRequireDefault(_Point);\n\nvar _Rectangle = __webpack_require__(\"./src/Rectangle.js\");\n\nvar _Rectangle2 = _interopRequireDefault(_Rectangle);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Immutable circle class.\n */\n\nvar Circle = function () {\n    /**\n     * Construct a new circle using center point `A` and radius `r`.\n     *\n     * @param {Point} a Center point `A`.\n     * @param {number} r The radius `r`.\n     * @return {void}\n     */\n\n    function Circle(a, r) {\n        _classCallCheck(this, Circle);\n\n        this._a = a;\n        this._r = r;\n    }\n\n    /**\n     * Get the circle center point.\n     *\n     * @return {Point} Center point.\n     */\n\n\n    _createClass(Circle, [{\n        key: 'toRectangle',\n\n\n        /**\n         * Convert this circle to a rectangle that contains this circle exactly.\n         *\n         * @return {Rectangle} Converted rectangle.\n         */\n        value: function toRectangle() {\n            var a = new _Point2.default(this._a._x - this.radius, this._a._y - this.radius);\n            var b = new _Point2.default(this._a._x + this.radius, this._a._y + this.radius);\n\n            return new _Rectangle2.default(a, b);\n        }\n\n        /**\n         * Convert this circle into an object.\n         *\n         * @return {object} Object representation (x, y, r).\n         */\n\n    }, {\n        key: 'toObject',\n        value: function toObject() {\n            return {\n                x: this._a._x,\n                y: this._a._y,\n                r: this._r\n            };\n        }\n\n        /**\n         * Convert this circle into an array.\n         *\n         * @return {Array} Array representation (x, y, r).\n         */\n\n    }, {\n        key: 'toArray',\n        value: function toArray() {\n            return [this._a._x, this._a._y, this._r];\n        }\n\n        /**\n         * Convert this circle into a string representation.\n         *\n         * @return {string} String representation (x, y, r).\n         */\n\n    }, {\n        key: 'toString',\n        value: function toString() {\n            return '(' + this._a._x + ', ' + this._a._y + ', ' + this._r + ')';\n        }\n\n        /**\n         * Create a shallow copy of this instance.\n         *\n         * @return {Circle} Cloned instance.\n         */\n\n    }, {\n        key: 'clone',\n        value: function clone() {\n            return new Circle(this._a, this._r);\n        }\n\n        /**\n         * Return true if this circle is equal to another circle. Two circles are\n         * equal if and only if the center point and radius are equal.\n         *\n         * @param {object} that Other instance to compare to.\n         * @return {boolean} True if both circles are equal, false otherwise.\n         */\n\n    }, {\n        key: 'equals',\n        value: function equals(that) {\n            return this.constructor.name === that.constructor.name && this._a.equals(that._a) && this._r === that._r;\n        }\n\n        /**\n         * Return true if the circle is defined, finite and valid.\n         *\n         * @return {Boolean} True if the circle is fully defined, finite and valid.\n         */\n\n    }, {\n        key: 'isValid',\n        value: function isValid() {\n            return this._a.isValid() && typeof this._r === 'number' && isFinite(this._r) && this._r >= 0;\n        }\n    }, {\n        key: 'a',\n        get: function get() {\n            return this._a;\n        }\n\n        /**\n         * Get the circle center x coordinate. Shortcut for `this.a.x`.\n         *\n         * @return {number} Circle center x coordinate.\n         */\n\n    }, {\n        key: 'x',\n        get: function get() {\n            return this._a._x;\n        }\n\n        /**\n         * Get the circle center y coordinate. Shortcut for `this.a.y`.\n         *\n         * @return {number} Circle center y coordinate.\n         */\n\n    }, {\n        key: 'y',\n        get: function get() {\n            return this._a._y;\n        }\n\n        /**\n         * Get the circle radius.\n         *\n         * @return {number} Circle radius.\n         */\n\n    }, {\n        key: 'r',\n        get: function get() {\n            return this._r;\n        }\n\n        /**\n         * Get the diameter. This is a shortcut for `this.r * 2`.\n         *\n         * @return {number} The circle diameter.\n         */\n\n    }, {\n        key: 'd',\n        get: function get() {\n            return this._r * 2;\n        }\n    }]);\n\n    return Circle;\n}();\n\nexports.default = Circle;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvQ2lyY2xlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL0NpcmNsZS5qcz81NTZlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX1BvaW50ID0gcmVxdWlyZSgnLi9Qb2ludCcpO1xuXG52YXIgX1BvaW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1BvaW50KTtcblxudmFyIF9SZWN0YW5nbGUgPSByZXF1aXJlKCcuL1JlY3RhbmdsZScpO1xuXG52YXIgX1JlY3RhbmdsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9SZWN0YW5nbGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIEltbXV0YWJsZSBjaXJjbGUgY2xhc3MuXG4gKi9cblxudmFyIENpcmNsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgY2lyY2xlIHVzaW5nIGNlbnRlciBwb2ludCBgQWAgYW5kIHJhZGl1cyBgcmAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBhIENlbnRlciBwb2ludCBgQWAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIHJhZGl1cyBgcmAuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIENpcmNsZShhLCByKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDaXJjbGUpO1xuXG4gICAgICAgIHRoaXMuX2EgPSBhO1xuICAgICAgICB0aGlzLl9yID0gcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNpcmNsZSBjZW50ZXIgcG9pbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtQb2ludH0gQ2VudGVyIHBvaW50LlxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoQ2lyY2xlLCBbe1xuICAgICAgICBrZXk6ICd0b1JlY3RhbmdsZScsXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydCB0aGlzIGNpcmNsZSB0byBhIHJlY3RhbmdsZSB0aGF0IGNvbnRhaW5zIHRoaXMgY2lyY2xlIGV4YWN0bHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1JlY3RhbmdsZX0gQ29udmVydGVkIHJlY3RhbmdsZS5cbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b1JlY3RhbmdsZSgpIHtcbiAgICAgICAgICAgIHZhciBhID0gbmV3IF9Qb2ludDIuZGVmYXVsdCh0aGlzLl9hLl94IC0gdGhpcy5yYWRpdXMsIHRoaXMuX2EuX3kgLSB0aGlzLnJhZGl1cyk7XG4gICAgICAgICAgICB2YXIgYiA9IG5ldyBfUG9pbnQyLmRlZmF1bHQodGhpcy5fYS5feCArIHRoaXMucmFkaXVzLCB0aGlzLl9hLl95ICsgdGhpcy5yYWRpdXMpO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IF9SZWN0YW5nbGUyLmRlZmF1bHQoYSwgYik7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydCB0aGlzIGNpcmNsZSBpbnRvIGFuIG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gKHgsIHksIHIpLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9PYmplY3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9PYmplY3QoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IHRoaXMuX2EuX3gsXG4gICAgICAgICAgICAgICAgeTogdGhpcy5fYS5feSxcbiAgICAgICAgICAgICAgICByOiB0aGlzLl9yXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnQgdGhpcyBjaXJjbGUgaW50byBhbiBhcnJheS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IHJlcHJlc2VudGF0aW9uICh4LCB5LCByKS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvQXJyYXknLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy5fYS5feCwgdGhpcy5fYS5feSwgdGhpcy5fcl07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydCB0aGlzIGNpcmNsZSBpbnRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbiAoeCwgeSwgcikuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiAnKCcgKyB0aGlzLl9hLl94ICsgJywgJyArIHRoaXMuX2EuX3kgKyAnLCAnICsgdGhpcy5fciArICcpJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBzaGFsbG93IGNvcHkgb2YgdGhpcyBpbnN0YW5jZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7Q2lyY2xlfSBDbG9uZWQgaW5zdGFuY2UuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjbG9uZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2lyY2xlKHRoaXMuX2EsIHRoaXMuX3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybiB0cnVlIGlmIHRoaXMgY2lyY2xlIGlzIGVxdWFsIHRvIGFub3RoZXIgY2lyY2xlLiBUd28gY2lyY2xlcyBhcmVcbiAgICAgICAgICogZXF1YWwgaWYgYW5kIG9ubHkgaWYgdGhlIGNlbnRlciBwb2ludCBhbmQgcmFkaXVzIGFyZSBlcXVhbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHRoYXQgT3RoZXIgaW5zdGFuY2UgdG8gY29tcGFyZSB0by5cbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBib3RoIGNpcmNsZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdlcXVhbHMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZXF1YWxzKHRoYXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgPT09IHRoYXQuY29uc3RydWN0b3IubmFtZSAmJiB0aGlzLl9hLmVxdWFscyh0aGF0Ll9hKSAmJiB0aGlzLl9yID09PSB0aGF0Ll9yO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSBjaXJjbGUgaXMgZGVmaW5lZCwgZmluaXRlIGFuZCB2YWxpZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgY2lyY2xlIGlzIGZ1bGx5IGRlZmluZWQsIGZpbml0ZSBhbmQgdmFsaWQuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdpc1ZhbGlkJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzVmFsaWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYS5pc1ZhbGlkKCkgJiYgdHlwZW9mIHRoaXMuX3IgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHRoaXMuX3IpICYmIHRoaXMuX3IgPj0gMDtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYScsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2E7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjaXJjbGUgY2VudGVyIHggY29vcmRpbmF0ZS4gU2hvcnRjdXQgZm9yIGB0aGlzLmEueGAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn0gQ2lyY2xlIGNlbnRlciB4IGNvb3JkaW5hdGUuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd4JyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYS5feDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGNpcmNsZSBjZW50ZXIgeSBjb29yZGluYXRlLiBTaG9ydGN1dCBmb3IgYHRoaXMuYS55YC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfSBDaXJjbGUgY2VudGVyIHkgY29vcmRpbmF0ZS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3knLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hLl95O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY2lyY2xlIHJhZGl1cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfSBDaXJjbGUgcmFkaXVzLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncicsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3I7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBkaWFtZXRlci4gVGhpcyBpcyBhIHNob3J0Y3V0IGZvciBgdGhpcy5yICogMmAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGNpcmNsZSBkaWFtZXRlci5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2QnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yICogMjtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBDaXJjbGU7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IENpcmNsZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL0NpcmNsZS5qc1xuICoqIG1vZHVsZSBpZCA9IC4vc3JjL0NpcmNsZS5qc1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },

/***/ "./src/Point.js":
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Vector = __webpack_require__(\"./src/Vector.js\");\n\nvar _Vector2 = _interopRequireDefault(_Vector);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Immutable point class.\n *\n * A point is an absolute place in space, at a given x and y coordinate.\n *\n * The difference between a Point and a vector is explained in this source:\n * http://math.stackexchange.com/a/645827\n */\n\nvar Point = function () {\n    /**\n     * Construct a new point, using a x and y coordinate.\n     *\n     * An point is immutable. All subsequent operations will return a new point\n     * instance.\n     *\n     * @param {number} x The x coordinate.\n     * @param {number} y The y coordinate.\n     * @return {void}\n     */\n\n    function Point(x, y) {\n        _classCallCheck(this, Point);\n\n        this._x = x;\n        this._y = y;\n    }\n\n    /**\n     * Create a new point from an array. The first index is considered the x\n     * coordinate, the second index is considered the y coordinate.\n     *\n     * @param {Array} array Input array with at least two values.\n     * @return {Point} Resulting point.\n     */\n\n\n    _createClass(Point, [{\n        key: 'add',\n\n\n        /**\n         * Add a vector to a point.\n         *\n         * Note that addition of two points is undefined.\n         *\n         * @param {Vector} vector Vector to add to this point.\n         * @return {Point} Point with the vector added to it.\n         */\n        value: function add(vector) {\n            if (vector instanceof Point) {\n                throw new Error('Addition of two points is undefined.');\n            }\n\n            return new Point(this._x + vector._x, this._y + vector._y);\n        }\n\n        /**\n         * Subtract a Point or a Vector.\n         *\n         * @param {Point|Vector} that Point or vector to subtract.\n         * @return {Point} If `that` is a Vector, it will return the new point.\n         * @return {Vector} If `that` is a Point, it will return the displacement.\n         */\n\n    }, {\n        key: 'subtract',\n        value: function subtract(that) {\n            if (that instanceof Point) {\n                return this.toVector().subtract(that);\n            }\n\n            return new Point(this._x - that._x, this._y - that._y);\n        }\n\n        /**\n         * Invert the x and y coordinate, relative to (0, 0).\n         *\n         * @return {Point} Inverted point.\n         */\n\n    }, {\n        key: 'invert',\n        value: function invert() {\n            return new Point(-this._x, -this._y);\n        }\n\n        /**\n         * @return {Point}\n         */\n\n    }, {\n        key: 'multiply',\n        value: function multiply(scalar) {\n            return new Point(this._x * scalar, this._y * scalar);\n        }\n\n        /**\n         * @return {Point}\n         */\n\n    }, {\n        key: 'multiplyXY',\n        value: function multiplyXY(scalarX, scalarY) {\n            return new Point(this._x * scalarX, this._y * scalarY);\n        }\n\n        /**\n         * @return {Point}\n         */\n\n    }, {\n        key: 'divide',\n        value: function divide(scalar) {\n            return new Point(this._x / scalar, this._y / scalar);\n        }\n\n        /**\n         * @return {Point}\n         */\n\n    }, {\n        key: 'divideXY',\n        value: function divideXY(scalarX, scalarY) {\n            return new Point(this._x / scalarX, this._y / scalarY);\n        }\n\n        /**\n         * @return {Point}\n         */\n\n    }, {\n        key: 'mix',\n        value: function mix(that) {\n            var amount = arguments.length <= 1 || arguments[1] === undefined ? 0.5 : arguments[1];\n\n            return this.multiply(1 - amount).add(that.multiply(amount));\n        }\n\n        /**\n         * @return {Point}\n         */\n\n    }, {\n        key: 'perpendicular',\n        value: function perpendicular() {\n            return new Point(-this._y, this._x);\n        }\n\n        /**\n         * @return {Point}\n         */\n\n    }, {\n        key: 'snap',\n        value: function snap(to) {\n            var round = function round(val) {\n                return Math.round(val / to) * to;\n            };\n\n            return new Point(round(this._x), round(this._y));\n        }\n\n        /**\n         * @return {number}\n         */\n\n    }, {\n        key: 'dot',\n        value: function dot(that) {\n            return this._x * that._x + this._y * that._y;\n        }\n\n        /**\n         * @return {number}\n         */\n\n    }, {\n        key: 'angle',\n        value: function angle() {\n            return Math.atan2(this._y, this._x);\n        }\n\n        /**\n         * @return {number}\n         */\n\n    }, {\n        key: 'angleDeg',\n        value: function angleDeg() {\n            return Math.atan2(this._y, this._x) * 180 / Math.PI;\n        }\n\n        /**\n         * @return {number}\n         */\n\n    }, {\n        key: 'slope',\n        value: function slope() {\n            return this._y / this._x;\n        }\n\n        /**\n         * Calculate the squared distance between two points.\n         *\n         * If the exact distance doesn't matter, this method is slightly faster\n         * than `this.distance`.\n         *\n         * @param {Point} point The other point.\n         * @return {number} The distance between both points.\n         */\n\n    }, {\n        key: 'distanceSq',\n        value: function distanceSq(point) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (!(point instanceof Point)) {\n                    throw new Error('Must be a point.');\n                }\n            }\n\n            var dX = this._x - point._x;\n            var dY = this._y - point._y;\n\n            return dX * dX + dY * dY;\n        }\n\n        /**\n         * Calculate the distance between two points.\n         *\n         * @param {Point} point The other point.\n         * @return {number} The distance between both points.\n         */\n\n    }, {\n        key: 'distance',\n        value: function distance(point) {\n            return Math.sqrt(this.distanceSq(point));\n        }\n\n        /**\n         * Convert point into a vector.\n         *\n         * Note: this is an utility method. A proper conversion does not exist.\n         *\n         * @return {Vector} The point converted as vector.\n         */\n\n    }, {\n        key: 'toVector',\n        value: function toVector() {\n            return new _Vector2.default(this._x, this._y);\n        }\n\n        /**\n         * Convert this point into an array.\n         *\n         * @return {Array} Array representation (x, y).\n         */\n\n    }, {\n        key: 'toArray',\n        value: function toArray() {\n            return [this._x, this._y];\n        }\n\n        /**\n         * Convert this point into an object.\n         *\n         * @return {object} Object representation (x, y).\n         */\n\n    }, {\n        key: 'toObject',\n        value: function toObject() {\n            return { x: this._x, y: this._y };\n        }\n\n        /**\n         * Convert this point into a string representation.\n         *\n         * @return {string} String representation (x, y).\n         */\n\n    }, {\n        key: 'toString',\n        value: function toString() {\n            return '(' + this._x + ', ' + this._y + ')';\n        }\n\n        /**\n         * Convert this point into a string representation, using a fixed number of\n         * digits for displaying.\n         *\n         * @param {number} digits Number of digits to use for representation.\n         * @return {string} String representation (x, y).\n         */\n\n    }, {\n        key: 'toFixed',\n        value: function toFixed(digits) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (typeof digits !== 'number') {\n                    throw new Error('Number of digits must be a number.');\n                }\n            }\n\n            return '(' + this._x.toFixed(digits) + ', ' + this._y.toFixed(digits) + ')';\n        }\n\n        /**\n         * Create a shallow copy of this instance.\n         *\n         * @return {Point} Cloned instance.\n         */\n\n    }, {\n        key: 'clone',\n        value: function clone() {\n            return new Point(this._x, this._y);\n        }\n\n        /**\n         * Return true if this point is equal to another point. Two points are\n         * equal when both x and y coordinates are equal.\n         *\n         * @param {object} that Other instance to compare to.\n         * @return {boolean} True if both points are equal, false otherwise.\n         */\n\n    }, {\n        key: 'equals',\n        value: function equals(that) {\n            return this.constructor.name === that.constructor.name && this._x === that._x && this._y === that._y;\n        }\n\n        /**\n         * Return true if the point is defined and finite.\n         *\n         * @return {Boolean} True if point is fully defined and valid.\n         */\n\n    }, {\n        key: 'isValid',\n        value: function isValid() {\n            return typeof this._x === 'number' && isFinite(this._x) && typeof this._y === 'number' && isFinite(this._y);\n        }\n    }, {\n        key: 'x',\n\n\n        /**\n         * Get the x coordinate.\n         *\n         * @return {number} The x coordinate.\n         */\n        get: function get() {\n            return this._x;\n        }\n\n        /**\n         * Get the y coordinate.\n         *\n         * @return {number} The y coordinate.\n         */\n\n    }, {\n        key: 'y',\n        get: function get() {\n            return this._y;\n        }\n    }], [{\n        key: 'fromArray',\n        value: function fromArray(array) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (!Array.isArray(array) || array.length < 2) {\n                    throw new Error('Expected an array with at least two values.');\n                }\n            }\n\n            return new Point(array[0], array[1]);\n        }\n\n        /**\n         * Create a new point from an object. The object should have an x and y\n         * property.\n         *\n         * @param {object} object Input object with x and y property.\n         * @return {Point} Resulting point.\n         */\n\n    }, {\n        key: 'fromObject',\n        value: function fromObject(object) {\n            if (process.env.NODE_ENV !== 'production') {\n                if ((typeof object === 'undefined' ? 'undefined' : _typeof(object)) !== 'object') {\n                    throw new Error('Expected an object.');\n                }\n            }\n\n            return new Point(object.x, object.y);\n        }\n    }]);\n\n    return Point;\n}();\n\nexports.default = Point;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(\"./node_modules/process/browser.js\")))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvUG9pbnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvUG9pbnQuanM/Mzc2MSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfVmVjdG9yID0gcmVxdWlyZSgnLi9WZWN0b3InKTtcblxudmFyIF9WZWN0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVmVjdG9yKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBJbW11dGFibGUgcG9pbnQgY2xhc3MuXG4gKlxuICogQSBwb2ludCBpcyBhbiBhYnNvbHV0ZSBwbGFjZSBpbiBzcGFjZSwgYXQgYSBnaXZlbiB4IGFuZCB5IGNvb3JkaW5hdGUuXG4gKlxuICogVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBhIFBvaW50IGFuZCBhIHZlY3RvciBpcyBleHBsYWluZWQgaW4gdGhpcyBzb3VyY2U6XG4gKiBodHRwOi8vbWF0aC5zdGFja2V4Y2hhbmdlLmNvbS9hLzY0NTgyN1xuICovXG5cbnZhciBQb2ludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgcG9pbnQsIHVzaW5nIGEgeCBhbmQgeSBjb29yZGluYXRlLlxuICAgICAqXG4gICAgICogQW4gcG9pbnQgaXMgaW1tdXRhYmxlLiBBbGwgc3Vic2VxdWVudCBvcGVyYXRpb25zIHdpbGwgcmV0dXJuIGEgbmV3IHBvaW50XG4gICAgICogaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCBUaGUgeCBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IFRoZSB5IGNvb3JkaW5hdGUuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFBvaW50KHgsIHkpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBvaW50KTtcblxuICAgICAgICB0aGlzLl94ID0geDtcbiAgICAgICAgdGhpcy5feSA9IHk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHBvaW50IGZyb20gYW4gYXJyYXkuIFRoZSBmaXJzdCBpbmRleCBpcyBjb25zaWRlcmVkIHRoZSB4XG4gICAgICogY29vcmRpbmF0ZSwgdGhlIHNlY29uZCBpbmRleCBpcyBjb25zaWRlcmVkIHRoZSB5IGNvb3JkaW5hdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBJbnB1dCBhcnJheSB3aXRoIGF0IGxlYXN0IHR3byB2YWx1ZXMuXG4gICAgICogQHJldHVybiB7UG9pbnR9IFJlc3VsdGluZyBwb2ludC5cbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKFBvaW50LCBbe1xuICAgICAgICBrZXk6ICdhZGQnLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBhIHZlY3RvciB0byBhIHBvaW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlIHRoYXQgYWRkaXRpb24gb2YgdHdvIHBvaW50cyBpcyB1bmRlZmluZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yfSB2ZWN0b3IgVmVjdG9yIHRvIGFkZCB0byB0aGlzIHBvaW50LlxuICAgICAgICAgKiBAcmV0dXJuIHtQb2ludH0gUG9pbnQgd2l0aCB0aGUgdmVjdG9yIGFkZGVkIHRvIGl0LlxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZCh2ZWN0b3IpIHtcbiAgICAgICAgICAgIGlmICh2ZWN0b3IgaW5zdGFuY2VvZiBQb2ludCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQWRkaXRpb24gb2YgdHdvIHBvaW50cyBpcyB1bmRlZmluZWQuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy5feCArIHZlY3Rvci5feCwgdGhpcy5feSArIHZlY3Rvci5feSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU3VidHJhY3QgYSBQb2ludCBvciBhIFZlY3Rvci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtQb2ludHxWZWN0b3J9IHRoYXQgUG9pbnQgb3IgdmVjdG9yIHRvIHN1YnRyYWN0LlxuICAgICAgICAgKiBAcmV0dXJuIHtQb2ludH0gSWYgYHRoYXRgIGlzIGEgVmVjdG9yLCBpdCB3aWxsIHJldHVybiB0aGUgbmV3IHBvaW50LlxuICAgICAgICAgKiBAcmV0dXJuIHtWZWN0b3J9IElmIGB0aGF0YCBpcyBhIFBvaW50LCBpdCB3aWxsIHJldHVybiB0aGUgZGlzcGxhY2VtZW50LlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc3VidHJhY3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc3VidHJhY3QodGhhdCkge1xuICAgICAgICAgICAgaWYgKHRoYXQgaW5zdGFuY2VvZiBQb2ludCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvVmVjdG9yKCkuc3VidHJhY3QodGhhdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy5feCAtIHRoYXQuX3gsIHRoaXMuX3kgLSB0aGF0Ll95KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnZlcnQgdGhlIHggYW5kIHkgY29vcmRpbmF0ZSwgcmVsYXRpdmUgdG8gKDAsIDApLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtQb2ludH0gSW52ZXJ0ZWQgcG9pbnQuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdpbnZlcnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaW52ZXJ0KCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCgtdGhpcy5feCwgLXRoaXMuX3kpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge1BvaW50fVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbXVsdGlwbHknLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbXVsdGlwbHkoc2NhbGFyKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMuX3ggKiBzY2FsYXIsIHRoaXMuX3kgKiBzY2FsYXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge1BvaW50fVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbXVsdGlwbHlYWScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtdWx0aXBseVhZKHNjYWxhclgsIHNjYWxhclkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy5feCAqIHNjYWxhclgsIHRoaXMuX3kgKiBzY2FsYXJZKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtQb2ludH1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2RpdmlkZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXZpZGUoc2NhbGFyKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMuX3ggLyBzY2FsYXIsIHRoaXMuX3kgLyBzY2FsYXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge1BvaW50fVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZGl2aWRlWFknLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGl2aWRlWFkoc2NhbGFyWCwgc2NhbGFyWSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLl94IC8gc2NhbGFyWCwgdGhpcy5feSAvIHNjYWxhclkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge1BvaW50fVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbWl4JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1peCh0aGF0KSB7XG4gICAgICAgICAgICB2YXIgYW1vdW50ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gMC41IDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseSgxIC0gYW1vdW50KS5hZGQodGhhdC5tdWx0aXBseShhbW91bnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtQb2ludH1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3BlcnBlbmRpY3VsYXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcGVycGVuZGljdWxhcigpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoLXRoaXMuX3ksIHRoaXMuX3gpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge1BvaW50fVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc25hcCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzbmFwKHRvKSB7XG4gICAgICAgICAgICB2YXIgcm91bmQgPSBmdW5jdGlvbiByb3VuZCh2YWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWwgLyB0bykgKiB0bztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQocm91bmQodGhpcy5feCksIHJvdW5kKHRoaXMuX3kpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdkb3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZG90KHRoYXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl94ICogdGhhdC5feCArIHRoaXMuX3kgKiB0aGF0Ll95O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2FuZ2xlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFuZ2xlKCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIodGhpcy5feSwgdGhpcy5feCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYW5nbGVEZWcnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYW5nbGVEZWcoKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hdGFuMih0aGlzLl95LCB0aGlzLl94KSAqIDE4MCAvIE1hdGguUEk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2xvcGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2xvcGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5feSAvIHRoaXMuX3g7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsY3VsYXRlIHRoZSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgdGhlIGV4YWN0IGRpc3RhbmNlIGRvZXNuJ3QgbWF0dGVyLCB0aGlzIG1ldGhvZCBpcyBzbGlnaHRseSBmYXN0ZXJcbiAgICAgICAgICogdGhhbiBgdGhpcy5kaXN0YW5jZWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IFRoZSBvdGhlciBwb2ludC5cbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgZGlzdGFuY2UgYmV0d2VlbiBib3RoIHBvaW50cy5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Rpc3RhbmNlU3EnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VTcShwb2ludCkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShwb2ludCBpbnN0YW5jZW9mIFBvaW50KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgYmUgYSBwb2ludC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkWCA9IHRoaXMuX3ggLSBwb2ludC5feDtcbiAgICAgICAgICAgIHZhciBkWSA9IHRoaXMuX3kgLSBwb2ludC5feTtcblxuICAgICAgICAgICAgcmV0dXJuIGRYICogZFggKyBkWSAqIGRZO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludCBUaGUgb3RoZXIgcG9pbnQuXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGRpc3RhbmNlIGJldHdlZW4gYm90aCBwb2ludHMuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdkaXN0YW5jZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZShwb2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmRpc3RhbmNlU3EocG9pbnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0IHBvaW50IGludG8gYSB2ZWN0b3IuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGU6IHRoaXMgaXMgYW4gdXRpbGl0eSBtZXRob2QuIEEgcHJvcGVyIGNvbnZlcnNpb24gZG9lcyBub3QgZXhpc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1ZlY3Rvcn0gVGhlIHBvaW50IGNvbnZlcnRlZCBhcyB2ZWN0b3IuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b1ZlY3RvcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b1ZlY3RvcigpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgX1ZlY3RvcjIuZGVmYXVsdCh0aGlzLl94LCB0aGlzLl95KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0IHRoaXMgcG9pbnQgaW50byBhbiBhcnJheS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IHJlcHJlc2VudGF0aW9uICh4LCB5KS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvQXJyYXknLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy5feCwgdGhpcy5feV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydCB0aGlzIHBvaW50IGludG8gYW4gb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiAoeCwgeSkuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b09iamVjdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b09iamVjdCgpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IHRoaXMuX3gsIHk6IHRoaXMuX3kgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0IHRoaXMgcG9pbnQgaW50byBhIHN0cmluZyByZXByZXNlbnRhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gKHgsIHkpLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9TdHJpbmcnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gJygnICsgdGhpcy5feCArICcsICcgKyB0aGlzLl95ICsgJyknO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnQgdGhpcyBwb2ludCBpbnRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uLCB1c2luZyBhIGZpeGVkIG51bWJlciBvZlxuICAgICAgICAgKiBkaWdpdHMgZm9yIGRpc3BsYXlpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaWdpdHMgTnVtYmVyIG9mIGRpZ2l0cyB0byB1c2UgZm9yIHJlcHJlc2VudGF0aW9uLlxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbiAoeCwgeSkuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b0ZpeGVkJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvRml4ZWQoZGlnaXRzKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGlnaXRzICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ051bWJlciBvZiBkaWdpdHMgbXVzdCBiZSBhIG51bWJlci4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAnKCcgKyB0aGlzLl94LnRvRml4ZWQoZGlnaXRzKSArICcsICcgKyB0aGlzLl95LnRvRml4ZWQoZGlnaXRzKSArICcpJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBzaGFsbG93IGNvcHkgb2YgdGhpcyBpbnN0YW5jZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7UG9pbnR9IENsb25lZCBpbnN0YW5jZS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Nsb25lJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLl94LCB0aGlzLl95KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGlzIHBvaW50IGlzIGVxdWFsIHRvIGFub3RoZXIgcG9pbnQuIFR3byBwb2ludHMgYXJlXG4gICAgICAgICAqIGVxdWFsIHdoZW4gYm90aCB4IGFuZCB5IGNvb3JkaW5hdGVzIGFyZSBlcXVhbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHRoYXQgT3RoZXIgaW5zdGFuY2UgdG8gY29tcGFyZSB0by5cbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBib3RoIHBvaW50cyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2VxdWFscycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBlcXVhbHModGhhdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZSA9PT0gdGhhdC5jb25zdHJ1Y3Rvci5uYW1lICYmIHRoaXMuX3ggPT09IHRoYXQuX3ggJiYgdGhpcy5feSA9PT0gdGhhdC5feTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgcG9pbnQgaXMgZGVmaW5lZCBhbmQgZmluaXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHBvaW50IGlzIGZ1bGx5IGRlZmluZWQgYW5kIHZhbGlkLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaXNWYWxpZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc1ZhbGlkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLl94ID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh0aGlzLl94KSAmJiB0eXBlb2YgdGhpcy5feSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodGhpcy5feSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3gnLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgeCBjb29yZGluYXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB4IGNvb3JkaW5hdGUuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl94O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgeSBjb29yZGluYXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB5IGNvb3JkaW5hdGUuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd5JyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5feTtcbiAgICAgICAgfVxuICAgIH1dLCBbe1xuICAgICAgICBrZXk6ICdmcm9tQXJyYXknLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUFycmF5KGFycmF5KSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheSkgfHwgYXJyYXkubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGFuIGFycmF5IHdpdGggYXQgbGVhc3QgdHdvIHZhbHVlcy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoYXJyYXlbMF0sIGFycmF5WzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgcG9pbnQgZnJvbSBhbiBvYmplY3QuIFRoZSBvYmplY3Qgc2hvdWxkIGhhdmUgYW4geCBhbmQgeVxuICAgICAgICAgKiBwcm9wZXJ0eS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9iamVjdCBJbnB1dCBvYmplY3Qgd2l0aCB4IGFuZCB5IHByb3BlcnR5LlxuICAgICAgICAgKiBAcmV0dXJuIHtQb2ludH0gUmVzdWx0aW5nIHBvaW50LlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZnJvbU9iamVjdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHR5cGVvZiBvYmplY3QgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9iamVjdCkpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGFuIG9iamVjdC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQob2JqZWN0LngsIG9iamVjdC55KTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBQb2ludDtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUG9pbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9Qb2ludC5qc1xuICoqIG1vZHVsZSBpZCA9IC4vc3JjL1BvaW50LmpzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },

/***/ "./node_modules/process/browser.js":
/***/ function(module, exports) {

	eval("// shim for using process in browser\n\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\n(function () {\n  try {\n    cachedSetTimeout = setTimeout;\n  } catch (e) {\n    cachedSetTimeout = function () {\n      throw new Error('setTimeout is not defined');\n    }\n  }\n  try {\n    cachedClearTimeout = clearTimeout;\n  } catch (e) {\n    cachedClearTimeout = function () {\n      throw new Error('clearTimeout is not defined');\n    }\n  }\n} ())\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = cachedSetTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    cachedClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        cachedSetTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9wcm9jZXNzL2Jyb3dzZXIuanM/ODJlNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICB9IGNhdGNoIChlKSB7XG4gICAgY2FjaGVkU2V0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBpcyBub3QgZGVmaW5lZCcpO1xuICAgIH1cbiAgfVxuICB0cnkge1xuICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGlzIG5vdCBkZWZpbmVkJyk7XG4gICAgfVxuICB9XG59ICgpKVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gY2FjaGVkU2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2FjaGVkQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuICoqIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },

/***/ "./src/Vector.js":
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Point = __webpack_require__(\"./src/Point.js\");\n\nvar _Point2 = _interopRequireDefault(_Point);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Immutable vector class.\n *\n * A vector represents a displacement, using a x an y component to represent\n * the length (magnitude) and direction.\n *\n * The difference between a Vector and a Point is explained in this source:\n * http://math.stackexchange.com/a/645827\n */\n\nvar Vector = function () {\n\n    /**\n     * Construct a new vector, using a x and y component to represent the\n     * length (magnitude) and direction relative to (0, 0).\n     *\n     * An vector is immutable. All subsequent operations will return a new\n     * vector instance.\n     *\n     * @param {number} x The x component.\n     * @param {number} y The y component.\n     * @return {void}\n     */\n\n    function Vector(x, y) {\n        _classCallCheck(this, Vector);\n\n        this._x = x;\n        this._y = y;\n    }\n\n    /**\n     * Create a new vector from an array. The first index is considered the x\n     * component, the second index is considered the y component.\n     *\n     * @param {Array} array Input array with at least two values.\n     * @return {Vector} Resulting vector.\n     */\n\n    /**\n     * Definition of the unit vector.\n     */\n\n\n    _createClass(Vector, [{\n        key: 'add',\n\n\n        /**\n         * Add another vector or point to this vector.\n         *\n         * If the input is a point, the result will be a point with this vector\n         * as offset.\n         *\n         * @param {Point|Vector} that Point or vector to add.\n         * @return {Point|Vector} New Vector if adding vector, point otherwise.\n         */\n        value: function add(that) {\n            if (that instanceof _Point2.default) {\n                return that.add(this);\n            }\n\n            return new Vector(this._x + that._x, this._y + that._y);\n        }\n\n        /**\n         * Subtract a given scalar from the `x` and `y` component of this vector.\n         *\n         * @param {number} that Scalar value to subtract.\n         * @return {Vector}\n         */\n\n    }, {\n        key: 'subtract',\n        value: function subtract(that) {\n            return new Vector(this._x - that._x, this._y - that._y);\n        }\n\n        /**\n         * Invert a vector, returning a copy with inverted magnitude and direction.\n         *\n         * @return {Vector}\n         */\n\n    }, {\n        key: 'invert',\n        value: function invert() {\n            return new Vector(-this._x, -this._y);\n        }\n\n        /**\n         * @return {Vector}\n         */\n\n    }, {\n        key: 'multiply',\n        value: function multiply(scalar) {\n            return new Vector(this._x * scalar, this._y * scalar);\n        }\n\n        /**\n         * @return {Vector}\n         */\n\n    }, {\n        key: 'multiplyXY',\n        value: function multiplyXY(scalarX, scalarY) {\n            return new Vector(this._x * scalarX, this._y * scalarY);\n        }\n\n        /**\n         * @return {Vector}\n         */\n\n    }, {\n        key: 'divide',\n        value: function divide(scalar) {\n            return new Vector(this._x / scalar, this._y / scalar);\n        }\n\n        /**\n         * @return {Vector}\n         */\n\n    }, {\n        key: 'divideXY',\n        value: function divideXY(scalarX, scalarY) {\n            return new Vector(this._x / scalarX, this._y / scalarY);\n        }\n\n        /**\n         * @return {Vector}\n         */\n\n    }, {\n        key: 'mix',\n        value: function mix(that) {\n            var amount = arguments.length <= 1 || arguments[1] === undefined ? 0.5 : arguments[1];\n\n            return this.multiply(1 - amount).add(that.multiply(amount));\n        }\n\n        /**\n         * @return {Vector}\n         */\n\n    }, {\n        key: 'perpendicular',\n        value: function perpendicular() {\n            return new Vector(-this._y, this._x);\n        }\n\n        /**\n         * @return {Vector}\n         */\n\n    }, {\n        key: 'snap',\n        value: function snap(to) {\n            var round = function round(val) {\n                return Math.round(val / to) * to;\n            };\n\n            return new Vector(round(this._x), round(this._y));\n        }\n\n        /**\n         * @return {number}\n         */\n\n    }, {\n        key: 'dot',\n        value: function dot(that) {\n            return this._x * that._x + this._y * that._y;\n        }\n\n        /**\n         * @return {number}\n         */\n\n    }, {\n        key: 'angle',\n        value: function angle() {\n            return Math.atan2(this._y, this._x);\n        }\n\n        /**\n         * @return {number}\n         */\n\n    }, {\n        key: 'angleDeg',\n        value: function angleDeg() {\n            return Math.atan2(this._y, this._x) * 180 / Math.PI;\n        }\n\n        /**\n         * @return {number}\n         */\n\n    }, {\n        key: 'slope',\n        value: function slope() {\n            return this._y / this._x;\n        }\n\n        /**\n         * Calculate the squared length of this vector.\n         *\n         * If the exact length doesn't matter, this method is slightly faster\n         * than `this.length`.\n         *\n         * @return {number} The squared length of this vector.\n         */\n\n    }, {\n        key: 'lengthSq',\n        value: function lengthSq() {\n            return this._x * this._x + this._y * this._y;\n        }\n\n        /**\n         * Calculate the length (magnitude) of the vector.\n         *\n         * @return {number} The length of the vector.\n         */\n\n    }, {\n        key: 'length',\n        value: function length() {\n            return Math.sqrt(this.lengthSq());\n        }\n\n        /**\n         * [minLength description]\n         * @param {[type]} length [description]\n         * @return {[type]}\n         */\n\n    }, {\n        key: 'minLength',\n        value: function minLength(length) {\n            return this.length() < length ? this.normalize(length) : this;\n        }\n    }, {\n        key: 'maxLength',\n        value: function maxLength(length) {\n            return this.length() > length ? this.normalize(length) : this;\n        }\n    }, {\n        key: 'normalize',\n        value: function normalize() {\n            var scalar = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];\n\n            return this.divide(this.length()).multiply(scalar);\n        }\n    }, {\n        key: 'projectOnto',\n        value: function projectOnto(that) {\n            return that.multiply(this.dot(that) / that.lengthSq());\n        }\n\n        /**\n         * Convert vector into a point.\n         *\n         * Note: this is an utility method. A proper conversion does not exist.\n         *\n         * @return {Point} The vector converted as point.\n         */\n\n    }, {\n        key: 'toPoint',\n        value: function toPoint() {\n            return new _Point2.default(this._x, this._y);\n        }\n\n        /**\n         * Convert this vector into an array.\n         *\n         * @return {Array} Array representation (x, y).\n         */\n\n    }, {\n        key: 'toArray',\n        value: function toArray() {\n            return [this._x, this._y];\n        }\n\n        /**\n         * Convert this vector into an object.\n         *\n         * @return {object} Object representation (x, y).\n         */\n\n    }, {\n        key: 'toObject',\n        value: function toObject() {\n            return { x: this._x, y: this._y };\n        }\n\n        /**\n         * Convert this vector into a string representation.\n         *\n         * @return {string} String representation (x, y).\n         */\n\n    }, {\n        key: 'toString',\n        value: function toString() {\n            return '(' + this._x + ', ' + this._y + ')';\n        }\n\n        /**\n         * Convert this vector into a string representation, using a fixed number\n         * of digits for displaying.\n         *\n         * @param {number} digits Number of digits to use for representation.\n         * @return {string} String representation (x, y).\n         */\n\n    }, {\n        key: 'toFixed',\n        value: function toFixed(digits) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (typeof digits !== 'number') {\n                    throw new Error('Number of digits must be a number.');\n                }\n            }\n\n            return '(' + this._x.toFixed(digits) + ', ' + this._y.toFixed(digits) + ')';\n        }\n\n        /**\n         * Create a shallow copy of this instance.\n         *\n         * @return {Vector} Cloned instance.\n         */\n\n    }, {\n        key: 'clone',\n        value: function clone() {\n            return new Vector(this._x, this._y);\n        }\n\n        /**\n         * Return true if this vector is equal to another vector. Two vectors are\n         * equal when both x and y components are equal.\n         *\n         * @param {object} that Other instance to compare to.\n         * @return {boolean} True if both points are equal, false otherwise.\n         */\n\n    }, {\n        key: 'equals',\n        value: function equals(that) {\n            return this.constructor.name === that.constructor.name && this._x === that._x && this._y === that._y;\n        }\n\n        /**\n         * Return true if the vector is defined and finite.\n         *\n         * @return {Boolean} True if vector is fully defined and valid.\n         */\n\n    }, {\n        key: 'isValid',\n        value: function isValid() {\n            return typeof this._x === 'number' && isFinite(this._x) && typeof this._y === 'number' && isFinite(this._y);\n        }\n    }, {\n        key: 'x',\n\n\n        /**\n         * Get the x component.\n         *\n         * @return {number} The x component.\n         */\n        get: function get() {\n            return this._x;\n        }\n\n        /**\n         * Get the y component.\n         *\n         * @return {number} The y component.\n         */\n\n    }, {\n        key: 'y',\n        get: function get() {\n            return this._y;\n        }\n    }], [{\n        key: 'fromArray',\n        value: function fromArray(array) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (!Array.isArray(array) || array.length < 2) {\n                    throw new Error('Expected an array with at least two values.');\n                }\n            }\n\n            return new Vector(array[0], array[1]);\n        }\n\n        /**\n         * Create a new vector from an object. The object should have an x and y\n         * property.\n         *\n         * @param {object} object Input object with x and y property.\n         * @return {Vector} Resulting vector.\n         */\n\n    }, {\n        key: 'fromObject',\n        value: function fromObject(object) {\n            if (process.env.NODE_ENV !== 'production') {\n                if ((typeof object === 'undefined' ? 'undefined' : _typeof(object)) !== 'object') {\n                    throw new Error('Expected an object.');\n                }\n            }\n\n            return new Vector(object.x, object.y);\n        }\n\n        /**\n         * Create a new vector form a single value. In that case, both the x and y\n         * property will have the same value.\n         *\n         * @param {number} number Input number for x and y property.\n         * @return {Vector} Resulting vector.\n         */\n\n    }, {\n        key: 'fromNumber',\n        value: function fromNumber(number) {\n            return new Vector(number, number);\n        }\n    }]);\n\n    return Vector;\n}();\n\nVector.Unit = new Vector(1, 1);\nexports.default = Vector;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(\"./node_modules/process/browser.js\")))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvVmVjdG9yLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL1ZlY3Rvci5qcz8wYjFlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9Qb2ludCA9IHJlcXVpcmUoJy4vUG9pbnQnKTtcblxudmFyIF9Qb2ludDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Qb2ludCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogSW1tdXRhYmxlIHZlY3RvciBjbGFzcy5cbiAqXG4gKiBBIHZlY3RvciByZXByZXNlbnRzIGEgZGlzcGxhY2VtZW50LCB1c2luZyBhIHggYW4geSBjb21wb25lbnQgdG8gcmVwcmVzZW50XG4gKiB0aGUgbGVuZ3RoIChtYWduaXR1ZGUpIGFuZCBkaXJlY3Rpb24uXG4gKlxuICogVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBhIFZlY3RvciBhbmQgYSBQb2ludCBpcyBleHBsYWluZWQgaW4gdGhpcyBzb3VyY2U6XG4gKiBodHRwOi8vbWF0aC5zdGFja2V4Y2hhbmdlLmNvbS9hLzY0NTgyN1xuICovXG5cbnZhciBWZWN0b3IgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgdmVjdG9yLCB1c2luZyBhIHggYW5kIHkgY29tcG9uZW50IHRvIHJlcHJlc2VudCB0aGVcbiAgICAgKiBsZW5ndGggKG1hZ25pdHVkZSkgYW5kIGRpcmVjdGlvbiByZWxhdGl2ZSB0byAoMCwgMCkuXG4gICAgICpcbiAgICAgKiBBbiB2ZWN0b3IgaXMgaW1tdXRhYmxlLiBBbGwgc3Vic2VxdWVudCBvcGVyYXRpb25zIHdpbGwgcmV0dXJuIGEgbmV3XG4gICAgICogdmVjdG9yIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIHggY29tcG9uZW50LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IFRoZSB5IGNvbXBvbmVudC5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gVmVjdG9yKHgsIHkpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFZlY3Rvcik7XG5cbiAgICAgICAgdGhpcy5feCA9IHg7XG4gICAgICAgIHRoaXMuX3kgPSB5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyB2ZWN0b3IgZnJvbSBhbiBhcnJheS4gVGhlIGZpcnN0IGluZGV4IGlzIGNvbnNpZGVyZWQgdGhlIHhcbiAgICAgKiBjb21wb25lbnQsIHRoZSBzZWNvbmQgaW5kZXggaXMgY29uc2lkZXJlZCB0aGUgeSBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBJbnB1dCBhcnJheSB3aXRoIGF0IGxlYXN0IHR3byB2YWx1ZXMuXG4gICAgICogQHJldHVybiB7VmVjdG9yfSBSZXN1bHRpbmcgdmVjdG9yLlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogRGVmaW5pdGlvbiBvZiB0aGUgdW5pdCB2ZWN0b3IuXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhWZWN0b3IsIFt7XG4gICAgICAgIGtleTogJ2FkZCcsXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGFub3RoZXIgdmVjdG9yIG9yIHBvaW50IHRvIHRoaXMgdmVjdG9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGUgaW5wdXQgaXMgYSBwb2ludCwgdGhlIHJlc3VsdCB3aWxsIGJlIGEgcG9pbnQgd2l0aCB0aGlzIHZlY3RvclxuICAgICAgICAgKiBhcyBvZmZzZXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7UG9pbnR8VmVjdG9yfSB0aGF0IFBvaW50IG9yIHZlY3RvciB0byBhZGQuXG4gICAgICAgICAqIEByZXR1cm4ge1BvaW50fFZlY3Rvcn0gTmV3IFZlY3RvciBpZiBhZGRpbmcgdmVjdG9yLCBwb2ludCBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKHRoYXQpIHtcbiAgICAgICAgICAgIGlmICh0aGF0IGluc3RhbmNlb2YgX1BvaW50Mi5kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuYWRkKHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLl94ICsgdGhhdC5feCwgdGhpcy5feSArIHRoYXQuX3kpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN1YnRyYWN0IGEgZ2l2ZW4gc2NhbGFyIGZyb20gdGhlIGB4YCBhbmQgYHlgIGNvbXBvbmVudCBvZiB0aGlzIHZlY3Rvci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHRoYXQgU2NhbGFyIHZhbHVlIHRvIHN1YnRyYWN0LlxuICAgICAgICAgKiBAcmV0dXJuIHtWZWN0b3J9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzdWJ0cmFjdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdWJ0cmFjdCh0aGF0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLl94IC0gdGhhdC5feCwgdGhpcy5feSAtIHRoYXQuX3kpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludmVydCBhIHZlY3RvciwgcmV0dXJuaW5nIGEgY29weSB3aXRoIGludmVydGVkIG1hZ25pdHVkZSBhbmQgZGlyZWN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtWZWN0b3J9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdpbnZlcnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaW52ZXJ0KCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoLXRoaXMuX3gsIC10aGlzLl95KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtWZWN0b3J9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdtdWx0aXBseScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtdWx0aXBseShzY2FsYXIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMuX3ggKiBzY2FsYXIsIHRoaXMuX3kgKiBzY2FsYXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge1ZlY3Rvcn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ211bHRpcGx5WFknLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbXVsdGlwbHlYWShzY2FsYXJYLCBzY2FsYXJZKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLl94ICogc2NhbGFyWCwgdGhpcy5feSAqIHNjYWxhclkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge1ZlY3Rvcn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2RpdmlkZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXZpZGUoc2NhbGFyKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLl94IC8gc2NhbGFyLCB0aGlzLl95IC8gc2NhbGFyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtWZWN0b3J9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdkaXZpZGVYWScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXZpZGVYWShzY2FsYXJYLCBzY2FsYXJZKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLl94IC8gc2NhbGFyWCwgdGhpcy5feSAvIHNjYWxhclkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge1ZlY3Rvcn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ21peCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtaXgodGhhdCkge1xuICAgICAgICAgICAgdmFyIGFtb3VudCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IDAuNSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHkoMSAtIGFtb3VudCkuYWRkKHRoYXQubXVsdGlwbHkoYW1vdW50KSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7VmVjdG9yfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncGVycGVuZGljdWxhcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwZXJwZW5kaWN1bGFyKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoLXRoaXMuX3ksIHRoaXMuX3gpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge1ZlY3Rvcn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NuYXAnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc25hcCh0bykge1xuICAgICAgICAgICAgdmFyIHJvdW5kID0gZnVuY3Rpb24gcm91bmQodmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQodmFsIC8gdG8pICogdG87XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcihyb3VuZCh0aGlzLl94KSwgcm91bmQodGhpcy5feSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2RvdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkb3QodGhhdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ggKiB0aGF0Ll94ICsgdGhpcy5feSAqIHRoYXQuX3k7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYW5nbGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYW5nbGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hdGFuMih0aGlzLl95LCB0aGlzLl94KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdhbmdsZURlZycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhbmdsZURlZygpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmF0YW4yKHRoaXMuX3ksIHRoaXMuX3gpICogMTgwIC8gTWF0aC5QSTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzbG9wZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzbG9wZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl95IC8gdGhpcy5feDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxjdWxhdGUgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIHRoaXMgdmVjdG9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGUgZXhhY3QgbGVuZ3RoIGRvZXNuJ3QgbWF0dGVyLCB0aGlzIG1ldGhvZCBpcyBzbGlnaHRseSBmYXN0ZXJcbiAgICAgICAgICogdGhhbiBgdGhpcy5sZW5ndGhgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzcXVhcmVkIGxlbmd0aCBvZiB0aGlzIHZlY3Rvci5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2xlbmd0aFNxJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxlbmd0aFNxKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ggKiB0aGlzLl94ICsgdGhpcy5feSAqIHRoaXMuX3k7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsY3VsYXRlIHRoZSBsZW5ndGggKG1hZ25pdHVkZSkgb2YgdGhlIHZlY3Rvci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbGVuZ3RoIG9mIHRoZSB2ZWN0b3IuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdsZW5ndGgnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbGVuZ3RoKCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmxlbmd0aFNxKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFttaW5MZW5ndGggZGVzY3JpcHRpb25dXG4gICAgICAgICAqIEBwYXJhbSB7W3R5cGVdfSBsZW5ndGggW2Rlc2NyaXB0aW9uXVxuICAgICAgICAgKiBAcmV0dXJuIHtbdHlwZV19XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdtaW5MZW5ndGgnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbWluTGVuZ3RoKGxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoKCkgPCBsZW5ndGggPyB0aGlzLm5vcm1hbGl6ZShsZW5ndGgpIDogdGhpcztcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbWF4TGVuZ3RoJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1heExlbmd0aChsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCgpID4gbGVuZ3RoID8gdGhpcy5ub3JtYWxpemUobGVuZ3RoKSA6IHRoaXM7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ25vcm1hbGl6ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBub3JtYWxpemUoKSB7XG4gICAgICAgICAgICB2YXIgc2NhbGFyID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gMSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGl2aWRlKHRoaXMubGVuZ3RoKCkpLm11bHRpcGx5KHNjYWxhcik7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3Byb2plY3RPbnRvJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByb2plY3RPbnRvKHRoYXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGF0Lm11bHRpcGx5KHRoaXMuZG90KHRoYXQpIC8gdGhhdC5sZW5ndGhTcSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0IHZlY3RvciBpbnRvIGEgcG9pbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGU6IHRoaXMgaXMgYW4gdXRpbGl0eSBtZXRob2QuIEEgcHJvcGVyIGNvbnZlcnNpb24gZG9lcyBub3QgZXhpc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1BvaW50fSBUaGUgdmVjdG9yIGNvbnZlcnRlZCBhcyBwb2ludC5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvUG9pbnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9Qb2ludCgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgX1BvaW50Mi5kZWZhdWx0KHRoaXMuX3gsIHRoaXMuX3kpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnQgdGhpcyB2ZWN0b3IgaW50byBhbiBhcnJheS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IHJlcHJlc2VudGF0aW9uICh4LCB5KS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvQXJyYXknLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy5feCwgdGhpcy5feV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydCB0aGlzIHZlY3RvciBpbnRvIGFuIG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gKHgsIHkpLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9PYmplY3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9PYmplY3QoKSB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiB0aGlzLl94LCB5OiB0aGlzLl95IH07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydCB0aGlzIHZlY3RvciBpbnRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbiAoeCwgeSkuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiAnKCcgKyB0aGlzLl94ICsgJywgJyArIHRoaXMuX3kgKyAnKSc7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydCB0aGlzIHZlY3RvciBpbnRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uLCB1c2luZyBhIGZpeGVkIG51bWJlclxuICAgICAgICAgKiBvZiBkaWdpdHMgZm9yIGRpc3BsYXlpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaWdpdHMgTnVtYmVyIG9mIGRpZ2l0cyB0byB1c2UgZm9yIHJlcHJlc2VudGF0aW9uLlxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbiAoeCwgeSkuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b0ZpeGVkJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvRml4ZWQoZGlnaXRzKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGlnaXRzICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ051bWJlciBvZiBkaWdpdHMgbXVzdCBiZSBhIG51bWJlci4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAnKCcgKyB0aGlzLl94LnRvRml4ZWQoZGlnaXRzKSArICcsICcgKyB0aGlzLl95LnRvRml4ZWQoZGlnaXRzKSArICcpJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBzaGFsbG93IGNvcHkgb2YgdGhpcyBpbnN0YW5jZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7VmVjdG9yfSBDbG9uZWQgaW5zdGFuY2UuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjbG9uZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMuX3gsIHRoaXMuX3kpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybiB0cnVlIGlmIHRoaXMgdmVjdG9yIGlzIGVxdWFsIHRvIGFub3RoZXIgdmVjdG9yLiBUd28gdmVjdG9ycyBhcmVcbiAgICAgICAgICogZXF1YWwgd2hlbiBib3RoIHggYW5kIHkgY29tcG9uZW50cyBhcmUgZXF1YWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGF0IE90aGVyIGluc3RhbmNlIHRvIGNvbXBhcmUgdG8uXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYm90aCBwb2ludHMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdlcXVhbHMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZXF1YWxzKHRoYXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgPT09IHRoYXQuY29uc3RydWN0b3IubmFtZSAmJiB0aGlzLl94ID09PSB0aGF0Ll94ICYmIHRoaXMuX3kgPT09IHRoYXQuX3k7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZlY3RvciBpcyBkZWZpbmVkIGFuZCBmaW5pdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdmVjdG9yIGlzIGZ1bGx5IGRlZmluZWQgYW5kIHZhbGlkLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaXNWYWxpZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc1ZhbGlkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLl94ID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh0aGlzLl94KSAmJiB0eXBlb2YgdGhpcy5feSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodGhpcy5feSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3gnLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgeCBjb21wb25lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHggY29tcG9uZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5feDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHkgY29tcG9uZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB5IGNvbXBvbmVudC5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3knLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl95O1xuICAgICAgICB9XG4gICAgfV0sIFt7XG4gICAgICAgIGtleTogJ2Zyb21BcnJheScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tQXJyYXkoYXJyYXkpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSB8fCBhcnJheS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYW4gYXJyYXkgd2l0aCBhdCBsZWFzdCB0d28gdmFsdWVzLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoYXJyYXlbMF0sIGFycmF5WzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgdmVjdG9yIGZyb20gYW4gb2JqZWN0LiBUaGUgb2JqZWN0IHNob3VsZCBoYXZlIGFuIHggYW5kIHlcbiAgICAgICAgICogcHJvcGVydHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3QgSW5wdXQgb2JqZWN0IHdpdGggeCBhbmQgeSBwcm9wZXJ0eS5cbiAgICAgICAgICogQHJldHVybiB7VmVjdG9yfSBSZXN1bHRpbmcgdmVjdG9yLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZnJvbU9iamVjdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHR5cGVvZiBvYmplY3QgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9iamVjdCkpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGFuIG9iamVjdC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKG9iamVjdC54LCBvYmplY3QueSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IHZlY3RvciBmb3JtIGEgc2luZ2xlIHZhbHVlLiBJbiB0aGF0IGNhc2UsIGJvdGggdGhlIHggYW5kIHlcbiAgICAgICAgICogcHJvcGVydHkgd2lsbCBoYXZlIHRoZSBzYW1lIHZhbHVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIElucHV0IG51bWJlciBmb3IgeCBhbmQgeSBwcm9wZXJ0eS5cbiAgICAgICAgICogQHJldHVybiB7VmVjdG9yfSBSZXN1bHRpbmcgdmVjdG9yLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZnJvbU51bWJlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tTnVtYmVyKG51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IobnVtYmVyLCBudW1iZXIpO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFZlY3Rvcjtcbn0oKTtcblxuVmVjdG9yLlVuaXQgPSBuZXcgVmVjdG9yKDEsIDEpO1xuZXhwb3J0cy5kZWZhdWx0ID0gVmVjdG9yO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvVmVjdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gLi9zcmMvVmVjdG9yLmpzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },

/***/ "./src/Rectangle.js":
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Point = __webpack_require__(\"./src/Point.js\");\n\nvar _Point2 = _interopRequireDefault(_Point);\n\nvar _LineSegment = __webpack_require__(\"./src/LineSegment.js\");\n\nvar _LineSegment2 = _interopRequireDefault(_LineSegment);\n\nvar _Vector = __webpack_require__(\"./src/Vector.js\");\n\nvar _Vector2 = _interopRequireDefault(_Vector);\n\nvar _Circle = __webpack_require__(\"./src/Circle.js\");\n\nvar _Circle2 = _interopRequireDefault(_Circle);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Immutable rectangle class.\n */\n\nvar Rectangle = function () {\n    /**\n     * Construct a new immutable rectangle of two points.\n     *\n     * @param {Point} a The `A` point..\n     * @param {Point} b The `B` point.\n     * @return {void}\n     */\n\n    function Rectangle(a, b) {\n        _classCallCheck(this, Rectangle);\n\n        this._a = a;\n        this._b = b;\n    }\n\n    /**\n     * Create a new rectangle from an array. The first index should be point\n     * `A` and the second index should be point `B`.\n     *\n     * @param {Array} array Input array with at least two values.\n     * @return {Rectangle} Resulting rectangle.\n     */\n\n\n    _createClass(Rectangle, [{\n        key: 'center',\n\n\n        /**\n         * Calculate the center point of this rectangle.\n         *\n         * @return {Point} Center of this rectangle.\n         */\n        value: function center() {\n            var x = (this._a._x + this._b._x) / 2;\n            var y = (this._a._y + this._b._y) / 2;\n\n            return new _Point2.default(x, y);\n        }\n\n        /**\n         * Calculate the center point offset.\n         *\n         * @return {Vector} Relative center point offset of this rectangle.\n         */\n\n    }, {\n        key: 'centerOffset',\n        value: function centerOffset() {\n            return this.center().subtract(this._a);\n        }\n\n        /**\n         * Merge two rectangles, taking the bouding box that contains both\n         * rectangles.\n         *\n         * @param {Rectangle} rectangle Other rectangle to merge with.\n         * @return {Rectangle} New rectangle containing both rectangles.\n         */\n\n    }, {\n        key: 'merge',\n        value: function merge(rectangle) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (!(rectangle instanceof Rectangle)) {\n                    throw new Error('Must merge with another rectangle.');\n                }\n            }\n\n            var a = new _Point2.default(Math.min(this._a._x, this._b._x, rectangle._a._x, rectangle._b._x), Math.min(this._a._y, this._b._y, rectangle._a._y, rectangle._b._y));\n            var b = new _Point2.default(Math.max(this._a._x, this._b._x, rectangle._a._x, rectangle._b._x), Math.max(this._a._y, this._b._y, rectangle._a._y, rectangle._b._y));\n\n            return new Rectangle(a, b);\n        }\n\n        /**\n         * Move the rectangle by applying an offset to the points `a` and `b`.\n         *\n         * @param {Vector} vector Offset vector.\n         * @return {Rectangle} Moved rectangle.\n         */\n\n    }, {\n        key: 'move',\n        value: function move(vector) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (!(vector instanceof _Vector2.default)) {\n                    throw new Error('Offset must be a vector.');\n                }\n            }\n\n            return new Rectangle(this._a.add(vector), this._b.add(vector));\n        }\n\n        /**\n         * Move the `a` point and `b` point of this rectangle individually.\n         *\n         * @param {Vector} vectorA Offset vector for `a` point.\n         * @param {Vector} vectorB Offset vector for `b` point.\n         * @return {Rectangle} Moved rectangle.\n         */\n\n    }, {\n        key: 'moveAB',\n        value: function moveAB(vectorA, vectorB) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (!(vectorA instanceof _Vector2.default) || !(vectorB instanceof _Vector2.default)) {\n                    throw new Error('Offset must be a vector.');\n                }\n            }\n\n            return new Rectangle(this._a.add(vectorA), this._b.add(vectorB));\n        }\n\n        /**\n         * Similar to move, but moves `a` and `b` in opposite directions by\n         * inverting the vector for `a`.\n         *\n         * This method may shrink the rectangle if the vector is negative, or if\n         * points `a` and `b` have been swapped. Normalize the\n         *\n         * @param {Vector} vector The offset vector to expand with.\n         * @return {Rectangle} Expanded rectangle.\n         */\n\n    }, {\n        key: 'expand',\n        value: function expand(vector) {\n            return this.moveAB(vector.invert(), vector);\n        }\n\n        /**\n         * Returns true if a given point is on this rectangle.\n         *\n         * @param {Point} point Point to test with.\n         * @return {boolean} True if point is within rectangle.\n         */\n\n    }, {\n        key: 'containsPoint',\n        value: function containsPoint(point) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (!(point instanceof _Point2.default)) {\n                    throw new Error('Must be a point.');\n                }\n            }\n\n            return (point._x >= this._a._x && point._x <= this._b._x || point._x >= this._b._x && point._x <= this._a._x) && (point._y >= this._a._y && point._y <= this._b._y || point._y >= this._b._y && point._y <= this._a._y);\n        }\n\n        /**\n         * Returns true if a given rectangle is within this rectangle. That is,\n         * both point `A` and `B` are within this rectangle.\n         *\n         * @param {Rectangle} rectangle The rectangle to check for.\n         * @return {booleam} True if the rectangle is within this rectangle.\n         */\n\n    }, {\n        key: 'containsRectangle',\n        value: function containsRectangle(rectangle) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (!(rectangle instanceof Rectangle)) {\n                    throw new Error('Must be a rectangle.');\n                }\n            }\n\n            return this.containsPoint(rectangle.a) && this.containsPoint(rectangle.b);\n        }\n\n        /**\n         * Returns true if a given rectangle collides with this rectangle.\n         *\n         * @param {Rectangle} rectangle Other rectangle to compare with.\n         * @return {boolean} True if the given rectangle collides with this one.\n         */\n\n    }, {\n        key: 'collidesRectangle',\n        value: function collidesRectangle(rectangle) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (!(rectangle instanceof Rectangle)) {\n                    throw new Error('Must be a rectangle.');\n                }\n            }\n\n            return this._a._x < rectangle._b._x && this._b._x > rectangle._a._x && this._a._y < rectangle._b._y && this._b._y > rectangle._a._y;\n        }\n\n        /**\n         * Returns true if a given circle collides with this rectangle.\n         *\n         * @param {Circle} circle Other circle to compare with.\n         * @return {boolean} True if the given circles collides with this one.\n         */\n\n    }, {\n        key: 'collidesCircle',\n        value: function collidesCircle(circle) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (!(circle instanceof _Circle2.default)) {\n                    throw new Error('Must be a circle.');\n                }\n            }\n\n            var clamp = function clamp(value, min, max) {\n                return Math.max(min, Math.min(max, value));\n            };\n\n            var closest = new _Point2.default(clamp(circle._a._x, this._a._x, this._b._x), clamp(circle._a._y, this._a._y, this._b._y));\n\n            return closest.distanceSq(circle._a) < circle._r * circle._r;\n        }\n\n        /**\n         * Calculate the area of the given rectangle.\n         *\n         * @return {number} The rectangle area.\n         */\n\n    }, {\n        key: 'area',\n        value: function area() {\n            return (this._b._x - this._a._x) * (this._b._y - this._a._y);\n        }\n\n        /**\n         * Return an array representation of this instance.\n         *\n         * @return {Array} Array representation [a, b].\n         */\n\n    }, {\n        key: 'toArray',\n        value: function toArray() {\n            return [this._a.toArray(), this._b.toArray()];\n        }\n\n        /**\n         * Return an object representation of this instance.\n         *\n         * @return {object} Object representation {a, b}.\n         */\n\n    }, {\n        key: 'toObject',\n        value: function toObject() {\n            return {\n                a: this._a.toObject(),\n                b: this._b.toObject()\n            };\n        }\n\n        /**\n         * Return an object representation of the bounding rectangle of this\n         * instance.\n         *\n         * @return {object} Object representation { left, top, width, height }.\n         */\n\n    }, {\n        key: 'toBoundingRect',\n        value: function toBoundingRect() {\n            return {\n                left: this.left,\n                top: this.top,\n                width: this.width,\n                height: this.height\n            };\n        }\n\n        /**\n         * Return a string representation of this rectangle.\n         *\n         * @return {string} String representation.\n         */\n\n    }, {\n        key: 'toString',\n        value: function toString() {\n            return '(' + this._a.toString() + ', ' + this._b.toString() + ')';\n        }\n\n        /**\n         * Return an array of line segments of the four edges of this rectangle.\n         *\n         * @return {Array<LineSegment>} Array of line segments.\n         */\n\n    }, {\n        key: 'toLineSegments',\n        value: function toLineSegments() {\n            var c = new _Point2.default(this._a._x, this._b._y);\n            var d = new _Point2.default(this._b._x, this._a._y);\n\n            return [new _LineSegment2.default(this._a, d), new _LineSegment2.default(d, this._b), new _LineSegment2.default(this._b, c), new _LineSegment2.default(c, this._a)];\n        }\n\n        /**\n         * Create a shallow copy of this instance.\n         *\n         * @return {Rectangle} Cloned instance.\n         */\n\n    }, {\n        key: 'clone',\n        value: function clone() {\n            return new Rectangle(this._a, this._b);\n        }\n\n        /**\n         * Return a normalize rectangle, with the `A` point in the top-left\n         * position and the `B` point in the bottom-right position.\n         *\n         * @return {Rectangle} The normalized rectangle.\n         */\n\n    }, {\n        key: 'normalize',\n        value: function normalize() {\n            return new Rectangle(new _Point2.default(this.left, this.top), new _Point2.default(this.right, this.bottom));\n        }\n\n        /**\n         * Return true if this rectangle is equal to another rectangle. Two\n         * rectangles are equal if and only if both points are equal. This means\n         * if two rectangles have the same left, right, top and bottom, they\n         * may not be equal, because they may have been defined from different\n         * points.\n         *\n         * @param {object} that Other instance to compare to.\n         * @return {boolean} True if both rectangles are equal, false otherwise.\n         */\n\n    }, {\n        key: 'equals',\n        value: function equals(that) {\n            return this.constructor.name === that.constructor.name && this._a.equals(that._b) && this._b.equals(that._b);\n        }\n\n        /**\n         * Return true if the rectangle is defined and finite.\n         *\n         * @return {Boolean} True if rectangle is valid.\n         */\n\n    }, {\n        key: 'isValid',\n        value: function isValid() {\n            return this._a.isValid() && this._b.isValid();\n        }\n    }, {\n        key: 'a',\n\n\n        /**\n         * Return point `A`.\n         *\n         * @return {Point} Point `A`.\n         */\n        get: function get() {\n            return this._a;\n        }\n\n        /**\n         * Return point `B`.\n         *\n         * @return {Point} Point `B`.\n         */\n\n    }, {\n        key: 'b',\n        get: function get() {\n            return this._b;\n        }\n\n        /**\n         * Return the left x coordinate.\n         *\n         * @return {number} Left x coordinate.\n         */\n\n    }, {\n        key: 'left',\n        get: function get() {\n            // return Math.min(this._a._x, this._b._x);\n            return this._a._x;\n        }\n\n        /**\n         * Return the right x coordinate.\n         *\n         * @return {number} Right x coordinate.\n         */\n\n    }, {\n        key: 'right',\n        get: function get() {\n            // return Math.max(this._a._x, this._b._x);\n            return this._b._x;\n        }\n\n        /**\n         * Return the top y coordinate.\n         *\n         * @return {number} Top y coordinate.\n         */\n\n    }, {\n        key: 'top',\n        get: function get() {\n            // return Math.min(this._a._y, this._b._y);\n            return this._a._y;\n        }\n\n        /**\n         * Return the bottom y coordinate.\n         *\n         * @return {number} Bottom y coordinate.\n         */\n\n    }, {\n        key: 'bottom',\n        get: function get() {\n            // return Math.max(this._a._y, this._b._y);\n            return this._b._y;\n        }\n\n        /**\n         * Return the width of this rectangle, which is the difference between\n         * `this.right` and `this.left`.\n         *\n         * @return {number} Width of the rectangle.\n         */\n\n    }, {\n        key: 'width',\n        get: function get() {\n            return this.right - this.left;\n        }\n\n        /**\n         * Return the height of this rectangle, which is the difference between\n         * `this.bottom` and `this.top`.\n         *\n         * @return {number} Height of the rectangle.\n         */\n\n    }, {\n        key: 'height',\n        get: function get() {\n            return this.bottom - this.top;\n        }\n    }], [{\n        key: 'fromArray',\n        value: function fromArray(array) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (!Array.isArray(array) || array.length < 2) {\n                    throw new Error('Expected an array with at least two values.');\n                }\n            }\n\n            return new Rectangle(_Point2.default.fromArray(array[0]), _Point2.default.fromArray(array[1]));\n        }\n\n        /**\n         * Create a new rectangle from an object. The object should have an `a` and\n         * `b` property.\n         *\n         * @param {object} object Input object with `a` and `b` property.\n         * @return {Rectangle} Resulting rectangle.\n         */\n\n    }, {\n        key: 'fromObject',\n        value: function fromObject(object) {\n            if (process.env.NODE_ENV !== 'production') {\n                if ((typeof object === 'undefined' ? 'undefined' : _typeof(object)) !== 'object') {\n                    throw new Error('Expected an object.');\n                }\n            }\n\n            return new Rectangle(_Point2.default.fromObject(object.a), _Point2.default.fromObject(object.b));\n        }\n\n        /**\n         * Create a new rectangle from a (client) bounding rect from an element.\n         * However, it accepts any object with a `left`, `top, `width` and `height`\n         * property.\n         *\n         * @param {object} boundingRect Input bounding rectangle.\n         * @return {Rectangle} Rectangle based on given bounding rectangle.\n         */\n\n    }, {\n        key: 'fromBoundingRect',\n        value: function fromBoundingRect(boundingRect) {\n            return new Rectangle(new _Point2.default(boundingRect.left, boundingRect.top), new _Point2.default(boundingRect.left + boundingRect.width, boundingRect.top + boundingRect.height));\n        }\n    }]);\n\n    return Rectangle;\n}();\n\nexports.default = Rectangle;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(\"./node_modules/process/browser.js\")))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvUmVjdGFuZ2xlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL1JlY3RhbmdsZS5qcz82YzM5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9Qb2ludCA9IHJlcXVpcmUoJy4vUG9pbnQnKTtcblxudmFyIF9Qb2ludDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Qb2ludCk7XG5cbnZhciBfTGluZVNlZ21lbnQgPSByZXF1aXJlKCcuL0xpbmVTZWdtZW50Jyk7XG5cbnZhciBfTGluZVNlZ21lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTGluZVNlZ21lbnQpO1xuXG52YXIgX1ZlY3RvciA9IHJlcXVpcmUoJy4vVmVjdG9yJyk7XG5cbnZhciBfVmVjdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1ZlY3Rvcik7XG5cbnZhciBfQ2lyY2xlID0gcmVxdWlyZSgnLi9DaXJjbGUnKTtcblxudmFyIF9DaXJjbGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2lyY2xlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBJbW11dGFibGUgcmVjdGFuZ2xlIGNsYXNzLlxuICovXG5cbnZhciBSZWN0YW5nbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IGltbXV0YWJsZSByZWN0YW5nbGUgb2YgdHdvIHBvaW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IGEgVGhlIGBBYCBwb2ludC4uXG4gICAgICogQHBhcmFtIHtQb2ludH0gYiBUaGUgYEJgIHBvaW50LlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBSZWN0YW5nbGUoYSwgYikge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVjdGFuZ2xlKTtcblxuICAgICAgICB0aGlzLl9hID0gYTtcbiAgICAgICAgdGhpcy5fYiA9IGI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHJlY3RhbmdsZSBmcm9tIGFuIGFycmF5LiBUaGUgZmlyc3QgaW5kZXggc2hvdWxkIGJlIHBvaW50XG4gICAgICogYEFgIGFuZCB0aGUgc2Vjb25kIGluZGV4IHNob3VsZCBiZSBwb2ludCBgQmAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBJbnB1dCBhcnJheSB3aXRoIGF0IGxlYXN0IHR3byB2YWx1ZXMuXG4gICAgICogQHJldHVybiB7UmVjdGFuZ2xlfSBSZXN1bHRpbmcgcmVjdGFuZ2xlLlxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoUmVjdGFuZ2xlLCBbe1xuICAgICAgICBrZXk6ICdjZW50ZXInLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGN1bGF0ZSB0aGUgY2VudGVyIHBvaW50IG9mIHRoaXMgcmVjdGFuZ2xlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtQb2ludH0gQ2VudGVyIG9mIHRoaXMgcmVjdGFuZ2xlLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNlbnRlcigpIHtcbiAgICAgICAgICAgIHZhciB4ID0gKHRoaXMuX2EuX3ggKyB0aGlzLl9iLl94KSAvIDI7XG4gICAgICAgICAgICB2YXIgeSA9ICh0aGlzLl9hLl95ICsgdGhpcy5fYi5feSkgLyAyO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IF9Qb2ludDIuZGVmYXVsdCh4LCB5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxjdWxhdGUgdGhlIGNlbnRlciBwb2ludCBvZmZzZXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1ZlY3Rvcn0gUmVsYXRpdmUgY2VudGVyIHBvaW50IG9mZnNldCBvZiB0aGlzIHJlY3RhbmdsZS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NlbnRlck9mZnNldCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjZW50ZXJPZmZzZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jZW50ZXIoKS5zdWJ0cmFjdCh0aGlzLl9hKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXJnZSB0d28gcmVjdGFuZ2xlcywgdGFraW5nIHRoZSBib3VkaW5nIGJveCB0aGF0IGNvbnRhaW5zIGJvdGhcbiAgICAgICAgICogcmVjdGFuZ2xlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtSZWN0YW5nbGV9IHJlY3RhbmdsZSBPdGhlciByZWN0YW5nbGUgdG8gbWVyZ2Ugd2l0aC5cbiAgICAgICAgICogQHJldHVybiB7UmVjdGFuZ2xlfSBOZXcgcmVjdGFuZ2xlIGNvbnRhaW5pbmcgYm90aCByZWN0YW5nbGVzLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbWVyZ2UnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbWVyZ2UocmVjdGFuZ2xlKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGlmICghKHJlY3RhbmdsZSBpbnN0YW5jZW9mIFJlY3RhbmdsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IG1lcmdlIHdpdGggYW5vdGhlciByZWN0YW5nbGUuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYSA9IG5ldyBfUG9pbnQyLmRlZmF1bHQoTWF0aC5taW4odGhpcy5fYS5feCwgdGhpcy5fYi5feCwgcmVjdGFuZ2xlLl9hLl94LCByZWN0YW5nbGUuX2IuX3gpLCBNYXRoLm1pbih0aGlzLl9hLl95LCB0aGlzLl9iLl95LCByZWN0YW5nbGUuX2EuX3ksIHJlY3RhbmdsZS5fYi5feSkpO1xuICAgICAgICAgICAgdmFyIGIgPSBuZXcgX1BvaW50Mi5kZWZhdWx0KE1hdGgubWF4KHRoaXMuX2EuX3gsIHRoaXMuX2IuX3gsIHJlY3RhbmdsZS5fYS5feCwgcmVjdGFuZ2xlLl9iLl94KSwgTWF0aC5tYXgodGhpcy5fYS5feSwgdGhpcy5fYi5feSwgcmVjdGFuZ2xlLl9hLl95LCByZWN0YW5nbGUuX2IuX3kpKTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUoYSwgYik7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogTW92ZSB0aGUgcmVjdGFuZ2xlIGJ5IGFwcGx5aW5nIGFuIG9mZnNldCB0byB0aGUgcG9pbnRzIGBhYCBhbmQgYGJgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3Rvcn0gdmVjdG9yIE9mZnNldCB2ZWN0b3IuXG4gICAgICAgICAqIEByZXR1cm4ge1JlY3RhbmdsZX0gTW92ZWQgcmVjdGFuZ2xlLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbW92ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlKHZlY3Rvcikge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpZiAoISh2ZWN0b3IgaW5zdGFuY2VvZiBfVmVjdG9yMi5kZWZhdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09mZnNldCBtdXN0IGJlIGEgdmVjdG9yLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUodGhpcy5fYS5hZGQodmVjdG9yKSwgdGhpcy5fYi5hZGQodmVjdG9yKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogTW92ZSB0aGUgYGFgIHBvaW50IGFuZCBgYmAgcG9pbnQgb2YgdGhpcyByZWN0YW5nbGUgaW5kaXZpZHVhbGx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3Rvcn0gdmVjdG9yQSBPZmZzZXQgdmVjdG9yIGZvciBgYWAgcG9pbnQuXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yfSB2ZWN0b3JCIE9mZnNldCB2ZWN0b3IgZm9yIGBiYCBwb2ludC5cbiAgICAgICAgICogQHJldHVybiB7UmVjdGFuZ2xlfSBNb3ZlZCByZWN0YW5nbGUuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdtb3ZlQUInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZUFCKHZlY3RvckEsIHZlY3RvckIpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEodmVjdG9yQSBpbnN0YW5jZW9mIF9WZWN0b3IyLmRlZmF1bHQpIHx8ICEodmVjdG9yQiBpbnN0YW5jZW9mIF9WZWN0b3IyLmRlZmF1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT2Zmc2V0IG11c3QgYmUgYSB2ZWN0b3IuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLl9hLmFkZCh2ZWN0b3JBKSwgdGhpcy5fYi5hZGQodmVjdG9yQikpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNpbWlsYXIgdG8gbW92ZSwgYnV0IG1vdmVzIGBhYCBhbmQgYGJgIGluIG9wcG9zaXRlIGRpcmVjdGlvbnMgYnlcbiAgICAgICAgICogaW52ZXJ0aW5nIHRoZSB2ZWN0b3IgZm9yIGBhYC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBtZXRob2QgbWF5IHNocmluayB0aGUgcmVjdGFuZ2xlIGlmIHRoZSB2ZWN0b3IgaXMgbmVnYXRpdmUsIG9yIGlmXG4gICAgICAgICAqIHBvaW50cyBgYWAgYW5kIGBiYCBoYXZlIGJlZW4gc3dhcHBlZC4gTm9ybWFsaXplIHRoZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3Rvcn0gdmVjdG9yIFRoZSBvZmZzZXQgdmVjdG9yIHRvIGV4cGFuZCB3aXRoLlxuICAgICAgICAgKiBAcmV0dXJuIHtSZWN0YW5nbGV9IEV4cGFuZGVkIHJlY3RhbmdsZS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2V4cGFuZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBleHBhbmQodmVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb3ZlQUIodmVjdG9yLmludmVydCgpLCB2ZWN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiBhIGdpdmVuIHBvaW50IGlzIG9uIHRoaXMgcmVjdGFuZ2xlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludCBQb2ludCB0byB0ZXN0IHdpdGguXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgcG9pbnQgaXMgd2l0aGluIHJlY3RhbmdsZS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NvbnRhaW5zUG9pbnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29udGFpbnNQb2ludChwb2ludCkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShwb2ludCBpbnN0YW5jZW9mIF9Qb2ludDIuZGVmYXVsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IGJlIGEgcG9pbnQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gKHBvaW50Ll94ID49IHRoaXMuX2EuX3ggJiYgcG9pbnQuX3ggPD0gdGhpcy5fYi5feCB8fCBwb2ludC5feCA+PSB0aGlzLl9iLl94ICYmIHBvaW50Ll94IDw9IHRoaXMuX2EuX3gpICYmIChwb2ludC5feSA+PSB0aGlzLl9hLl95ICYmIHBvaW50Ll95IDw9IHRoaXMuX2IuX3kgfHwgcG9pbnQuX3kgPj0gdGhpcy5fYi5feSAmJiBwb2ludC5feSA8PSB0aGlzLl9hLl95KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgYSBnaXZlbiByZWN0YW5nbGUgaXMgd2l0aGluIHRoaXMgcmVjdGFuZ2xlLiBUaGF0IGlzLFxuICAgICAgICAgKiBib3RoIHBvaW50IGBBYCBhbmQgYEJgIGFyZSB3aXRoaW4gdGhpcyByZWN0YW5nbGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0YW5nbGUgVGhlIHJlY3RhbmdsZSB0byBjaGVjayBmb3IuXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW19IFRydWUgaWYgdGhlIHJlY3RhbmdsZSBpcyB3aXRoaW4gdGhpcyByZWN0YW5nbGUuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjb250YWluc1JlY3RhbmdsZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb250YWluc1JlY3RhbmdsZShyZWN0YW5nbGUpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEocmVjdGFuZ2xlIGluc3RhbmNlb2YgUmVjdGFuZ2xlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgYmUgYSByZWN0YW5nbGUuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250YWluc1BvaW50KHJlY3RhbmdsZS5hKSAmJiB0aGlzLmNvbnRhaW5zUG9pbnQocmVjdGFuZ2xlLmIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiBhIGdpdmVuIHJlY3RhbmdsZSBjb2xsaWRlcyB3aXRoIHRoaXMgcmVjdGFuZ2xlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gcmVjdGFuZ2xlIE90aGVyIHJlY3RhbmdsZSB0byBjb21wYXJlIHdpdGguXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGdpdmVuIHJlY3RhbmdsZSBjb2xsaWRlcyB3aXRoIHRoaXMgb25lLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY29sbGlkZXNSZWN0YW5nbGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29sbGlkZXNSZWN0YW5nbGUocmVjdGFuZ2xlKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGlmICghKHJlY3RhbmdsZSBpbnN0YW5jZW9mIFJlY3RhbmdsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IGJlIGEgcmVjdGFuZ2xlLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2EuX3ggPCByZWN0YW5nbGUuX2IuX3ggJiYgdGhpcy5fYi5feCA+IHJlY3RhbmdsZS5fYS5feCAmJiB0aGlzLl9hLl95IDwgcmVjdGFuZ2xlLl9iLl95ICYmIHRoaXMuX2IuX3kgPiByZWN0YW5nbGUuX2EuX3k7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIGEgZ2l2ZW4gY2lyY2xlIGNvbGxpZGVzIHdpdGggdGhpcyByZWN0YW5nbGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7Q2lyY2xlfSBjaXJjbGUgT3RoZXIgY2lyY2xlIHRvIGNvbXBhcmUgd2l0aC5cbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZ2l2ZW4gY2lyY2xlcyBjb2xsaWRlcyB3aXRoIHRoaXMgb25lLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY29sbGlkZXNDaXJjbGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29sbGlkZXNDaXJjbGUoY2lyY2xlKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGlmICghKGNpcmNsZSBpbnN0YW5jZW9mIF9DaXJjbGUyLmRlZmF1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBiZSBhIGNpcmNsZS4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjbGFtcCA9IGZ1bmN0aW9uIGNsYW1wKHZhbHVlLCBtaW4sIG1heCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgdmFsdWUpKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBjbG9zZXN0ID0gbmV3IF9Qb2ludDIuZGVmYXVsdChjbGFtcChjaXJjbGUuX2EuX3gsIHRoaXMuX2EuX3gsIHRoaXMuX2IuX3gpLCBjbGFtcChjaXJjbGUuX2EuX3ksIHRoaXMuX2EuX3ksIHRoaXMuX2IuX3kpKTtcblxuICAgICAgICAgICAgcmV0dXJuIGNsb3Nlc3QuZGlzdGFuY2VTcShjaXJjbGUuX2EpIDwgY2lyY2xlLl9yICogY2lyY2xlLl9yO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGN1bGF0ZSB0aGUgYXJlYSBvZiB0aGUgZ2l2ZW4gcmVjdGFuZ2xlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSByZWN0YW5nbGUgYXJlYS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2FyZWEnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXJlYSgpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5fYi5feCAtIHRoaXMuX2EuX3gpICogKHRoaXMuX2IuX3kgLSB0aGlzLl9hLl95KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gYW4gYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBpbnN0YW5jZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IHJlcHJlc2VudGF0aW9uIFthLCBiXS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvQXJyYXknLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy5fYS50b0FycmF5KCksIHRoaXMuX2IudG9BcnJheSgpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgaW5zdGFuY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIHthLCBifS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvT2JqZWN0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvT2JqZWN0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhOiB0aGlzLl9hLnRvT2JqZWN0KCksXG4gICAgICAgICAgICAgICAgYjogdGhpcy5fYi50b09iamVjdCgpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybiBhbiBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZSBvZiB0aGlzXG4gICAgICAgICAqIGluc3RhbmNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiB7IGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCB9LlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9Cb3VuZGluZ1JlY3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9Cb3VuZGluZ1JlY3QoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGxlZnQ6IHRoaXMubGVmdCxcbiAgICAgICAgICAgICAgICB0b3A6IHRoaXMudG9wLFxuICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcmVjdGFuZ2xlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbi5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuICcoJyArIHRoaXMuX2EudG9TdHJpbmcoKSArICcsICcgKyB0aGlzLl9iLnRvU3RyaW5nKCkgKyAnKSc7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIGFuIGFycmF5IG9mIGxpbmUgc2VnbWVudHMgb2YgdGhlIGZvdXIgZWRnZXMgb2YgdGhpcyByZWN0YW5nbGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5PExpbmVTZWdtZW50Pn0gQXJyYXkgb2YgbGluZSBzZWdtZW50cy5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvTGluZVNlZ21lbnRzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvTGluZVNlZ21lbnRzKCkge1xuICAgICAgICAgICAgdmFyIGMgPSBuZXcgX1BvaW50Mi5kZWZhdWx0KHRoaXMuX2EuX3gsIHRoaXMuX2IuX3kpO1xuICAgICAgICAgICAgdmFyIGQgPSBuZXcgX1BvaW50Mi5kZWZhdWx0KHRoaXMuX2IuX3gsIHRoaXMuX2EuX3kpO1xuXG4gICAgICAgICAgICByZXR1cm4gW25ldyBfTGluZVNlZ21lbnQyLmRlZmF1bHQodGhpcy5fYSwgZCksIG5ldyBfTGluZVNlZ21lbnQyLmRlZmF1bHQoZCwgdGhpcy5fYiksIG5ldyBfTGluZVNlZ21lbnQyLmRlZmF1bHQodGhpcy5fYiwgYyksIG5ldyBfTGluZVNlZ21lbnQyLmRlZmF1bHQoYywgdGhpcy5fYSldO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIHNoYWxsb3cgY29weSBvZiB0aGlzIGluc3RhbmNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtSZWN0YW5nbGV9IENsb25lZCBpbnN0YW5jZS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Nsb25lJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUodGhpcy5fYSwgdGhpcy5fYik7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIGEgbm9ybWFsaXplIHJlY3RhbmdsZSwgd2l0aCB0aGUgYEFgIHBvaW50IGluIHRoZSB0b3AtbGVmdFxuICAgICAgICAgKiBwb3NpdGlvbiBhbmQgdGhlIGBCYCBwb2ludCBpbiB0aGUgYm90dG9tLXJpZ2h0IHBvc2l0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtSZWN0YW5nbGV9IFRoZSBub3JtYWxpemVkIHJlY3RhbmdsZS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ25vcm1hbGl6ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBub3JtYWxpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZShuZXcgX1BvaW50Mi5kZWZhdWx0KHRoaXMubGVmdCwgdGhpcy50b3ApLCBuZXcgX1BvaW50Mi5kZWZhdWx0KHRoaXMucmlnaHQsIHRoaXMuYm90dG9tKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIHRydWUgaWYgdGhpcyByZWN0YW5nbGUgaXMgZXF1YWwgdG8gYW5vdGhlciByZWN0YW5nbGUuIFR3b1xuICAgICAgICAgKiByZWN0YW5nbGVzIGFyZSBlcXVhbCBpZiBhbmQgb25seSBpZiBib3RoIHBvaW50cyBhcmUgZXF1YWwuIFRoaXMgbWVhbnNcbiAgICAgICAgICogaWYgdHdvIHJlY3RhbmdsZXMgaGF2ZSB0aGUgc2FtZSBsZWZ0LCByaWdodCwgdG9wIGFuZCBib3R0b20sIHRoZXlcbiAgICAgICAgICogbWF5IG5vdCBiZSBlcXVhbCwgYmVjYXVzZSB0aGV5IG1heSBoYXZlIGJlZW4gZGVmaW5lZCBmcm9tIGRpZmZlcmVudFxuICAgICAgICAgKiBwb2ludHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGF0IE90aGVyIGluc3RhbmNlIHRvIGNvbXBhcmUgdG8uXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYm90aCByZWN0YW5nbGVzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZXF1YWxzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVxdWFscyh0aGF0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lID09PSB0aGF0LmNvbnN0cnVjdG9yLm5hbWUgJiYgdGhpcy5fYS5lcXVhbHModGhhdC5fYikgJiYgdGhpcy5fYi5lcXVhbHModGhhdC5fYik7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHJlY3RhbmdsZSBpcyBkZWZpbmVkIGFuZCBmaW5pdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgcmVjdGFuZ2xlIGlzIHZhbGlkLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaXNWYWxpZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc1ZhbGlkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2EuaXNWYWxpZCgpICYmIHRoaXMuX2IuaXNWYWxpZCgpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdhJyxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gcG9pbnQgYEFgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtQb2ludH0gUG9pbnQgYEFgLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gcG9pbnQgYEJgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtQb2ludH0gUG9pbnQgYEJgLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYicsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2I7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIHRoZSBsZWZ0IHggY29vcmRpbmF0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfSBMZWZ0IHggY29vcmRpbmF0ZS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2xlZnQnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIC8vIHJldHVybiBNYXRoLm1pbih0aGlzLl9hLl94LCB0aGlzLl9iLl94KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hLl94O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybiB0aGUgcmlnaHQgeCBjb29yZGluYXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFJpZ2h0IHggY29vcmRpbmF0ZS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3JpZ2h0JyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAvLyByZXR1cm4gTWF0aC5tYXgodGhpcy5fYS5feCwgdGhpcy5fYi5feCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYi5feDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gdGhlIHRvcCB5IGNvb3JkaW5hdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn0gVG9wIHkgY29vcmRpbmF0ZS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvcCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgLy8gcmV0dXJuIE1hdGgubWluKHRoaXMuX2EuX3ksIHRoaXMuX2IuX3kpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2EuX3k7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIHRoZSBib3R0b20geSBjb29yZGluYXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IEJvdHRvbSB5IGNvb3JkaW5hdGUuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdib3R0b20nLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIC8vIHJldHVybiBNYXRoLm1heCh0aGlzLl9hLl95LCB0aGlzLl9iLl95KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9iLl95O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybiB0aGUgd2lkdGggb2YgdGhpcyByZWN0YW5nbGUsIHdoaWNoIGlzIHRoZSBkaWZmZXJlbmNlIGJldHdlZW5cbiAgICAgICAgICogYHRoaXMucmlnaHRgIGFuZCBgdGhpcy5sZWZ0YC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfSBXaWR0aCBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnd2lkdGgnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJpZ2h0IC0gdGhpcy5sZWZ0O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybiB0aGUgaGVpZ2h0IG9mIHRoaXMgcmVjdGFuZ2xlLCB3aGljaCBpcyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuXG4gICAgICAgICAqIGB0aGlzLmJvdHRvbWAgYW5kIGB0aGlzLnRvcGAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn0gSGVpZ2h0IG9mIHRoZSByZWN0YW5nbGUuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdoZWlnaHQnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJvdHRvbSAtIHRoaXMudG9wO1xuICAgICAgICB9XG4gICAgfV0sIFt7XG4gICAgICAgIGtleTogJ2Zyb21BcnJheScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tQXJyYXkoYXJyYXkpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSB8fCBhcnJheS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYW4gYXJyYXkgd2l0aCBhdCBsZWFzdCB0d28gdmFsdWVzLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUoX1BvaW50Mi5kZWZhdWx0LmZyb21BcnJheShhcnJheVswXSksIF9Qb2ludDIuZGVmYXVsdC5mcm9tQXJyYXkoYXJyYXlbMV0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgcmVjdGFuZ2xlIGZyb20gYW4gb2JqZWN0LiBUaGUgb2JqZWN0IHNob3VsZCBoYXZlIGFuIGBhYCBhbmRcbiAgICAgICAgICogYGJgIHByb3BlcnR5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0IElucHV0IG9iamVjdCB3aXRoIGBhYCBhbmQgYGJgIHByb3BlcnR5LlxuICAgICAgICAgKiBAcmV0dXJuIHtSZWN0YW5nbGV9IFJlc3VsdGluZyByZWN0YW5nbGUuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmcm9tT2JqZWN0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIG9iamVjdCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yob2JqZWN0KSkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYW4gb2JqZWN0LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUoX1BvaW50Mi5kZWZhdWx0LmZyb21PYmplY3Qob2JqZWN0LmEpLCBfUG9pbnQyLmRlZmF1bHQuZnJvbU9iamVjdChvYmplY3QuYikpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyByZWN0YW5nbGUgZnJvbSBhIChjbGllbnQpIGJvdW5kaW5nIHJlY3QgZnJvbSBhbiBlbGVtZW50LlxuICAgICAgICAgKiBIb3dldmVyLCBpdCBhY2NlcHRzIGFueSBvYmplY3Qgd2l0aCBhIGBsZWZ0YCwgYHRvcCwgYHdpZHRoYCBhbmQgYGhlaWdodGBcbiAgICAgICAgICogcHJvcGVydHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBib3VuZGluZ1JlY3QgSW5wdXQgYm91bmRpbmcgcmVjdGFuZ2xlLlxuICAgICAgICAgKiBAcmV0dXJuIHtSZWN0YW5nbGV9IFJlY3RhbmdsZSBiYXNlZCBvbiBnaXZlbiBib3VuZGluZyByZWN0YW5nbGUuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmcm9tQm91bmRpbmdSZWN0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21Cb3VuZGluZ1JlY3QoYm91bmRpbmdSZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZShuZXcgX1BvaW50Mi5kZWZhdWx0KGJvdW5kaW5nUmVjdC5sZWZ0LCBib3VuZGluZ1JlY3QudG9wKSwgbmV3IF9Qb2ludDIuZGVmYXVsdChib3VuZGluZ1JlY3QubGVmdCArIGJvdW5kaW5nUmVjdC53aWR0aCwgYm91bmRpbmdSZWN0LnRvcCArIGJvdW5kaW5nUmVjdC5oZWlnaHQpKTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBSZWN0YW5nbGU7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFJlY3RhbmdsZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL1JlY3RhbmdsZS5qc1xuICoqIG1vZHVsZSBpZCA9IC4vc3JjL1JlY3RhbmdsZS5qc1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },

/***/ "./src/LineSegment.js":
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Point = __webpack_require__(\"./src/Point.js\");\n\nvar _Point2 = _interopRequireDefault(_Point);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Immutable line class.\n *\n * A line is defined by two points, `a` and `b`. It has no thickness and its\n * length is inifite (e.g. it extends beyond point `a` and `b`).\n */\n\nvar LineSegment = function () {\n    /**\n     * Construct a new immutable line out of two points.\n     *\n     * @param {Point} a The `A` point..\n     * @param {Point} b The `B` point.\n     * @return {void}\n     */\n\n    function LineSegment(a, b) {\n        _classCallCheck(this, LineSegment);\n\n        this._a = a;\n        this._b = b;\n    }\n\n    /**\n     * Return point `A`.\n     *\n     * @return {Point} Point `A`.\n     */\n\n\n    _createClass(LineSegment, [{\n        key: 'intersection',\n\n\n        /**\n         * Calculate the intersection point of the two line segments. If there is\n         * no intersection, this method returns null.\n         *\n         * Algorithm is based on http://stackoverflow.com/a/35457290/1423623.\n         *\n         * @param {LineSegment} other The other line segment.\n         * @return {Point?} Point of intersection, if any.\n         */\n        value: function intersection(other) {\n            var dx1 = this._b._x - this._a._x;\n            var dy1 = this._b._y - this._a._y;\n\n            var dx2 = other._b._x - other._a._x;\n            var dy2 = other._b._y - other._a._y;\n\n            var dx3 = this._a._x - other._a._x;\n            var dy3 = this._a._y - other._a._y;\n\n            var d = dx1 * dy2 - dx2 * dy1;\n\n            if (d !== 0) {\n                var s = dx1 * dy3 - dx3 * dy1;\n\n                if (s <= 0 && d < 0 && s >= d || s >= 0 && d > 0 && s <= d) {\n                    var t = dx2 * dy3 - dx3 * dy2;\n\n                    if (t <= 0 && d < 0 && t > d || t >= 0 && d > 0 && t < d) {\n                        var u = t / d;\n\n                        return new _Point2.default(this._a._x + u * dx1, this._a._y + u * dy1);\n                    }\n                }\n            }\n\n            return null;\n        }\n\n        /**\n         * Create a shallow copy of this instance.\n         *\n         * @return {LineSegment} Cloned instance.\n         */\n\n    }, {\n        key: 'clone',\n        value: function clone() {\n            return new LineSegment(this._a, this._b);\n        }\n\n        /**\n         * Return true if the line segment is defined and finite.\n         *\n         * @return {Boolean} True if line segment is valid.\n         */\n\n    }, {\n        key: 'isValid',\n        value: function isValid() {\n            return this._a.isValid() && this._b.isValid();\n        }\n    }, {\n        key: 'a',\n        get: function get() {\n            return this._a;\n        }\n\n        /**\n         * Return point `B`.\n         *\n         * @return {Point} Point `B`.\n         */\n\n    }, {\n        key: 'b',\n        get: function get() {\n            return this._b;\n        }\n\n        /**\n         * Return the length.\n         *\n         * @return {float} length of line, which is infinity, per definition.\n         */\n\n    }, {\n        key: 'length',\n        get: function get() {\n            return this._a.distance(this._b);\n        }\n    }]);\n\n    return LineSegment;\n}();\n\nexports.default = LineSegment;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvTGluZVNlZ21lbnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvTGluZVNlZ21lbnQuanM/OGViYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9Qb2ludCA9IHJlcXVpcmUoJy4vUG9pbnQnKTtcblxudmFyIF9Qb2ludDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Qb2ludCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogSW1tdXRhYmxlIGxpbmUgY2xhc3MuXG4gKlxuICogQSBsaW5lIGlzIGRlZmluZWQgYnkgdHdvIHBvaW50cywgYGFgIGFuZCBgYmAuIEl0IGhhcyBubyB0aGlja25lc3MgYW5kIGl0c1xuICogbGVuZ3RoIGlzIGluaWZpdGUgKGUuZy4gaXQgZXh0ZW5kcyBiZXlvbmQgcG9pbnQgYGFgIGFuZCBgYmApLlxuICovXG5cbnZhciBMaW5lU2VnbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgaW1tdXRhYmxlIGxpbmUgb3V0IG9mIHR3byBwb2ludHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBhIFRoZSBgQWAgcG9pbnQuLlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IGIgVGhlIGBCYCBwb2ludC5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gTGluZVNlZ21lbnQoYSwgYikge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGluZVNlZ21lbnQpO1xuXG4gICAgICAgIHRoaXMuX2EgPSBhO1xuICAgICAgICB0aGlzLl9iID0gYjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gcG9pbnQgYEFgLlxuICAgICAqXG4gICAgICogQHJldHVybiB7UG9pbnR9IFBvaW50IGBBYC5cbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKExpbmVTZWdtZW50LCBbe1xuICAgICAgICBrZXk6ICdpbnRlcnNlY3Rpb24nLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGN1bGF0ZSB0aGUgaW50ZXJzZWN0aW9uIHBvaW50IG9mIHRoZSB0d28gbGluZSBzZWdtZW50cy4gSWYgdGhlcmUgaXNcbiAgICAgICAgICogbm8gaW50ZXJzZWN0aW9uLCB0aGlzIG1ldGhvZCByZXR1cm5zIG51bGwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEFsZ29yaXRobSBpcyBiYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zNTQ1NzI5MC8xNDIzNjIzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0xpbmVTZWdtZW50fSBvdGhlciBUaGUgb3RoZXIgbGluZSBzZWdtZW50LlxuICAgICAgICAgKiBAcmV0dXJuIHtQb2ludD99IFBvaW50IG9mIGludGVyc2VjdGlvbiwgaWYgYW55LlxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGludGVyc2VjdGlvbihvdGhlcikge1xuICAgICAgICAgICAgdmFyIGR4MSA9IHRoaXMuX2IuX3ggLSB0aGlzLl9hLl94O1xuICAgICAgICAgICAgdmFyIGR5MSA9IHRoaXMuX2IuX3kgLSB0aGlzLl9hLl95O1xuXG4gICAgICAgICAgICB2YXIgZHgyID0gb3RoZXIuX2IuX3ggLSBvdGhlci5fYS5feDtcbiAgICAgICAgICAgIHZhciBkeTIgPSBvdGhlci5fYi5feSAtIG90aGVyLl9hLl95O1xuXG4gICAgICAgICAgICB2YXIgZHgzID0gdGhpcy5fYS5feCAtIG90aGVyLl9hLl94O1xuICAgICAgICAgICAgdmFyIGR5MyA9IHRoaXMuX2EuX3kgLSBvdGhlci5fYS5feTtcblxuICAgICAgICAgICAgdmFyIGQgPSBkeDEgKiBkeTIgLSBkeDIgKiBkeTE7XG5cbiAgICAgICAgICAgIGlmIChkICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHMgPSBkeDEgKiBkeTMgLSBkeDMgKiBkeTE7XG5cbiAgICAgICAgICAgICAgICBpZiAocyA8PSAwICYmIGQgPCAwICYmIHMgPj0gZCB8fCBzID49IDAgJiYgZCA+IDAgJiYgcyA8PSBkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gZHgyICogZHkzIC0gZHgzICogZHkyO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0IDw9IDAgJiYgZCA8IDAgJiYgdCA+IGQgfHwgdCA+PSAwICYmIGQgPiAwICYmIHQgPCBkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdSA9IHQgLyBkO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IF9Qb2ludDIuZGVmYXVsdCh0aGlzLl9hLl94ICsgdSAqIGR4MSwgdGhpcy5fYS5feSArIHUgKiBkeTEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBzaGFsbG93IGNvcHkgb2YgdGhpcyBpbnN0YW5jZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7TGluZVNlZ21lbnR9IENsb25lZCBpbnN0YW5jZS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Nsb25lJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaW5lU2VnbWVudCh0aGlzLl9hLCB0aGlzLl9iKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgbGluZSBzZWdtZW50IGlzIGRlZmluZWQgYW5kIGZpbml0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiBsaW5lIHNlZ21lbnQgaXMgdmFsaWQuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdpc1ZhbGlkJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzVmFsaWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYS5pc1ZhbGlkKCkgJiYgdGhpcy5fYi5pc1ZhbGlkKCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2EnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybiBwb2ludCBgQmAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1BvaW50fSBQb2ludCBgQmAuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdiJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gdGhlIGxlbmd0aC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7ZmxvYXR9IGxlbmd0aCBvZiBsaW5lLCB3aGljaCBpcyBpbmZpbml0eSwgcGVyIGRlZmluaXRpb24uXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdsZW5ndGgnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hLmRpc3RhbmNlKHRoaXMuX2IpO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIExpbmVTZWdtZW50O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBMaW5lU2VnbWVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL0xpbmVTZWdtZW50LmpzXG4gKiogbW9kdWxlIGlkID0gLi9zcmMvTGluZVNlZ21lbnQuanNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },

/***/ "./src/Line.js":
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Point = __webpack_require__(\"./src/Point.js\");\n\nvar _Point2 = _interopRequireDefault(_Point);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Immutable line class.\n *\n * A line is defined by two points, `a` and `b`. It has no thickness and its\n * length is inifite (e.g. it extends beyond point `a` and `b`).\n */\n\nvar Line = function () {\n  /**\n   * Construct a new immutable line out of two points.\n   *\n   * @param {Point} a The `A` point..\n   * @param {Point} b The `B` point.\n   * @return {void}\n   */\n\n  function Line(a, b) {\n    _classCallCheck(this, Line);\n\n    this._a = a;\n    this._b = b;\n  }\n\n  /**\n   * Return point `A`.\n   *\n   * @return {Point} Point `A`.\n   */\n\n\n  _createClass(Line, [{\n    key: 'clone',\n\n\n    /**\n     * Create a shallow copy of this instance.\n     *\n     * @return {Line} Cloned instance.\n     */\n    value: function clone() {\n      return new Line(this._a, this._b);\n    }\n\n    /**\n     * Return true if the line is defined and finite.\n     *\n     * @return {Boolean} True if line is valid.\n     */\n\n  }, {\n    key: 'isValid',\n    value: function isValid() {\n      return this._a.isValid() && this._b.isValid();\n    }\n  }, {\n    key: 'a',\n    get: function get() {\n      return this._a;\n    }\n\n    /**\n     * Return point `B`.\n     *\n     * @return {Point} Point `B`.\n     */\n\n  }, {\n    key: 'b',\n    get: function get() {\n      return this._b;\n    }\n\n    /**\n     * Return the length.\n     *\n     * @return {float} length of line, which is infinity, per definition.\n     */\n\n  }, {\n    key: 'length',\n    get: function get() {\n      return Infinity;\n    }\n  }]);\n\n  return Line;\n}();\n\nexports.default = Line;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvTGluZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9MaW5lLmpzP2U5ZjIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX1BvaW50ID0gcmVxdWlyZSgnLi9Qb2ludCcpO1xuXG52YXIgX1BvaW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1BvaW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBJbW11dGFibGUgbGluZSBjbGFzcy5cbiAqXG4gKiBBIGxpbmUgaXMgZGVmaW5lZCBieSB0d28gcG9pbnRzLCBgYWAgYW5kIGBiYC4gSXQgaGFzIG5vIHRoaWNrbmVzcyBhbmQgaXRzXG4gKiBsZW5ndGggaXMgaW5pZml0ZSAoZS5nLiBpdCBleHRlbmRzIGJleW9uZCBwb2ludCBgYWAgYW5kIGBiYCkuXG4gKi9cblxudmFyIExpbmUgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgaW1tdXRhYmxlIGxpbmUgb3V0IG9mIHR3byBwb2ludHMuXG4gICAqXG4gICAqIEBwYXJhbSB7UG9pbnR9IGEgVGhlIGBBYCBwb2ludC4uXG4gICAqIEBwYXJhbSB7UG9pbnR9IGIgVGhlIGBCYCBwb2ludC5cbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG5cbiAgZnVuY3Rpb24gTGluZShhLCBiKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExpbmUpO1xuXG4gICAgdGhpcy5fYSA9IGE7XG4gICAgdGhpcy5fYiA9IGI7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHBvaW50IGBBYC5cbiAgICpcbiAgICogQHJldHVybiB7UG9pbnR9IFBvaW50IGBBYC5cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoTGluZSwgW3tcbiAgICBrZXk6ICdjbG9uZScsXG5cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHNoYWxsb3cgY29weSBvZiB0aGlzIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7TGluZX0gQ2xvbmVkIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgIHJldHVybiBuZXcgTGluZSh0aGlzLl9hLCB0aGlzLl9iKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgbGluZSBpcyBkZWZpbmVkIGFuZCBmaW5pdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIGxpbmUgaXMgdmFsaWQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2lzVmFsaWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1ZhbGlkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2EuaXNWYWxpZCgpICYmIHRoaXMuX2IuaXNWYWxpZCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2EnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2E7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHBvaW50IGBCYC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1BvaW50fSBQb2ludCBgQmAuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2InLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBsZW5ndGguXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtmbG9hdH0gbGVuZ3RoIG9mIGxpbmUsIHdoaWNoIGlzIGluZmluaXR5LCBwZXIgZGVmaW5pdGlvbi5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbGVuZ3RoJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGluZTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gTGluZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL0xpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSAuL3NyYy9MaW5lLmpzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }

/******/ });