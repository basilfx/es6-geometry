/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Vector = exports.Rectangle = exports.Point = exports.Circle = undefined;\n\nvar _Circle = __webpack_require__(1);\n\nvar _Circle2 = _interopRequireDefault(_Circle);\n\nvar _Point = __webpack_require__(2);\n\nvar _Point2 = _interopRequireDefault(_Point);\n\nvar _Rectangle = __webpack_require__(5);\n\nvar _Rectangle2 = _interopRequireDefault(_Rectangle);\n\nvar _Vector = __webpack_require__(4);\n\nvar _Vector2 = _interopRequireDefault(_Vector);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.Circle = _Circle2.default;\nexports.Point = _Point2.default;\nexports.Rectangle = _Rectangle2.default;\nexports.Vector = _Vector2.default;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9pbmRleC5qcz9jODcyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5WZWN0b3IgPSBleHBvcnRzLlJlY3RhbmdsZSA9IGV4cG9ydHMuUG9pbnQgPSBleHBvcnRzLkNpcmNsZSA9IHVuZGVmaW5lZDtcblxudmFyIF9DaXJjbGUgPSByZXF1aXJlKCcuL0NpcmNsZScpO1xuXG52YXIgX0NpcmNsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DaXJjbGUpO1xuXG52YXIgX1BvaW50ID0gcmVxdWlyZSgnLi9Qb2ludCcpO1xuXG52YXIgX1BvaW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1BvaW50KTtcblxudmFyIF9SZWN0YW5nbGUgPSByZXF1aXJlKCcuL1JlY3RhbmdsZScpO1xuXG52YXIgX1JlY3RhbmdsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9SZWN0YW5nbGUpO1xuXG52YXIgX1ZlY3RvciA9IHJlcXVpcmUoJy4vVmVjdG9yJyk7XG5cbnZhciBfVmVjdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1ZlY3Rvcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuQ2lyY2xlID0gX0NpcmNsZTIuZGVmYXVsdDtcbmV4cG9ydHMuUG9pbnQgPSBfUG9pbnQyLmRlZmF1bHQ7XG5leHBvcnRzLlJlY3RhbmdsZSA9IF9SZWN0YW5nbGUyLmRlZmF1bHQ7XG5leHBvcnRzLlZlY3RvciA9IF9WZWN0b3IyLmRlZmF1bHQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Point = __webpack_require__(2);\n\nvar _Point2 = _interopRequireDefault(_Point);\n\nvar _Rectangle = __webpack_require__(5);\n\nvar _Rectangle2 = _interopRequireDefault(_Rectangle);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Immutable circle class.\n */\n\nvar Circle = function () {\n    /**\n     * Construct a new circle using center point `A` and radius `r`.\n     *\n     * @param {Point} a Center point `A`.\n     * @param {number} r The radius `r`.\n     * @return {void}\n     */\n\n    function Circle(a, r) {\n        _classCallCheck(this, Circle);\n\n        this._a = a;\n        this._r = r;\n    }\n\n    /**\n     * Get the circle center point.\n     *\n     * @return {Point} Center point.\n     */\n\n\n    _createClass(Circle, [{\n        key: 'toRectangle',\n\n\n        /**\n         * Convert this circle to a rectangle that contains this circle exactly.\n         *\n         * @return {Rectangle} Converted rectangle.\n         */\n        value: function toRectangle() {\n            var a = new _Point2.default(this._a._x - this.radius, this._a._y - this.radius);\n            var b = new _Point2.default(this._a._x + this.radius, this._a._y + this.radius);\n\n            return new _Rectangle2.default(a, b);\n        }\n\n        /**\n         * Convert this circle into an object.\n         *\n         * @return {object} Object representation (x, y, r).\n         */\n\n    }, {\n        key: 'toObject',\n        value: function toObject() {\n            return {\n                x: this._a._x,\n                y: this._a._y,\n                r: this._r\n            };\n        }\n\n        /**\n         * Convert this circle into an array.\n         *\n         * @return {Array} Array representation (x, y, r).\n         */\n\n    }, {\n        key: 'toArray',\n        value: function toArray() {\n            return [this._a._x, this._a._y, this._r];\n        }\n\n        /**\n         * Convert this circle into a string representation.\n         *\n         * @return {string} String representation (x, y, r).\n         */\n\n    }, {\n        key: 'toString',\n        value: function toString() {\n            return '(' + this._a._x + ', ' + this._a._y + ', ' + this._r + ')';\n        }\n\n        /**\n         * Create a shallow copy of this instance.\n         *\n         * @return {Circle} Cloned instance.\n         */\n\n    }, {\n        key: 'clone',\n        value: function clone() {\n            return new Circle(this._a, this._r);\n        }\n\n        /**\n         * Return true if this circle is equal to another circle. Two circles are\n         * equal if and only if the center point and radius are equal.\n         *\n         * @param {object} that Other instance to compare to.\n         * @return {boolean} True if both circles are equal, false otherwise.\n         */\n\n    }, {\n        key: 'equals',\n        value: function equals(that) {\n            return this.constructor.name === that.constructor.name && this._a.equals(that._a) && this._r === that._r;\n        }\n\n        /**\n         * Return true if the circle is defined, finite and valid.\n         *\n         * @return {Boolean} True if the circle is fully defined, finite and valid.\n         */\n\n    }, {\n        key: 'isValid',\n        value: function isValid() {\n            return this._a.isValid() && typeof this._r === 'number' && isFinite(this._r) && this._r >= 0;\n        }\n    }, {\n        key: 'a',\n        get: function get() {\n            return this._a;\n        }\n\n        /**\n         * Get the circle center x coordinate. Shortcut for `this.a.x`.\n         *\n         * @return {number} Circle center x coordinate.\n         */\n\n    }, {\n        key: 'x',\n        get: function get() {\n            return this._a._x;\n        }\n\n        /**\n         * Get the circle center y coordinate. Shortcut for `this.a.y`.\n         *\n         * @return {number} Circle center y coordinate.\n         */\n\n    }, {\n        key: 'y',\n        get: function get() {\n            return this._a._y;\n        }\n\n        /**\n         * Get the circle radius.\n         *\n         * @return {number} Circle radius.\n         */\n\n    }, {\n        key: 'r',\n        get: function get() {\n            return this._r;\n        }\n\n        /**\n         * Get the diameter. This is a shortcut for `this.r * 2`.\n         *\n         * @return {number} The circle diameter.\n         */\n\n    }, {\n        key: 'd',\n        get: function get() {\n            return this._r * 2;\n        }\n    }]);\n\n    return Circle;\n}();\n\nexports.default = Circle;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9DaXJjbGUuanM/NTU2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9Qb2ludCA9IHJlcXVpcmUoJy4vUG9pbnQnKTtcblxudmFyIF9Qb2ludDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Qb2ludCk7XG5cbnZhciBfUmVjdGFuZ2xlID0gcmVxdWlyZSgnLi9SZWN0YW5nbGUnKTtcblxudmFyIF9SZWN0YW5nbGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUmVjdGFuZ2xlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBJbW11dGFibGUgY2lyY2xlIGNsYXNzLlxuICovXG5cbnZhciBDaXJjbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IGNpcmNsZSB1c2luZyBjZW50ZXIgcG9pbnQgYEFgIGFuZCByYWRpdXMgYHJgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQb2ludH0gYSBDZW50ZXIgcG9pbnQgYEFgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByIFRoZSByYWRpdXMgYHJgLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBDaXJjbGUoYSwgcikge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2lyY2xlKTtcblxuICAgICAgICB0aGlzLl9hID0gYTtcbiAgICAgICAgdGhpcy5fciA9IHI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjaXJjbGUgY2VudGVyIHBvaW50LlxuICAgICAqXG4gICAgICogQHJldHVybiB7UG9pbnR9IENlbnRlciBwb2ludC5cbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKENpcmNsZSwgW3tcbiAgICAgICAga2V5OiAndG9SZWN0YW5nbGUnLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnQgdGhpcyBjaXJjbGUgdG8gYSByZWN0YW5nbGUgdGhhdCBjb250YWlucyB0aGlzIGNpcmNsZSBleGFjdGx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtSZWN0YW5nbGV9IENvbnZlcnRlZCByZWN0YW5nbGUuXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9SZWN0YW5nbGUoKSB7XG4gICAgICAgICAgICB2YXIgYSA9IG5ldyBfUG9pbnQyLmRlZmF1bHQodGhpcy5fYS5feCAtIHRoaXMucmFkaXVzLCB0aGlzLl9hLl95IC0gdGhpcy5yYWRpdXMpO1xuICAgICAgICAgICAgdmFyIGIgPSBuZXcgX1BvaW50Mi5kZWZhdWx0KHRoaXMuX2EuX3ggKyB0aGlzLnJhZGl1cywgdGhpcy5fYS5feSArIHRoaXMucmFkaXVzKTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBfUmVjdGFuZ2xlMi5kZWZhdWx0KGEsIGIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnQgdGhpcyBjaXJjbGUgaW50byBhbiBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uICh4LCB5LCByKS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvT2JqZWN0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvT2JqZWN0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiB0aGlzLl9hLl94LFxuICAgICAgICAgICAgICAgIHk6IHRoaXMuX2EuX3ksXG4gICAgICAgICAgICAgICAgcjogdGhpcy5fclxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0IHRoaXMgY2lyY2xlIGludG8gYW4gYXJyYXkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5fSBBcnJheSByZXByZXNlbnRhdGlvbiAoeCwgeSwgcikuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b0FycmF5JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvQXJyYXkoKSB7XG4gICAgICAgICAgICByZXR1cm4gW3RoaXMuX2EuX3gsIHRoaXMuX2EuX3ksIHRoaXMuX3JdO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnQgdGhpcyBjaXJjbGUgaW50byBhIHN0cmluZyByZXByZXNlbnRhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gKHgsIHksIHIpLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9TdHJpbmcnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gJygnICsgdGhpcy5fYS5feCArICcsICcgKyB0aGlzLl9hLl95ICsgJywgJyArIHRoaXMuX3IgKyAnKSc7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgc2hhbGxvdyBjb3B5IG9mIHRoaXMgaW5zdGFuY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0NpcmNsZX0gQ2xvbmVkIGluc3RhbmNlLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2xvbmUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENpcmNsZSh0aGlzLl9hLCB0aGlzLl9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGlzIGNpcmNsZSBpcyBlcXVhbCB0byBhbm90aGVyIGNpcmNsZS4gVHdvIGNpcmNsZXMgYXJlXG4gICAgICAgICAqIGVxdWFsIGlmIGFuZCBvbmx5IGlmIHRoZSBjZW50ZXIgcG9pbnQgYW5kIHJhZGl1cyBhcmUgZXF1YWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGF0IE90aGVyIGluc3RhbmNlIHRvIGNvbXBhcmUgdG8uXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYm90aCBjaXJjbGVzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZXF1YWxzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVxdWFscyh0aGF0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lID09PSB0aGF0LmNvbnN0cnVjdG9yLm5hbWUgJiYgdGhpcy5fYS5lcXVhbHModGhhdC5fYSkgJiYgdGhpcy5fciA9PT0gdGhhdC5fcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgY2lyY2xlIGlzIGRlZmluZWQsIGZpbml0ZSBhbmQgdmFsaWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIGNpcmNsZSBpcyBmdWxseSBkZWZpbmVkLCBmaW5pdGUgYW5kIHZhbGlkLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaXNWYWxpZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc1ZhbGlkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2EuaXNWYWxpZCgpICYmIHR5cGVvZiB0aGlzLl9yID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh0aGlzLl9yKSAmJiB0aGlzLl9yID49IDA7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2EnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY2lyY2xlIGNlbnRlciB4IGNvb3JkaW5hdGUuIFNob3J0Y3V0IGZvciBgdGhpcy5hLnhgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IENpcmNsZSBjZW50ZXIgeCBjb29yZGluYXRlLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAneCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2EuX3g7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjaXJjbGUgY2VudGVyIHkgY29vcmRpbmF0ZS4gU2hvcnRjdXQgZm9yIGB0aGlzLmEueWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn0gQ2lyY2xlIGNlbnRlciB5IGNvb3JkaW5hdGUuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd5JyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYS5feTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGNpcmNsZSByYWRpdXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn0gQ2lyY2xlIHJhZGl1cy5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3InLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgZGlhbWV0ZXIuIFRoaXMgaXMgYSBzaG9ydGN1dCBmb3IgYHRoaXMuciAqIDJgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBjaXJjbGUgZGlhbWV0ZXIuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdkJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fciAqIDI7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQ2lyY2xlO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBDaXJjbGU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9DaXJjbGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Vector = __webpack_require__(4);\n\nvar _Vector2 = _interopRequireDefault(_Vector);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Immutable point class.\n *\n * A point is an absolute place in space, at a given x and y coordinate.\n *\n * The difference between a Point and a vector is explained in this source:\n * http://math.stackexchange.com/a/645827\n */\n\nvar Point = function () {\n    /**\n     * Construct a new point, using a x and y coordinate.\n     *\n     * An point is immutable. All subsequent operations will return a new point\n     * instance.\n     *\n     * @param {number} x The x coordinate.\n     * @param {number} y The y coordinate.\n     * @return {void}\n     */\n\n    function Point(x, y) {\n        _classCallCheck(this, Point);\n\n        this._x = x;\n        this._y = y;\n    }\n\n    /**\n     * Create a new point from an array. The first index is considered the x\n     * coordinate, the second index is considered the y coordinate.\n     *\n     * @param {Array} array Input array with at least two values.\n     * @return {Point} Resulting point.\n     */\n\n\n    _createClass(Point, [{\n        key: 'add',\n\n\n        /**\n         * Add a vector to a point.\n         *\n         * Note that addition of two points is undefined.\n         *\n         * @param {Vector} vector Vector to add to this point.\n         * @return {Point} Point with the vector added to it.\n         */\n        value: function add(vector) {\n            if (vector instanceof Point) {\n                throw new Error('Addition of two points is undefined.');\n            }\n\n            return new Point(this._x + vector._x, this._y + vector._y);\n        }\n\n        /**\n         * Subtract a Point or a Vector.\n         *\n         * @param {Point|Vector} that Point or vector to subtract.\n         * @return {Point} If `that` is a Vector, it will return the new point.\n         * @return {Vector} If `that` is a Point, it will return the displacement.\n         */\n\n    }, {\n        key: 'subtract',\n        value: function subtract(that) {\n            if (that instanceof Point) {\n                return this.toVector().subtract(that);\n            }\n\n            return new Point(this._x - that._x, this._y - that._y);\n        }\n\n        /**\n         * Invert the x and y coordinate, relative to (0, 0).\n         *\n         * @return {Point} Inverted point.\n         */\n\n    }, {\n        key: 'invert',\n        value: function invert() {\n            return new Point(-this._x, -this._y);\n        }\n\n        /**\n         * @return {Point}\n         */\n\n    }, {\n        key: 'multiply',\n        value: function multiply(scalar) {\n            return new Point(this._x * scalar, this._y * scalar);\n        }\n\n        /**\n         * @return {Point}\n         */\n\n    }, {\n        key: 'multiplyXY',\n        value: function multiplyXY(scalarX, scalarY) {\n            return new Point(this._x * scalarX, this._y * scalarY);\n        }\n\n        /**\n         * @return {Point}\n         */\n\n    }, {\n        key: 'divide',\n        value: function divide(scalar) {\n            return new Point(this._x / scalar, this._y / scalar);\n        }\n\n        /**\n         * @return {Point}\n         */\n\n    }, {\n        key: 'divideXY',\n        value: function divideXY(scalarX, scalarY) {\n            return new Point(this._x / scalarX, this._y / scalarY);\n        }\n\n        /**\n         * @return {Point}\n         */\n\n    }, {\n        key: 'mix',\n        value: function mix(that) {\n            var amount = arguments.length <= 1 || arguments[1] === undefined ? 0.5 : arguments[1];\n\n            return this.multiply(1 - amount).add(that.multiply(amount));\n        }\n\n        /**\n         * @return {Point}\n         */\n\n    }, {\n        key: 'perpendicular',\n        value: function perpendicular() {\n            return new Point(-this._y, this._x);\n        }\n\n        /**\n         * @return {Point}\n         */\n\n    }, {\n        key: 'snap',\n        value: function snap(to) {\n            var round = function round(val) {\n                return Math.round(val / to) * to;\n            };\n\n            return new Point(round(this._x), round(this._y));\n        }\n\n        /**\n         * @return {number}\n         */\n\n    }, {\n        key: 'dot',\n        value: function dot(that) {\n            return this._x * that._x + this._y * that._y;\n        }\n\n        /**\n         * @return {number}\n         */\n\n    }, {\n        key: 'angle',\n        value: function angle() {\n            return Math.atan2(this._y, this._x);\n        }\n\n        /**\n         * @return {number}\n         */\n\n    }, {\n        key: 'angleDeg',\n        value: function angleDeg() {\n            return Math.atan2(this._y, this._x) * 180 / Math.PI;\n        }\n\n        /**\n         * @return {number}\n         */\n\n    }, {\n        key: 'slope',\n        value: function slope() {\n            return this._y / this._x;\n        }\n\n        /**\n         * Calculate the squared distance between two points.\n         *\n         * If the exact distance doesn't matter, this method is slightly faster\n         * than `this.distance`.\n         *\n         * @param {Point} point The other point.\n         * @return {number} The distance between both points.\n         */\n\n    }, {\n        key: 'distanceSq',\n        value: function distanceSq(point) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (!(point instanceof Point)) {\n                    throw new Error('Must be a point.');\n                }\n            }\n\n            var dX = this._x - point._x;\n            var dY = this._y - point._y;\n\n            return dX * dX + dY * dY;\n        }\n\n        /**\n         * Calculate the distance between two points.\n         *\n         * @param {Point} point The other point.\n         * @return {number} The distance between both points.\n         */\n\n    }, {\n        key: 'distance',\n        value: function distance(point) {\n            return Math.sqrt(this.distanceSq(point));\n        }\n\n        /**\n         * Convert point into a vector.\n         *\n         * Note: this is an utility method. A proper conversion does not exist.\n         *\n         * @return {Vector} The point converted as vector.\n         */\n\n    }, {\n        key: 'toVector',\n        value: function toVector() {\n            return new _Vector2.default(this._x, this._y);\n        }\n\n        /**\n         * Convert this point into an array.\n         *\n         * @return {Array} Array representation (x, y).\n         */\n\n    }, {\n        key: 'toArray',\n        value: function toArray() {\n            return [this._x, this._y];\n        }\n\n        /**\n         * Convert this point into an object.\n         *\n         * @return {object} Object representation (x, y).\n         */\n\n    }, {\n        key: 'toObject',\n        value: function toObject() {\n            return { x: this._x, y: this._y };\n        }\n\n        /**\n         * Convert this point into a string representation.\n         *\n         * @return {string} String representation (x, y).\n         */\n\n    }, {\n        key: 'toString',\n        value: function toString() {\n            return '(' + this._x + ', ' + this._y + ')';\n        }\n\n        /**\n         * Convert this point into a string representation, using a fixed number of\n         * digits for displaying.\n         *\n         * @param {number} digits Number of digits to use for representation.\n         * @return {string} String representation (x, y).\n         */\n\n    }, {\n        key: 'toFixed',\n        value: function toFixed(digits) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (typeof digits !== 'number') {\n                    throw new Error('Number of digits must be a number.');\n                }\n            }\n\n            return '(' + this._x.toFixed(digits) + ', ' + this._y.toFixed(digits) + ')';\n        }\n\n        /**\n         * Create a shallow copy of this instance.\n         *\n         * @return {Point} Cloned instance.\n         */\n\n    }, {\n        key: 'clone',\n        value: function clone() {\n            return new Point(this._x, this._y);\n        }\n\n        /**\n         * Return true if this point is equal to another point. Two points are\n         * equal when both x and y coordinates are equal.\n         *\n         * @param {object} that Other instance to compare to.\n         * @return {boolean} True if both points are equal, false otherwise.\n         */\n\n    }, {\n        key: 'equals',\n        value: function equals(that) {\n            return this.constructor.name === that.constructor.name && this._x === that._x && this._y === that._y;\n        }\n\n        /**\n         * Return true if the point is defined and finite.\n         *\n         * @return {Boolean} True if point is fully defined and valid.\n         */\n\n    }, {\n        key: 'isValid',\n        value: function isValid() {\n            return typeof this._x === 'number' && isFinite(this._x) && typeof this._y === 'number' && isFinite(this._y);\n        }\n    }, {\n        key: 'x',\n\n\n        /**\n         * Get the x coordinate.\n         *\n         * @return {number} The x coordinate.\n         */\n        get: function get() {\n            return this._x;\n        }\n\n        /**\n         * Get the y coordinate.\n         *\n         * @return {number} The y coordinate.\n         */\n\n    }, {\n        key: 'y',\n        get: function get() {\n            return this._y;\n        }\n    }], [{\n        key: 'fromArray',\n        value: function fromArray(array) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (!Array.isArray(array) || array.length < 2) {\n                    throw new Error('Expected an array with at least two values.');\n                }\n            }\n\n            return new Point(array[0], array[1]);\n        }\n\n        /**\n         * Create a new point from an object. The object should have an x and y\n         * property.\n         *\n         * @param {object} object Input object with x and y property.\n         * @return {Point} Resulting point.\n         */\n\n    }, {\n        key: 'fromObject',\n        value: function fromObject(object) {\n            if (process.env.NODE_ENV !== 'production') {\n                if ((typeof object === 'undefined' ? 'undefined' : _typeof(object)) !== 'object') {\n                    throw new Error('Expected an object.');\n                }\n            }\n\n            return new Point(object.x, object.y);\n        }\n    }]);\n\n    return Point;\n}();\n\nexports.default = Point;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9Qb2ludC5qcz8zNzYxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9WZWN0b3IgPSByZXF1aXJlKCcuL1ZlY3RvcicpO1xuXG52YXIgX1ZlY3RvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9WZWN0b3IpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIEltbXV0YWJsZSBwb2ludCBjbGFzcy5cbiAqXG4gKiBBIHBvaW50IGlzIGFuIGFic29sdXRlIHBsYWNlIGluIHNwYWNlLCBhdCBhIGdpdmVuIHggYW5kIHkgY29vcmRpbmF0ZS5cbiAqXG4gKiBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGEgUG9pbnQgYW5kIGEgdmVjdG9yIGlzIGV4cGxhaW5lZCBpbiB0aGlzIHNvdXJjZTpcbiAqIGh0dHA6Ly9tYXRoLnN0YWNrZXhjaGFuZ2UuY29tL2EvNjQ1ODI3XG4gKi9cblxudmFyIFBvaW50ID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyBwb2ludCwgdXNpbmcgYSB4IGFuZCB5IGNvb3JkaW5hdGUuXG4gICAgICpcbiAgICAgKiBBbiBwb2ludCBpcyBpbW11dGFibGUuIEFsbCBzdWJzZXF1ZW50IG9wZXJhdGlvbnMgd2lsbCByZXR1cm4gYSBuZXcgcG9pbnRcbiAgICAgKiBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IFRoZSB4IGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgVGhlIHkgY29vcmRpbmF0ZS5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gUG9pbnQoeCwgeSkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9pbnQpO1xuXG4gICAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgICB0aGlzLl95ID0geTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgcG9pbnQgZnJvbSBhbiBhcnJheS4gVGhlIGZpcnN0IGluZGV4IGlzIGNvbnNpZGVyZWQgdGhlIHhcbiAgICAgKiBjb29yZGluYXRlLCB0aGUgc2Vjb25kIGluZGV4IGlzIGNvbnNpZGVyZWQgdGhlIHkgY29vcmRpbmF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IElucHV0IGFycmF5IHdpdGggYXQgbGVhc3QgdHdvIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJuIHtQb2ludH0gUmVzdWx0aW5nIHBvaW50LlxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoUG9pbnQsIFt7XG4gICAgICAgIGtleTogJ2FkZCcsXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGEgdmVjdG9yIHRvIGEgcG9pbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGUgdGhhdCBhZGRpdGlvbiBvZiB0d28gcG9pbnRzIGlzIHVuZGVmaW5lZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3J9IHZlY3RvciBWZWN0b3IgdG8gYWRkIHRvIHRoaXMgcG9pbnQuXG4gICAgICAgICAqIEByZXR1cm4ge1BvaW50fSBQb2ludCB3aXRoIHRoZSB2ZWN0b3IgYWRkZWQgdG8gaXQuXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKHZlY3Rvcikge1xuICAgICAgICAgICAgaWYgKHZlY3RvciBpbnN0YW5jZW9mIFBvaW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBZGRpdGlvbiBvZiB0d28gcG9pbnRzIGlzIHVuZGVmaW5lZC4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLl94ICsgdmVjdG9yLl94LCB0aGlzLl95ICsgdmVjdG9yLl95KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdWJ0cmFjdCBhIFBvaW50IG9yIGEgVmVjdG9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1BvaW50fFZlY3Rvcn0gdGhhdCBQb2ludCBvciB2ZWN0b3IgdG8gc3VidHJhY3QuXG4gICAgICAgICAqIEByZXR1cm4ge1BvaW50fSBJZiBgdGhhdGAgaXMgYSBWZWN0b3IsIGl0IHdpbGwgcmV0dXJuIHRoZSBuZXcgcG9pbnQuXG4gICAgICAgICAqIEByZXR1cm4ge1ZlY3Rvcn0gSWYgYHRoYXRgIGlzIGEgUG9pbnQsIGl0IHdpbGwgcmV0dXJuIHRoZSBkaXNwbGFjZW1lbnQuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzdWJ0cmFjdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdWJ0cmFjdCh0aGF0KSB7XG4gICAgICAgICAgICBpZiAodGhhdCBpbnN0YW5jZW9mIFBvaW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9WZWN0b3IoKS5zdWJ0cmFjdCh0aGF0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLl94IC0gdGhhdC5feCwgdGhpcy5feSAtIHRoYXQuX3kpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludmVydCB0aGUgeCBhbmQgeSBjb29yZGluYXRlLCByZWxhdGl2ZSB0byAoMCwgMCkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1BvaW50fSBJbnZlcnRlZCBwb2ludC5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2ludmVydCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbnZlcnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KC10aGlzLl94LCAtdGhpcy5feSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7UG9pbnR9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdtdWx0aXBseScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtdWx0aXBseShzY2FsYXIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy5feCAqIHNjYWxhciwgdGhpcy5feSAqIHNjYWxhcik7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7UG9pbnR9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdtdWx0aXBseVhZJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG11bHRpcGx5WFkoc2NhbGFyWCwgc2NhbGFyWSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLl94ICogc2NhbGFyWCwgdGhpcy5feSAqIHNjYWxhclkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge1BvaW50fVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZGl2aWRlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpdmlkZShzY2FsYXIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy5feCAvIHNjYWxhciwgdGhpcy5feSAvIHNjYWxhcik7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7UG9pbnR9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdkaXZpZGVYWScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXZpZGVYWShzY2FsYXJYLCBzY2FsYXJZKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMuX3ggLyBzY2FsYXJYLCB0aGlzLl95IC8gc2NhbGFyWSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7UG9pbnR9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdtaXgnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbWl4KHRoYXQpIHtcbiAgICAgICAgICAgIHZhciBhbW91bnQgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyAwLjUgOiBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5KDEgLSBhbW91bnQpLmFkZCh0aGF0Lm11bHRpcGx5KGFtb3VudCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge1BvaW50fVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncGVycGVuZGljdWxhcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwZXJwZW5kaWN1bGFyKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCgtdGhpcy5feSwgdGhpcy5feCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7UG9pbnR9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzbmFwJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNuYXAodG8pIHtcbiAgICAgICAgICAgIHZhciByb3VuZCA9IGZ1bmN0aW9uIHJvdW5kKHZhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbCAvIHRvKSAqIHRvO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChyb3VuZCh0aGlzLl94KSwgcm91bmQodGhpcy5feSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2RvdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkb3QodGhhdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ggKiB0aGF0Ll94ICsgdGhpcy5feSAqIHRoYXQuX3k7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYW5nbGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYW5nbGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hdGFuMih0aGlzLl95LCB0aGlzLl94KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdhbmdsZURlZycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhbmdsZURlZygpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmF0YW4yKHRoaXMuX3ksIHRoaXMuX3gpICogMTgwIC8gTWF0aC5QSTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzbG9wZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzbG9wZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl95IC8gdGhpcy5feDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxjdWxhdGUgdGhlIHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGUgZXhhY3QgZGlzdGFuY2UgZG9lc24ndCBtYXR0ZXIsIHRoaXMgbWV0aG9kIGlzIHNsaWdodGx5IGZhc3RlclxuICAgICAgICAgKiB0aGFuIGB0aGlzLmRpc3RhbmNlYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnQgVGhlIG90aGVyIHBvaW50LlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBkaXN0YW5jZSBiZXR3ZWVuIGJvdGggcG9pbnRzLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZGlzdGFuY2VTcScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVNxKHBvaW50KSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGlmICghKHBvaW50IGluc3RhbmNlb2YgUG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBiZSBhIHBvaW50LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRYID0gdGhpcy5feCAtIHBvaW50Ll94O1xuICAgICAgICAgICAgdmFyIGRZID0gdGhpcy5feSAtIHBvaW50Ll95O1xuXG4gICAgICAgICAgICByZXR1cm4gZFggKiBkWCArIGRZICogZFk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IFRoZSBvdGhlciBwb2ludC5cbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgZGlzdGFuY2UgYmV0d2VlbiBib3RoIHBvaW50cy5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Rpc3RhbmNlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlKHBvaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZGlzdGFuY2VTcShwb2ludCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnQgcG9pbnQgaW50byBhIHZlY3Rvci5cbiAgICAgICAgICpcbiAgICAgICAgICogTm90ZTogdGhpcyBpcyBhbiB1dGlsaXR5IG1ldGhvZC4gQSBwcm9wZXIgY29udmVyc2lvbiBkb2VzIG5vdCBleGlzdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7VmVjdG9yfSBUaGUgcG9pbnQgY29udmVydGVkIGFzIHZlY3Rvci5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvVmVjdG9yJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvVmVjdG9yKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBfVmVjdG9yMi5kZWZhdWx0KHRoaXMuX3gsIHRoaXMuX3kpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnQgdGhpcyBwb2ludCBpbnRvIGFuIGFycmF5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgcmVwcmVzZW50YXRpb24gKHgsIHkpLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9BcnJheScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0FycmF5KCkge1xuICAgICAgICAgICAgcmV0dXJuIFt0aGlzLl94LCB0aGlzLl95XTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0IHRoaXMgcG9pbnQgaW50byBhbiBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uICh4LCB5KS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvT2JqZWN0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvT2JqZWN0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogdGhpcy5feCwgeTogdGhpcy5feSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnQgdGhpcyBwb2ludCBpbnRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbiAoeCwgeSkuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiAnKCcgKyB0aGlzLl94ICsgJywgJyArIHRoaXMuX3kgKyAnKSc7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydCB0aGlzIHBvaW50IGludG8gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24sIHVzaW5nIGEgZml4ZWQgbnVtYmVyIG9mXG4gICAgICAgICAqIGRpZ2l0cyBmb3IgZGlzcGxheWluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGRpZ2l0cyBOdW1iZXIgb2YgZGlnaXRzIHRvIHVzZSBmb3IgcmVwcmVzZW50YXRpb24uXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gU3RyaW5nIHJlcHJlc2VudGF0aW9uICh4LCB5KS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvRml4ZWQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9GaXhlZChkaWdpdHMpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkaWdpdHMgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTnVtYmVyIG9mIGRpZ2l0cyBtdXN0IGJlIGEgbnVtYmVyLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICcoJyArIHRoaXMuX3gudG9GaXhlZChkaWdpdHMpICsgJywgJyArIHRoaXMuX3kudG9GaXhlZChkaWdpdHMpICsgJyknO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIHNoYWxsb3cgY29weSBvZiB0aGlzIGluc3RhbmNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtQb2ludH0gQ2xvbmVkIGluc3RhbmNlLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2xvbmUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMuX3gsIHRoaXMuX3kpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybiB0cnVlIGlmIHRoaXMgcG9pbnQgaXMgZXF1YWwgdG8gYW5vdGhlciBwb2ludC4gVHdvIHBvaW50cyBhcmVcbiAgICAgICAgICogZXF1YWwgd2hlbiBib3RoIHggYW5kIHkgY29vcmRpbmF0ZXMgYXJlIGVxdWFsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gdGhhdCBPdGhlciBpbnN0YW5jZSB0byBjb21wYXJlIHRvLlxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGJvdGggcG9pbnRzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZXF1YWxzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVxdWFscyh0aGF0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lID09PSB0aGF0LmNvbnN0cnVjdG9yLm5hbWUgJiYgdGhpcy5feCA9PT0gdGhhdC5feCAmJiB0aGlzLl95ID09PSB0aGF0Ll95O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSBwb2ludCBpcyBkZWZpbmVkIGFuZCBmaW5pdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgcG9pbnQgaXMgZnVsbHkgZGVmaW5lZCBhbmQgdmFsaWQuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdpc1ZhbGlkJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzVmFsaWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMuX3ggPT09ICdudW1iZXInICYmIGlzRmluaXRlKHRoaXMuX3gpICYmIHR5cGVvZiB0aGlzLl95ID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh0aGlzLl95KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAneCcsXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSB4IGNvb3JkaW5hdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHggY29vcmRpbmF0ZS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3g7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSB5IGNvb3JkaW5hdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHkgY29vcmRpbmF0ZS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3knLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl95O1xuICAgICAgICB9XG4gICAgfV0sIFt7XG4gICAgICAgIGtleTogJ2Zyb21BcnJheScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tQXJyYXkoYXJyYXkpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSB8fCBhcnJheS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYW4gYXJyYXkgd2l0aCBhdCBsZWFzdCB0d28gdmFsdWVzLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChhcnJheVswXSwgYXJyYXlbMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyBwb2ludCBmcm9tIGFuIG9iamVjdC4gVGhlIG9iamVjdCBzaG91bGQgaGF2ZSBhbiB4IGFuZCB5XG4gICAgICAgICAqIHByb3BlcnR5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0IElucHV0IG9iamVjdCB3aXRoIHggYW5kIHkgcHJvcGVydHkuXG4gICAgICAgICAqIEByZXR1cm4ge1BvaW50fSBSZXN1bHRpbmcgcG9pbnQuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmcm9tT2JqZWN0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIG9iamVjdCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yob2JqZWN0KSkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYW4gb2JqZWN0LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChvYmplY3QueCwgb2JqZWN0LnkpO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFBvaW50O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBQb2ludDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL1BvaW50LmpzXG4gKiogbW9kdWxlIGlkID0gMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 3 */
/***/ function(module, exports) {

	eval("// shim for using process in browser\n\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\n(function () {\n  try {\n    cachedSetTimeout = setTimeout;\n  } catch (e) {\n    cachedSetTimeout = function () {\n      throw new Error('setTimeout is not defined');\n    }\n  }\n  try {\n    cachedClearTimeout = clearTimeout;\n  } catch (e) {\n    cachedClearTimeout = function () {\n      throw new Error('clearTimeout is not defined');\n    }\n  }\n} ())\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = cachedSetTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    cachedClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        cachedSetTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vcHJvY2Vzcy9icm93c2VyLmpzPzgyZTQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNhY2hlZFNldFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaXMgbm90IGRlZmluZWQnKTtcbiAgICB9XG4gIH1cbiAgdHJ5IHtcbiAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBpcyBub3QgZGVmaW5lZCcpO1xuICAgIH1cbiAgfVxufSAoKSlcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IGNhY2hlZFNldFRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGNhY2hlZENsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9wcm9jZXNzL2Jyb3dzZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Point = __webpack_require__(2);\n\nvar _Point2 = _interopRequireDefault(_Point);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Immutable vector class.\n *\n * A vector represents a displacement, using a x an y component to represent\n * the length (magnitude) and direction.\n *\n * The difference between a Vector and a Point is explained in this source:\n * http://math.stackexchange.com/a/645827\n */\n\nvar Vector = function () {\n\n    /**\n     * Construct a new vector, using a x and y component to represent the\n     * length (magnitude) and direction relative to (0, 0).\n     *\n     * An vector is immutable. All subsequent operations will return a new\n     * vector instance.\n     *\n     * @param {number} x The x component.\n     * @param {number} y The y component.\n     * @return {void}\n     */\n\n    function Vector(x, y) {\n        _classCallCheck(this, Vector);\n\n        this._x = x;\n        this._y = y;\n    }\n\n    /**\n     * Create a new vector from an array. The first index is considered the x\n     * component, the second index is considered the y component.\n     *\n     * @param {Array} array Input array with at least two values.\n     * @return {Vector} Resulting vector.\n     */\n\n    /**\n     * Definition of the unit vector.\n     */\n\n\n    _createClass(Vector, [{\n        key: 'add',\n\n\n        /**\n         * Add another vector or point to this vector.\n         *\n         * If the input is a point, the result will be a point with this vector\n         * as offset.\n         *\n         * @param {Point|Vector} that Point or vector to add.\n         * @return {Point|Vector} New Vector if adding vector, point otherwise.\n         */\n        value: function add(that) {\n            if (that instanceof _Point2.default) {\n                return that.add(this);\n            }\n\n            return new Vector(this._x + that._x, this._y + that._y);\n        }\n\n        /**\n         * Subtract a given scalar from the `x` and `y` component of this vector.\n         *\n         * @param {number} that Scalar value to subtract.\n         * @return {Vector}\n         */\n\n    }, {\n        key: 'subtract',\n        value: function subtract(that) {\n            return new Vector(this._x - that._x, this._y - that._y);\n        }\n\n        /**\n         * Invert a vector, returning a copy with inverted magnitude and direction.\n         *\n         * @return {Vector}\n         */\n\n    }, {\n        key: 'invert',\n        value: function invert() {\n            return new Vector(-this._x, -this._y);\n        }\n\n        /**\n         * @return {Vector}\n         */\n\n    }, {\n        key: 'multiply',\n        value: function multiply(scalar) {\n            return new Vector(this._x * scalar, this._y * scalar);\n        }\n\n        /**\n         * @return {Vector}\n         */\n\n    }, {\n        key: 'multiplyXY',\n        value: function multiplyXY(scalarX, scalarY) {\n            return new Vector(this._x * scalarX, this._y * scalarY);\n        }\n\n        /**\n         * @return {Vector}\n         */\n\n    }, {\n        key: 'divide',\n        value: function divide(scalar) {\n            return new Vector(this._x / scalar, this._y / scalar);\n        }\n\n        /**\n         * @return {Vector}\n         */\n\n    }, {\n        key: 'divideXY',\n        value: function divideXY(scalarX, scalarY) {\n            return new Vector(this._x / scalarX, this._y / scalarY);\n        }\n\n        /**\n         * @return {Vector}\n         */\n\n    }, {\n        key: 'mix',\n        value: function mix(that) {\n            var amount = arguments.length <= 1 || arguments[1] === undefined ? 0.5 : arguments[1];\n\n            return this.multiply(1 - amount).add(that.multiply(amount));\n        }\n\n        /**\n         * @return {Vector}\n         */\n\n    }, {\n        key: 'perpendicular',\n        value: function perpendicular() {\n            return new Vector(-this._y, this._x);\n        }\n\n        /**\n         * @return {Vector}\n         */\n\n    }, {\n        key: 'snap',\n        value: function snap(to) {\n            var round = function round(val) {\n                return Math.round(val / to) * to;\n            };\n\n            return new Vector(round(this._x), round(this._y));\n        }\n\n        /**\n         * @return {number}\n         */\n\n    }, {\n        key: 'dot',\n        value: function dot(that) {\n            return this._x * that._x + this._y * that._y;\n        }\n\n        /**\n         * @return {number}\n         */\n\n    }, {\n        key: 'angle',\n        value: function angle() {\n            return Math.atan2(this._y, this._x);\n        }\n\n        /**\n         * @return {number}\n         */\n\n    }, {\n        key: 'angleDeg',\n        value: function angleDeg() {\n            return Math.atan2(this._y, this._x) * 180 / Math.PI;\n        }\n\n        /**\n         * @return {number}\n         */\n\n    }, {\n        key: 'slope',\n        value: function slope() {\n            return this._y / this._x;\n        }\n\n        /**\n         * Calculate the squared length of this vector.\n         *\n         * If the exact length doesn't matter, this method is slightly faster\n         * than `this.length`.\n         *\n         * @return {number} The squared length of this vector.\n         */\n\n    }, {\n        key: 'lengthSq',\n        value: function lengthSq() {\n            return this._x * this._x + this._y * this._y;\n        }\n\n        /**\n         * Calculate the length (magnitude) of the vector.\n         *\n         * @return {number} The length of the vector.\n         */\n\n    }, {\n        key: 'length',\n        value: function length() {\n            return Math.sqrt(this.lengthSq());\n        }\n\n        /**\n         * [minLength description]\n         * @param {[type]} length [description]\n         * @return {[type]}\n         */\n\n    }, {\n        key: 'minLength',\n        value: function minLength(length) {\n            return this.length() < length ? this.normalize(length) : this;\n        }\n    }, {\n        key: 'maxLength',\n        value: function maxLength(length) {\n            return this.length() > length ? this.normalize(length) : this;\n        }\n    }, {\n        key: 'normalize',\n        value: function normalize() {\n            var scalar = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];\n\n            return this.divide(this.length()).multiply(scalar);\n        }\n    }, {\n        key: 'projectOnto',\n        value: function projectOnto(that) {\n            return that.multiply(this.dot(that) / that.lengthSq());\n        }\n\n        /**\n         * Convert vector into a point.\n         *\n         * Note: this is an utility method. A proper conversion does not exist.\n         *\n         * @return {Point} The vector converted as point.\n         */\n\n    }, {\n        key: 'toPoint',\n        value: function toPoint() {\n            return new _Point2.default(this._x, this._y);\n        }\n\n        /**\n         * Convert this vector into an array.\n         *\n         * @return {Array} Array representation (x, y).\n         */\n\n    }, {\n        key: 'toArray',\n        value: function toArray() {\n            return [this._x, this._y];\n        }\n\n        /**\n         * Convert this vector into an object.\n         *\n         * @return {object} Object representation (x, y).\n         */\n\n    }, {\n        key: 'toObject',\n        value: function toObject() {\n            return { x: this._x, y: this._y };\n        }\n\n        /**\n         * Convert this vector into a string representation.\n         *\n         * @return {string} String representation (x, y).\n         */\n\n    }, {\n        key: 'toString',\n        value: function toString() {\n            return '(' + this._x + ', ' + this._y + ')';\n        }\n\n        /**\n         * Convert this vector into a string representation, using a fixed number\n         * of digits for displaying.\n         *\n         * @param {number} digits Number of digits to use for representation.\n         * @return {string} String representation (x, y).\n         */\n\n    }, {\n        key: 'toFixed',\n        value: function toFixed(digits) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (typeof digits !== 'number') {\n                    throw new Error('Number of digits must be a number.');\n                }\n            }\n\n            return '(' + this._x.toFixed(digits) + ', ' + this._y.toFixed(digits) + ')';\n        }\n\n        /**\n         * Create a shallow copy of this instance.\n         *\n         * @return {Vector} Cloned instance.\n         */\n\n    }, {\n        key: 'clone',\n        value: function clone() {\n            return new Vector(this._x, this._y);\n        }\n\n        /**\n         * Return true if this vector is equal to another vector. Two vectors are\n         * equal when both x and y components are equal.\n         *\n         * @param {object} that Other instance to compare to.\n         * @return {boolean} True if both points are equal, false otherwise.\n         */\n\n    }, {\n        key: 'equals',\n        value: function equals(that) {\n            return this.constructor.name === that.constructor.name && this._x === that._x && this._y === that._y;\n        }\n\n        /**\n         * Return true if the vector is defined and finite.\n         *\n         * @return {Boolean} True if vector is fully defined and valid.\n         */\n\n    }, {\n        key: 'isValid',\n        value: function isValid() {\n            return typeof this._x === 'number' && isFinite(this._x) && typeof this._y === 'number' && isFinite(this._y);\n        }\n    }, {\n        key: 'x',\n\n\n        /**\n         * Get the x component.\n         *\n         * @return {number} The x component.\n         */\n        get: function get() {\n            return this._x;\n        }\n\n        /**\n         * Get the y component.\n         *\n         * @return {number} The y component.\n         */\n\n    }, {\n        key: 'y',\n        get: function get() {\n            return this._y;\n        }\n    }], [{\n        key: 'fromArray',\n        value: function fromArray(array) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (!Array.isArray(array) || array.length < 2) {\n                    throw new Error('Expected an array with at least two values.');\n                }\n            }\n\n            return new Vector(array[0], array[1]);\n        }\n\n        /**\n         * Create a new vector from an object. The object should have an x and y\n         * property.\n         *\n         * @param {object} object Input object with x and y property.\n         * @return {Vector} Resulting vector.\n         */\n\n    }, {\n        key: 'fromObject',\n        value: function fromObject(object) {\n            if (process.env.NODE_ENV !== 'production') {\n                if ((typeof object === 'undefined' ? 'undefined' : _typeof(object)) !== 'object') {\n                    throw new Error('Expected an object.');\n                }\n            }\n\n            return new Vector(object.x, object.y);\n        }\n\n        /**\n         * Create a new vector form a single value. In that case, both the x and y\n         * property will have the same value.\n         *\n         * @param {number} number Input number for x and y property.\n         * @return {Vector} Resulting vector.\n         */\n\n    }, {\n        key: 'fromNumber',\n        value: function fromNumber(number) {\n            return new Vector(number, number);\n        }\n    }]);\n\n    return Vector;\n}();\n\nVector.Unit = new Vector(1, 1);\nexports.default = Vector;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9WZWN0b3IuanM/MGIxZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfUG9pbnQgPSByZXF1aXJlKCcuL1BvaW50Jyk7XG5cbnZhciBfUG9pbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUG9pbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIEltbXV0YWJsZSB2ZWN0b3IgY2xhc3MuXG4gKlxuICogQSB2ZWN0b3IgcmVwcmVzZW50cyBhIGRpc3BsYWNlbWVudCwgdXNpbmcgYSB4IGFuIHkgY29tcG9uZW50IHRvIHJlcHJlc2VudFxuICogdGhlIGxlbmd0aCAobWFnbml0dWRlKSBhbmQgZGlyZWN0aW9uLlxuICpcbiAqIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gYSBWZWN0b3IgYW5kIGEgUG9pbnQgaXMgZXhwbGFpbmVkIGluIHRoaXMgc291cmNlOlxuICogaHR0cDovL21hdGguc3RhY2tleGNoYW5nZS5jb20vYS82NDU4MjdcbiAqL1xuXG52YXIgVmVjdG9yID0gZnVuY3Rpb24gKCkge1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IHZlY3RvciwgdXNpbmcgYSB4IGFuZCB5IGNvbXBvbmVudCB0byByZXByZXNlbnQgdGhlXG4gICAgICogbGVuZ3RoIChtYWduaXR1ZGUpIGFuZCBkaXJlY3Rpb24gcmVsYXRpdmUgdG8gKDAsIDApLlxuICAgICAqXG4gICAgICogQW4gdmVjdG9yIGlzIGltbXV0YWJsZS4gQWxsIHN1YnNlcXVlbnQgb3BlcmF0aW9ucyB3aWxsIHJldHVybiBhIG5ld1xuICAgICAqIHZlY3RvciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IFRoZSB4IGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBUaGUgeSBjb21wb25lbnQuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFZlY3Rvcih4LCB5KSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBWZWN0b3IpO1xuXG4gICAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgICB0aGlzLl95ID0geTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgdmVjdG9yIGZyb20gYW4gYXJyYXkuIFRoZSBmaXJzdCBpbmRleCBpcyBjb25zaWRlcmVkIHRoZSB4XG4gICAgICogY29tcG9uZW50LCB0aGUgc2Vjb25kIGluZGV4IGlzIGNvbnNpZGVyZWQgdGhlIHkgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgSW5wdXQgYXJyYXkgd2l0aCBhdCBsZWFzdCB0d28gdmFsdWVzLlxuICAgICAqIEByZXR1cm4ge1ZlY3Rvcn0gUmVzdWx0aW5nIHZlY3Rvci5cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIERlZmluaXRpb24gb2YgdGhlIHVuaXQgdmVjdG9yLlxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoVmVjdG9yLCBbe1xuICAgICAgICBrZXk6ICdhZGQnLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBhbm90aGVyIHZlY3RvciBvciBwb2ludCB0byB0aGlzIHZlY3Rvci5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgdGhlIGlucHV0IGlzIGEgcG9pbnQsIHRoZSByZXN1bHQgd2lsbCBiZSBhIHBvaW50IHdpdGggdGhpcyB2ZWN0b3JcbiAgICAgICAgICogYXMgb2Zmc2V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1BvaW50fFZlY3Rvcn0gdGhhdCBQb2ludCBvciB2ZWN0b3IgdG8gYWRkLlxuICAgICAgICAgKiBAcmV0dXJuIHtQb2ludHxWZWN0b3J9IE5ldyBWZWN0b3IgaWYgYWRkaW5nIHZlY3RvciwgcG9pbnQgb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZCh0aGF0KSB7XG4gICAgICAgICAgICBpZiAodGhhdCBpbnN0YW5jZW9mIF9Qb2ludDIuZGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LmFkZCh0aGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy5feCArIHRoYXQuX3gsIHRoaXMuX3kgKyB0aGF0Ll95KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdWJ0cmFjdCBhIGdpdmVuIHNjYWxhciBmcm9tIHRoZSBgeGAgYW5kIGB5YCBjb21wb25lbnQgb2YgdGhpcyB2ZWN0b3IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aGF0IFNjYWxhciB2YWx1ZSB0byBzdWJ0cmFjdC5cbiAgICAgICAgICogQHJldHVybiB7VmVjdG9yfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc3VidHJhY3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc3VidHJhY3QodGhhdCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy5feCAtIHRoYXQuX3gsIHRoaXMuX3kgLSB0aGF0Ll95KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnZlcnQgYSB2ZWN0b3IsIHJldHVybmluZyBhIGNvcHkgd2l0aCBpbnZlcnRlZCBtYWduaXR1ZGUgYW5kIGRpcmVjdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7VmVjdG9yfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaW52ZXJ0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGludmVydCgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKC10aGlzLl94LCAtdGhpcy5feSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7VmVjdG9yfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbXVsdGlwbHknLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbXVsdGlwbHkoc2NhbGFyKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLl94ICogc2NhbGFyLCB0aGlzLl95ICogc2NhbGFyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtWZWN0b3J9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdtdWx0aXBseVhZJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG11bHRpcGx5WFkoc2NhbGFyWCwgc2NhbGFyWSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy5feCAqIHNjYWxhclgsIHRoaXMuX3kgKiBzY2FsYXJZKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtWZWN0b3J9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdkaXZpZGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGl2aWRlKHNjYWxhcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy5feCAvIHNjYWxhciwgdGhpcy5feSAvIHNjYWxhcik7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7VmVjdG9yfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZGl2aWRlWFknLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGl2aWRlWFkoc2NhbGFyWCwgc2NhbGFyWSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy5feCAvIHNjYWxhclgsIHRoaXMuX3kgLyBzY2FsYXJZKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtWZWN0b3J9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdtaXgnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbWl4KHRoYXQpIHtcbiAgICAgICAgICAgIHZhciBhbW91bnQgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyAwLjUgOiBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5KDEgLSBhbW91bnQpLmFkZCh0aGF0Lm11bHRpcGx5KGFtb3VudCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge1ZlY3Rvcn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3BlcnBlbmRpY3VsYXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcGVycGVuZGljdWxhcigpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKC10aGlzLl95LCB0aGlzLl94KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtWZWN0b3J9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzbmFwJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNuYXAodG8pIHtcbiAgICAgICAgICAgIHZhciByb3VuZCA9IGZ1bmN0aW9uIHJvdW5kKHZhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbCAvIHRvKSAqIHRvO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3Iocm91bmQodGhpcy5feCksIHJvdW5kKHRoaXMuX3kpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdkb3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZG90KHRoYXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl94ICogdGhhdC5feCArIHRoaXMuX3kgKiB0aGF0Ll95O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2FuZ2xlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFuZ2xlKCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIodGhpcy5feSwgdGhpcy5feCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYW5nbGVEZWcnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYW5nbGVEZWcoKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hdGFuMih0aGlzLl95LCB0aGlzLl94KSAqIDE4MCAvIE1hdGguUEk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2xvcGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2xvcGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5feSAvIHRoaXMuX3g7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsY3VsYXRlIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiB0aGlzIHZlY3Rvci5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgdGhlIGV4YWN0IGxlbmd0aCBkb2Vzbid0IG1hdHRlciwgdGhpcyBtZXRob2QgaXMgc2xpZ2h0bHkgZmFzdGVyXG4gICAgICAgICAqIHRoYW4gYHRoaXMubGVuZ3RoYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgc3F1YXJlZCBsZW5ndGggb2YgdGhpcyB2ZWN0b3IuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdsZW5ndGhTcScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBsZW5ndGhTcSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl94ICogdGhpcy5feCArIHRoaXMuX3kgKiB0aGlzLl95O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGN1bGF0ZSB0aGUgbGVuZ3RoIChtYWduaXR1ZGUpIG9mIHRoZSB2ZWN0b3IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGxlbmd0aCBvZiB0aGUgdmVjdG9yLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbGVuZ3RoJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxlbmd0aCgpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5sZW5ndGhTcSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBbbWluTGVuZ3RoIGRlc2NyaXB0aW9uXVxuICAgICAgICAgKiBAcGFyYW0ge1t0eXBlXX0gbGVuZ3RoIFtkZXNjcmlwdGlvbl1cbiAgICAgICAgICogQHJldHVybiB7W3R5cGVdfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbWluTGVuZ3RoJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1pbkxlbmd0aChsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCgpIDwgbGVuZ3RoID8gdGhpcy5ub3JtYWxpemUobGVuZ3RoKSA6IHRoaXM7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ21heExlbmd0aCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtYXhMZW5ndGgobGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGgoKSA+IGxlbmd0aCA/IHRoaXMubm9ybWFsaXplKGxlbmd0aCkgOiB0aGlzO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdub3JtYWxpemUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbm9ybWFsaXplKCkge1xuICAgICAgICAgICAgdmFyIHNjYWxhciA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IDEgOiBhcmd1bWVudHNbMF07XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpdmlkZSh0aGlzLmxlbmd0aCgpKS5tdWx0aXBseShzY2FsYXIpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdwcm9qZWN0T250bycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9qZWN0T250byh0aGF0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhhdC5tdWx0aXBseSh0aGlzLmRvdCh0aGF0KSAvIHRoYXQubGVuZ3RoU3EoKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydCB2ZWN0b3IgaW50byBhIHBvaW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlOiB0aGlzIGlzIGFuIHV0aWxpdHkgbWV0aG9kLiBBIHByb3BlciBjb252ZXJzaW9uIGRvZXMgbm90IGV4aXN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtQb2ludH0gVGhlIHZlY3RvciBjb252ZXJ0ZWQgYXMgcG9pbnQuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b1BvaW50JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvUG9pbnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IF9Qb2ludDIuZGVmYXVsdCh0aGlzLl94LCB0aGlzLl95KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0IHRoaXMgdmVjdG9yIGludG8gYW4gYXJyYXkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5fSBBcnJheSByZXByZXNlbnRhdGlvbiAoeCwgeSkuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b0FycmF5JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvQXJyYXkoKSB7XG4gICAgICAgICAgICByZXR1cm4gW3RoaXMuX3gsIHRoaXMuX3ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnQgdGhpcyB2ZWN0b3IgaW50byBhbiBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uICh4LCB5KS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvT2JqZWN0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvT2JqZWN0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogdGhpcy5feCwgeTogdGhpcy5feSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnQgdGhpcyB2ZWN0b3IgaW50byBhIHN0cmluZyByZXByZXNlbnRhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gKHgsIHkpLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9TdHJpbmcnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gJygnICsgdGhpcy5feCArICcsICcgKyB0aGlzLl95ICsgJyknO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnQgdGhpcyB2ZWN0b3IgaW50byBhIHN0cmluZyByZXByZXNlbnRhdGlvbiwgdXNpbmcgYSBmaXhlZCBudW1iZXJcbiAgICAgICAgICogb2YgZGlnaXRzIGZvciBkaXNwbGF5aW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZGlnaXRzIE51bWJlciBvZiBkaWdpdHMgdG8gdXNlIGZvciByZXByZXNlbnRhdGlvbi5cbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gKHgsIHkpLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9GaXhlZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0ZpeGVkKGRpZ2l0cykge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRpZ2l0cyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOdW1iZXIgb2YgZGlnaXRzIG11c3QgYmUgYSBudW1iZXIuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gJygnICsgdGhpcy5feC50b0ZpeGVkKGRpZ2l0cykgKyAnLCAnICsgdGhpcy5feS50b0ZpeGVkKGRpZ2l0cykgKyAnKSc7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgc2hhbGxvdyBjb3B5IG9mIHRoaXMgaW5zdGFuY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1ZlY3Rvcn0gQ2xvbmVkIGluc3RhbmNlLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2xvbmUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLl94LCB0aGlzLl95KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGlzIHZlY3RvciBpcyBlcXVhbCB0byBhbm90aGVyIHZlY3Rvci4gVHdvIHZlY3RvcnMgYXJlXG4gICAgICAgICAqIGVxdWFsIHdoZW4gYm90aCB4IGFuZCB5IGNvbXBvbmVudHMgYXJlIGVxdWFsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gdGhhdCBPdGhlciBpbnN0YW5jZSB0byBjb21wYXJlIHRvLlxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGJvdGggcG9pbnRzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZXF1YWxzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVxdWFscyh0aGF0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lID09PSB0aGF0LmNvbnN0cnVjdG9yLm5hbWUgJiYgdGhpcy5feCA9PT0gdGhhdC5feCAmJiB0aGlzLl95ID09PSB0aGF0Ll95O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2ZWN0b3IgaXMgZGVmaW5lZCBhbmQgZmluaXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHZlY3RvciBpcyBmdWxseSBkZWZpbmVkIGFuZCB2YWxpZC5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2lzVmFsaWQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNWYWxpZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5feCA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodGhpcy5feCkgJiYgdHlwZW9mIHRoaXMuX3kgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHRoaXMuX3kpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd4JyxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHggY29tcG9uZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB4IGNvbXBvbmVudC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3g7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSB5IGNvbXBvbmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgeSBjb21wb25lbnQuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd5JyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5feTtcbiAgICAgICAgfVxuICAgIH1dLCBbe1xuICAgICAgICBrZXk6ICdmcm9tQXJyYXknLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUFycmF5KGFycmF5KSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheSkgfHwgYXJyYXkubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGFuIGFycmF5IHdpdGggYXQgbGVhc3QgdHdvIHZhbHVlcy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKGFycmF5WzBdLCBhcnJheVsxXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IHZlY3RvciBmcm9tIGFuIG9iamVjdC4gVGhlIG9iamVjdCBzaG91bGQgaGF2ZSBhbiB4IGFuZCB5XG4gICAgICAgICAqIHByb3BlcnR5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0IElucHV0IG9iamVjdCB3aXRoIHggYW5kIHkgcHJvcGVydHkuXG4gICAgICAgICAqIEByZXR1cm4ge1ZlY3Rvcn0gUmVzdWx0aW5nIHZlY3Rvci5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Zyb21PYmplY3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKCh0eXBlb2Ygb2JqZWN0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvYmplY3QpKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhbiBvYmplY3QuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvcihvYmplY3QueCwgb2JqZWN0LnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyB2ZWN0b3IgZm9ybSBhIHNpbmdsZSB2YWx1ZS4gSW4gdGhhdCBjYXNlLCBib3RoIHRoZSB4IGFuZCB5XG4gICAgICAgICAqIHByb3BlcnR5IHdpbGwgaGF2ZSB0aGUgc2FtZSB2YWx1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBJbnB1dCBudW1iZXIgZm9yIHggYW5kIHkgcHJvcGVydHkuXG4gICAgICAgICAqIEByZXR1cm4ge1ZlY3Rvcn0gUmVzdWx0aW5nIHZlY3Rvci5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Zyb21OdW1iZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbU51bWJlcihudW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKG51bWJlciwgbnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBWZWN0b3I7XG59KCk7XG5cblZlY3Rvci5Vbml0ID0gbmV3IFZlY3RvcigxLCAxKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFZlY3RvcjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL1ZlY3Rvci5qc1xuICoqIG1vZHVsZSBpZCA9IDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Point = __webpack_require__(2);\n\nvar _Point2 = _interopRequireDefault(_Point);\n\nvar _Vector = __webpack_require__(4);\n\nvar _Vector2 = _interopRequireDefault(_Vector);\n\nvar _Circle = __webpack_require__(1);\n\nvar _Circle2 = _interopRequireDefault(_Circle);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Immutable rectangle class.\n */\n\nvar Rectangle = function () {\n    /**\n     * Construct a new immutable rectangle of two points.\n     *\n     * @param {Point} a The `A` point..\n     * @param {Point} b The `B` point.\n     * @return {void}\n     */\n\n    function Rectangle(a, b) {\n        _classCallCheck(this, Rectangle);\n\n        this._a = a;\n        this._b = b;\n    }\n\n    /**\n     * Create a new rectangle from an array. The first index should be point\n     * `A` and the second index should be point `B`.\n     *\n     * @param {Array} array Input array with at least two values.\n     * @return {Rectangle} Resulting rectangle.\n     */\n\n\n    _createClass(Rectangle, [{\n        key: 'center',\n\n\n        /**\n         * Calculate the center point of this rectangle.\n         *\n         * @return {Point} Center of this rectangle.\n         */\n        value: function center() {\n            var x = (this._a._x + this._b._x) / 2;\n            var y = (this._a._y + this._b._y) / 2;\n\n            return new _Point2.default(x, y);\n        }\n\n        /**\n         * Calculate the center point offset.\n         *\n         * @return {Vector} Relative center point offset of this rectangle.\n         */\n\n    }, {\n        key: 'centerOffset',\n        value: function centerOffset() {\n            return this.center().subtract(this._a);\n        }\n\n        /**\n         * Merge two rectangles, taking the bouding box that contains both\n         * rectangles.\n         *\n         * @param {Rectangle} rectangle Other rectangle to merge with.\n         * @return {Rectangle} New rectangle containing both rectangles.\n         */\n\n    }, {\n        key: 'merge',\n        value: function merge(rectangle) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (!(rectangle instanceof Rectangle)) {\n                    throw new Error('Must merge with another rectangle.');\n                }\n            }\n\n            var a = new _Point2.default(Math.min(this._a._x, this._b._x, rectangle._a._x, rectangle._b._x), Math.min(this._a._y, this._b._y, rectangle._a._y, rectangle._b._y));\n            var b = new _Point2.default(Math.max(this._a._x, this._b._x, rectangle._a._x, rectangle._b._x), Math.max(this._a._y, this._b._y, rectangle._a._y, rectangle._b._y));\n\n            return new Rectangle(a, b);\n        }\n\n        /**\n         * Move the rectangle by applying an offset to the points `a` and `b`.\n         *\n         * @param {Vector} vector Offset vector.\n         * @return {Rectangle} Moved rectangle.\n         */\n\n    }, {\n        key: 'move',\n        value: function move(vector) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (!(vector instanceof _Vector2.default)) {\n                    throw new Error('Offset must be a vector.');\n                }\n            }\n\n            return new Rectangle(this._a.add(vector), this._b.add(vector));\n        }\n\n        /**\n         * Move the `a` point and `b` point of this rectangle individually.\n         *\n         * @param {Vector} vectorA Offset vector for `a` point.\n         * @param {Vector} vectorB Offset vector for `b` point.\n         * @return {Rectangle} Moved rectangle.\n         */\n\n    }, {\n        key: 'moveAB',\n        value: function moveAB(vectorA, vectorB) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (!(vectorA instanceof _Vector2.default) || !(vectorB instanceof _Vector2.default)) {\n                    throw new Error('Offset must be a vector.');\n                }\n            }\n\n            return new Rectangle(this._a.add(vectorA), this._b.add(vectorB));\n        }\n\n        /**\n         * Similar to move, but moves `a` and `b` in opposite directions by\n         * inverting the vector for `a`.\n         *\n         * This method may shrink the rectangle if the vector is negative, or if\n         * points `a` and `b` have been swapped. Normalize the\n         *\n         * @param {Vector} vector The offset vector to expand with.\n         * @return {Rectangle} Expanded rectangle.\n         */\n\n    }, {\n        key: 'expand',\n        value: function expand(vector) {\n            return this.moveAB(vector.invert(), vector);\n        }\n\n        /**\n         * Returns true if a given point is on this rectangle.\n         *\n         * @param {Point} point Point to test with.\n         * @return {boolean} True if point is within rectangle.\n         */\n\n    }, {\n        key: 'containsPoint',\n        value: function containsPoint(point) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (!(point instanceof _Point2.default)) {\n                    throw new Error('Must be a point.');\n                }\n            }\n\n            return (point._x >= this._a._x && point._x <= this._b._x || point._x >= this._b._x && point._x <= this._a._x) && (point._y >= this._a._y && point._y <= this._b._y || point._y >= this._b._y && point._y <= this._a._y);\n        }\n\n        /**\n         * Returns true if a given rectangle is within this rectangle. That is,\n         * both point `A` and `B` are within this rectangle.\n         *\n         * @param {Rectangle} rectangle The rectangle to check for.\n         * @return {booleam} True if the rectangle is within this rectangle.\n         */\n\n    }, {\n        key: 'containsRectangle',\n        value: function containsRectangle(rectangle) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (!(rectangle instanceof Rectangle)) {\n                    throw new Error('Must be a rectangle.');\n                }\n            }\n\n            return this.containsPoint(rectangle.a) && this.containsPoint(rectangle.b);\n        }\n\n        /**\n         * Returns true if a given rectangle collides with this rectangle.\n         *\n         * @param {Rectangle} rectangle Other rectangle to compare with.\n         * @return {boolean} True if the given rectangle collides with this one.\n         */\n\n    }, {\n        key: 'collidesRectangle',\n        value: function collidesRectangle(rectangle) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (!(rectangle instanceof Rectangle)) {\n                    throw new Error('Must be a rectangle.');\n                }\n            }\n\n            return this._a._x < rectangle._b._x && this._b._x > rectangle._a._x && this._a._y < rectangle._b._y && this._b._y > rectangle._a._y;\n        }\n\n        /**\n         * Returns true if a given circle collides with this rectangle.\n         *\n         * @param {Circle} circle Other circle to compare with.\n         * @return {boolean} True if the given circles collides with this one.\n         */\n\n    }, {\n        key: 'collidesCircle',\n        value: function collidesCircle(circle) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (!(circle instanceof _Circle2.default)) {\n                    throw new Error('Must be a circle.');\n                }\n            }\n\n            var clamp = function clamp(value, min, max) {\n                return Math.max(min, Math.min(max, value));\n            };\n\n            var closest = new _Point2.default(clamp(circle._a._x, this._a._x, this._b._x), clamp(circle._a._y, this._a._y, this._b._y));\n\n            return closest.distanceSq(circle._a) < circle._r * circle._r;\n        }\n\n        /**\n         * Calculate the area of the given rectangle.\n         *\n         * @return {number} The rectangle area.\n         */\n\n    }, {\n        key: 'area',\n        value: function area() {\n            return (this._b._x - this._a._x) * (this._b._y - this._a._y);\n        }\n\n        /**\n         * Return an array representation of this instance.\n         *\n         * @return {Array} Array representation ([a, b]).\n         */\n\n    }, {\n        key: 'toArray',\n        value: function toArray() {\n            return [this._a.toArray(), this._b.toArray()];\n        }\n\n        /**\n         * Return an object representation of this instance.\n         *\n         * @return {object} Object representation (a, b).\n         */\n\n    }, {\n        key: 'toObject',\n        value: function toObject() {\n            return {\n                a: this._a.toObject(),\n                b: this._b.toObject()\n            };\n        }\n\n        /**\n         * Return a string representation of this rectangle.\n         *\n         * @return {string} String representation.\n         */\n\n    }, {\n        key: 'toString',\n        value: function toString() {\n            return '(' + this._a.toString() + ', ' + this._b.toString() + ')';\n        }\n\n        /**\n         * Create a shallow copy of this instance.\n         *\n         * @return {Rectangle} Cloned instance.\n         */\n\n    }, {\n        key: 'clone',\n        value: function clone() {\n            return new Rectangle(this._a, this._b);\n        }\n\n        /**\n         * Return a normalize rectangle, with the `A` point in the top-left\n         * position and the `B` point in the bottom-right position.\n         *\n         * @return {Rectangle} The normalized rectangle.\n         */\n\n    }, {\n        key: 'normalize',\n        value: function normalize() {\n            return new Rectangle(new _Point2.default(this.left, this.top), new _Point2.default(this.right, this.bottom));\n        }\n\n        /**\n         * Return true if this rectangle is equal to another rectangle. Two\n         * rectangles are equal if and only if both points are equal. This means\n         * if two rectangles have the same left, right, top and bottom, they\n         * may not be equal, becaus they can be defined from different points.\n         *\n         * @param {object} that Other instance to compare to.\n         * @return {boolean} True if both rectangles are equal, false otherwise.\n         */\n\n    }, {\n        key: 'equals',\n        value: function equals(that) {\n            return this.constructor.name === that.constructor.name && this._a.equals(that._b) && this._b.equals(that._b);\n        }\n\n        /**\n         * Return true if the rectangle is defined and finite.\n         *\n         * @return {Boolean} True if rectangle is valid.\n         */\n\n    }, {\n        key: 'isValid',\n        value: function isValid() {\n            return this._a.isValid() && this._b.isValid();\n        }\n    }, {\n        key: 'a',\n\n\n        /**\n         * Return point `A`.\n         *\n         * @return {Point} Point `A`.\n         */\n        get: function get() {\n            return this._a;\n        }\n\n        /**\n         * Return point `B`.\n         *\n         * @return {Point} Point `B`.\n         */\n\n    }, {\n        key: 'b',\n        get: function get() {\n            return this._b;\n        }\n\n        /**\n         * Return the left x coordinate.\n         *\n         * @return {number} Left x coordinate.\n         */\n\n    }, {\n        key: 'left',\n        get: function get() {\n            //return Math.min(this._a._x, this._b._x);\n            return this._a._x;\n        }\n\n        /**\n         * Return the right x coordinate.\n         *\n         * @return {number} Right x coordinate.\n         */\n\n    }, {\n        key: 'right',\n        get: function get() {\n            //return Math.max(this._a._x, this._b._x);\n            return this._b._x;\n        }\n\n        /**\n         * Return the top y coordinate.\n         *\n         * @return {number} Top y coordinate.\n         */\n\n    }, {\n        key: 'top',\n        get: function get() {\n            //return Math.min(this._a._y, this._b._y);\n            return this._a._y;\n        }\n\n        /**\n         * Return the bottom y coordinate.\n         *\n         * @return {number} Bottom y coordinate.\n         */\n\n    }, {\n        key: 'bottom',\n        get: function get() {\n            //return Math.max(this._a._y, this._b._y);\n            return this._b._y;\n        }\n\n        /**\n         * Return the width of this rectangle, which is the difference between\n         * `this.right` and `this.left`.\n         *\n         * @return {number} Width of the rectangle.\n         */\n\n    }, {\n        key: 'width',\n        get: function get() {\n            return this.right - this.left;\n        }\n\n        /**\n         * Return the height of this rectangle, which is the difference between\n         * `this.bottom` and `this.top`.\n         *\n         * @return {number} Height of the rectangle.\n         */\n\n    }, {\n        key: 'height',\n        get: function get() {\n            return this.bottom - this.top;\n        }\n    }], [{\n        key: 'fromArray',\n        value: function fromArray(array) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (!Array.isArray(array) || array.length < 2) {\n                    throw new Error('Expected an array with at least two values.');\n                }\n            }\n\n            return new Rectangle(_Point2.default.fromArray(array[0]), _Point2.default.fromArray(array[1]));\n        }\n\n        /**\n         * Create a new rectangle from an object. The object should have an `a` and\n         * `b` property.\n         *\n         * @param {object} object Input object with `a` and `b` property.\n         * @return {Rectangle} Resulting rectangle.\n         */\n\n    }, {\n        key: 'fromObject',\n        value: function fromObject(object) {\n            if (process.env.NODE_ENV !== 'production') {\n                if ((typeof object === 'undefined' ? 'undefined' : _typeof(object)) !== 'object') {\n                    throw new Error('Expected an object.');\n                }\n            }\n\n            return new Rectangle(_Point2.default.fromObject(object.a), _Point2.default.fromObject(object.b));\n        }\n\n        /**\n         * Create a new rectangle from a (client) bounding rect from an element.\n         * However, it accepts any object with a `left`, `top, `width` and `height`\n         * property.\n         *\n         * @param {object} boundingRect Input bounding rectangle.\n         * @return {Rectangle}\n         */\n\n    }, {\n        key: 'fromBoundingRect',\n        value: function fromBoundingRect(boundingRect) {\n            return new Rectangle(new _Point2.default(boundingRect.left, boundingRect.top), new _Point2.default(boundingRect.left + boundingRect.width, boundingRect.top + boundingRect.height));\n        }\n    }]);\n\n    return Rectangle;\n}();\n\nexports.default = Rectangle;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9SZWN0YW5nbGUuanM/NmMzOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfUG9pbnQgPSByZXF1aXJlKCcuL1BvaW50Jyk7XG5cbnZhciBfUG9pbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUG9pbnQpO1xuXG52YXIgX1ZlY3RvciA9IHJlcXVpcmUoJy4vVmVjdG9yJyk7XG5cbnZhciBfVmVjdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1ZlY3Rvcik7XG5cbnZhciBfQ2lyY2xlID0gcmVxdWlyZSgnLi9DaXJjbGUnKTtcblxudmFyIF9DaXJjbGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2lyY2xlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBJbW11dGFibGUgcmVjdGFuZ2xlIGNsYXNzLlxuICovXG5cbnZhciBSZWN0YW5nbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IGltbXV0YWJsZSByZWN0YW5nbGUgb2YgdHdvIHBvaW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IGEgVGhlIGBBYCBwb2ludC4uXG4gICAgICogQHBhcmFtIHtQb2ludH0gYiBUaGUgYEJgIHBvaW50LlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBSZWN0YW5nbGUoYSwgYikge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVjdGFuZ2xlKTtcblxuICAgICAgICB0aGlzLl9hID0gYTtcbiAgICAgICAgdGhpcy5fYiA9IGI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHJlY3RhbmdsZSBmcm9tIGFuIGFycmF5LiBUaGUgZmlyc3QgaW5kZXggc2hvdWxkIGJlIHBvaW50XG4gICAgICogYEFgIGFuZCB0aGUgc2Vjb25kIGluZGV4IHNob3VsZCBiZSBwb2ludCBgQmAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBJbnB1dCBhcnJheSB3aXRoIGF0IGxlYXN0IHR3byB2YWx1ZXMuXG4gICAgICogQHJldHVybiB7UmVjdGFuZ2xlfSBSZXN1bHRpbmcgcmVjdGFuZ2xlLlxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoUmVjdGFuZ2xlLCBbe1xuICAgICAgICBrZXk6ICdjZW50ZXInLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGN1bGF0ZSB0aGUgY2VudGVyIHBvaW50IG9mIHRoaXMgcmVjdGFuZ2xlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtQb2ludH0gQ2VudGVyIG9mIHRoaXMgcmVjdGFuZ2xlLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNlbnRlcigpIHtcbiAgICAgICAgICAgIHZhciB4ID0gKHRoaXMuX2EuX3ggKyB0aGlzLl9iLl94KSAvIDI7XG4gICAgICAgICAgICB2YXIgeSA9ICh0aGlzLl9hLl95ICsgdGhpcy5fYi5feSkgLyAyO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IF9Qb2ludDIuZGVmYXVsdCh4LCB5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxjdWxhdGUgdGhlIGNlbnRlciBwb2ludCBvZmZzZXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1ZlY3Rvcn0gUmVsYXRpdmUgY2VudGVyIHBvaW50IG9mZnNldCBvZiB0aGlzIHJlY3RhbmdsZS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NlbnRlck9mZnNldCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjZW50ZXJPZmZzZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jZW50ZXIoKS5zdWJ0cmFjdCh0aGlzLl9hKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXJnZSB0d28gcmVjdGFuZ2xlcywgdGFraW5nIHRoZSBib3VkaW5nIGJveCB0aGF0IGNvbnRhaW5zIGJvdGhcbiAgICAgICAgICogcmVjdGFuZ2xlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtSZWN0YW5nbGV9IHJlY3RhbmdsZSBPdGhlciByZWN0YW5nbGUgdG8gbWVyZ2Ugd2l0aC5cbiAgICAgICAgICogQHJldHVybiB7UmVjdGFuZ2xlfSBOZXcgcmVjdGFuZ2xlIGNvbnRhaW5pbmcgYm90aCByZWN0YW5nbGVzLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbWVyZ2UnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbWVyZ2UocmVjdGFuZ2xlKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGlmICghKHJlY3RhbmdsZSBpbnN0YW5jZW9mIFJlY3RhbmdsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IG1lcmdlIHdpdGggYW5vdGhlciByZWN0YW5nbGUuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYSA9IG5ldyBfUG9pbnQyLmRlZmF1bHQoTWF0aC5taW4odGhpcy5fYS5feCwgdGhpcy5fYi5feCwgcmVjdGFuZ2xlLl9hLl94LCByZWN0YW5nbGUuX2IuX3gpLCBNYXRoLm1pbih0aGlzLl9hLl95LCB0aGlzLl9iLl95LCByZWN0YW5nbGUuX2EuX3ksIHJlY3RhbmdsZS5fYi5feSkpO1xuICAgICAgICAgICAgdmFyIGIgPSBuZXcgX1BvaW50Mi5kZWZhdWx0KE1hdGgubWF4KHRoaXMuX2EuX3gsIHRoaXMuX2IuX3gsIHJlY3RhbmdsZS5fYS5feCwgcmVjdGFuZ2xlLl9iLl94KSwgTWF0aC5tYXgodGhpcy5fYS5feSwgdGhpcy5fYi5feSwgcmVjdGFuZ2xlLl9hLl95LCByZWN0YW5nbGUuX2IuX3kpKTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUoYSwgYik7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogTW92ZSB0aGUgcmVjdGFuZ2xlIGJ5IGFwcGx5aW5nIGFuIG9mZnNldCB0byB0aGUgcG9pbnRzIGBhYCBhbmQgYGJgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3Rvcn0gdmVjdG9yIE9mZnNldCB2ZWN0b3IuXG4gICAgICAgICAqIEByZXR1cm4ge1JlY3RhbmdsZX0gTW92ZWQgcmVjdGFuZ2xlLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbW92ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlKHZlY3Rvcikge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpZiAoISh2ZWN0b3IgaW5zdGFuY2VvZiBfVmVjdG9yMi5kZWZhdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09mZnNldCBtdXN0IGJlIGEgdmVjdG9yLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUodGhpcy5fYS5hZGQodmVjdG9yKSwgdGhpcy5fYi5hZGQodmVjdG9yKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogTW92ZSB0aGUgYGFgIHBvaW50IGFuZCBgYmAgcG9pbnQgb2YgdGhpcyByZWN0YW5nbGUgaW5kaXZpZHVhbGx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3Rvcn0gdmVjdG9yQSBPZmZzZXQgdmVjdG9yIGZvciBgYWAgcG9pbnQuXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yfSB2ZWN0b3JCIE9mZnNldCB2ZWN0b3IgZm9yIGBiYCBwb2ludC5cbiAgICAgICAgICogQHJldHVybiB7UmVjdGFuZ2xlfSBNb3ZlZCByZWN0YW5nbGUuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdtb3ZlQUInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZUFCKHZlY3RvckEsIHZlY3RvckIpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEodmVjdG9yQSBpbnN0YW5jZW9mIF9WZWN0b3IyLmRlZmF1bHQpIHx8ICEodmVjdG9yQiBpbnN0YW5jZW9mIF9WZWN0b3IyLmRlZmF1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT2Zmc2V0IG11c3QgYmUgYSB2ZWN0b3IuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLl9hLmFkZCh2ZWN0b3JBKSwgdGhpcy5fYi5hZGQodmVjdG9yQikpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNpbWlsYXIgdG8gbW92ZSwgYnV0IG1vdmVzIGBhYCBhbmQgYGJgIGluIG9wcG9zaXRlIGRpcmVjdGlvbnMgYnlcbiAgICAgICAgICogaW52ZXJ0aW5nIHRoZSB2ZWN0b3IgZm9yIGBhYC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBtZXRob2QgbWF5IHNocmluayB0aGUgcmVjdGFuZ2xlIGlmIHRoZSB2ZWN0b3IgaXMgbmVnYXRpdmUsIG9yIGlmXG4gICAgICAgICAqIHBvaW50cyBgYWAgYW5kIGBiYCBoYXZlIGJlZW4gc3dhcHBlZC4gTm9ybWFsaXplIHRoZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3Rvcn0gdmVjdG9yIFRoZSBvZmZzZXQgdmVjdG9yIHRvIGV4cGFuZCB3aXRoLlxuICAgICAgICAgKiBAcmV0dXJuIHtSZWN0YW5nbGV9IEV4cGFuZGVkIHJlY3RhbmdsZS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2V4cGFuZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBleHBhbmQodmVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb3ZlQUIodmVjdG9yLmludmVydCgpLCB2ZWN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiBhIGdpdmVuIHBvaW50IGlzIG9uIHRoaXMgcmVjdGFuZ2xlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludCBQb2ludCB0byB0ZXN0IHdpdGguXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgcG9pbnQgaXMgd2l0aGluIHJlY3RhbmdsZS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NvbnRhaW5zUG9pbnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29udGFpbnNQb2ludChwb2ludCkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShwb2ludCBpbnN0YW5jZW9mIF9Qb2ludDIuZGVmYXVsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IGJlIGEgcG9pbnQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gKHBvaW50Ll94ID49IHRoaXMuX2EuX3ggJiYgcG9pbnQuX3ggPD0gdGhpcy5fYi5feCB8fCBwb2ludC5feCA+PSB0aGlzLl9iLl94ICYmIHBvaW50Ll94IDw9IHRoaXMuX2EuX3gpICYmIChwb2ludC5feSA+PSB0aGlzLl9hLl95ICYmIHBvaW50Ll95IDw9IHRoaXMuX2IuX3kgfHwgcG9pbnQuX3kgPj0gdGhpcy5fYi5feSAmJiBwb2ludC5feSA8PSB0aGlzLl9hLl95KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgYSBnaXZlbiByZWN0YW5nbGUgaXMgd2l0aGluIHRoaXMgcmVjdGFuZ2xlLiBUaGF0IGlzLFxuICAgICAgICAgKiBib3RoIHBvaW50IGBBYCBhbmQgYEJgIGFyZSB3aXRoaW4gdGhpcyByZWN0YW5nbGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0YW5nbGUgVGhlIHJlY3RhbmdsZSB0byBjaGVjayBmb3IuXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW19IFRydWUgaWYgdGhlIHJlY3RhbmdsZSBpcyB3aXRoaW4gdGhpcyByZWN0YW5nbGUuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjb250YWluc1JlY3RhbmdsZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb250YWluc1JlY3RhbmdsZShyZWN0YW5nbGUpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEocmVjdGFuZ2xlIGluc3RhbmNlb2YgUmVjdGFuZ2xlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgYmUgYSByZWN0YW5nbGUuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250YWluc1BvaW50KHJlY3RhbmdsZS5hKSAmJiB0aGlzLmNvbnRhaW5zUG9pbnQocmVjdGFuZ2xlLmIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiBhIGdpdmVuIHJlY3RhbmdsZSBjb2xsaWRlcyB3aXRoIHRoaXMgcmVjdGFuZ2xlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gcmVjdGFuZ2xlIE90aGVyIHJlY3RhbmdsZSB0byBjb21wYXJlIHdpdGguXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGdpdmVuIHJlY3RhbmdsZSBjb2xsaWRlcyB3aXRoIHRoaXMgb25lLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY29sbGlkZXNSZWN0YW5nbGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29sbGlkZXNSZWN0YW5nbGUocmVjdGFuZ2xlKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGlmICghKHJlY3RhbmdsZSBpbnN0YW5jZW9mIFJlY3RhbmdsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IGJlIGEgcmVjdGFuZ2xlLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2EuX3ggPCByZWN0YW5nbGUuX2IuX3ggJiYgdGhpcy5fYi5feCA+IHJlY3RhbmdsZS5fYS5feCAmJiB0aGlzLl9hLl95IDwgcmVjdGFuZ2xlLl9iLl95ICYmIHRoaXMuX2IuX3kgPiByZWN0YW5nbGUuX2EuX3k7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIGEgZ2l2ZW4gY2lyY2xlIGNvbGxpZGVzIHdpdGggdGhpcyByZWN0YW5nbGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7Q2lyY2xlfSBjaXJjbGUgT3RoZXIgY2lyY2xlIHRvIGNvbXBhcmUgd2l0aC5cbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZ2l2ZW4gY2lyY2xlcyBjb2xsaWRlcyB3aXRoIHRoaXMgb25lLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY29sbGlkZXNDaXJjbGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29sbGlkZXNDaXJjbGUoY2lyY2xlKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGlmICghKGNpcmNsZSBpbnN0YW5jZW9mIF9DaXJjbGUyLmRlZmF1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBiZSBhIGNpcmNsZS4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjbGFtcCA9IGZ1bmN0aW9uIGNsYW1wKHZhbHVlLCBtaW4sIG1heCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgdmFsdWUpKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBjbG9zZXN0ID0gbmV3IF9Qb2ludDIuZGVmYXVsdChjbGFtcChjaXJjbGUuX2EuX3gsIHRoaXMuX2EuX3gsIHRoaXMuX2IuX3gpLCBjbGFtcChjaXJjbGUuX2EuX3ksIHRoaXMuX2EuX3ksIHRoaXMuX2IuX3kpKTtcblxuICAgICAgICAgICAgcmV0dXJuIGNsb3Nlc3QuZGlzdGFuY2VTcShjaXJjbGUuX2EpIDwgY2lyY2xlLl9yICogY2lyY2xlLl9yO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGN1bGF0ZSB0aGUgYXJlYSBvZiB0aGUgZ2l2ZW4gcmVjdGFuZ2xlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSByZWN0YW5nbGUgYXJlYS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2FyZWEnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXJlYSgpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5fYi5feCAtIHRoaXMuX2EuX3gpICogKHRoaXMuX2IuX3kgLSB0aGlzLl9hLl95KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gYW4gYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBpbnN0YW5jZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IHJlcHJlc2VudGF0aW9uIChbYSwgYl0pLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9BcnJheScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0FycmF5KCkge1xuICAgICAgICAgICAgcmV0dXJuIFt0aGlzLl9hLnRvQXJyYXkoKSwgdGhpcy5fYi50b0FycmF5KCldO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybiBhbiBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBpbnN0YW5jZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gKGEsIGIpLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9PYmplY3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9PYmplY3QoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGE6IHRoaXMuX2EudG9PYmplY3QoKSxcbiAgICAgICAgICAgICAgICBiOiB0aGlzLl9iLnRvT2JqZWN0KClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcmVjdGFuZ2xlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbi5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuICcoJyArIHRoaXMuX2EudG9TdHJpbmcoKSArICcsICcgKyB0aGlzLl9iLnRvU3RyaW5nKCkgKyAnKSc7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgc2hhbGxvdyBjb3B5IG9mIHRoaXMgaW5zdGFuY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1JlY3RhbmdsZX0gQ2xvbmVkIGluc3RhbmNlLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2xvbmUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLl9hLCB0aGlzLl9iKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gYSBub3JtYWxpemUgcmVjdGFuZ2xlLCB3aXRoIHRoZSBgQWAgcG9pbnQgaW4gdGhlIHRvcC1sZWZ0XG4gICAgICAgICAqIHBvc2l0aW9uIGFuZCB0aGUgYEJgIHBvaW50IGluIHRoZSBib3R0b20tcmlnaHQgcG9zaXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1JlY3RhbmdsZX0gVGhlIG5vcm1hbGl6ZWQgcmVjdGFuZ2xlLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbm9ybWFsaXplJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG5vcm1hbGl6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKG5ldyBfUG9pbnQyLmRlZmF1bHQodGhpcy5sZWZ0LCB0aGlzLnRvcCksIG5ldyBfUG9pbnQyLmRlZmF1bHQodGhpcy5yaWdodCwgdGhpcy5ib3R0b20pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGlzIHJlY3RhbmdsZSBpcyBlcXVhbCB0byBhbm90aGVyIHJlY3RhbmdsZS4gVHdvXG4gICAgICAgICAqIHJlY3RhbmdsZXMgYXJlIGVxdWFsIGlmIGFuZCBvbmx5IGlmIGJvdGggcG9pbnRzIGFyZSBlcXVhbC4gVGhpcyBtZWFuc1xuICAgICAgICAgKiBpZiB0d28gcmVjdGFuZ2xlcyBoYXZlIHRoZSBzYW1lIGxlZnQsIHJpZ2h0LCB0b3AgYW5kIGJvdHRvbSwgdGhleVxuICAgICAgICAgKiBtYXkgbm90IGJlIGVxdWFsLCBiZWNhdXMgdGhleSBjYW4gYmUgZGVmaW5lZCBmcm9tIGRpZmZlcmVudCBwb2ludHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGF0IE90aGVyIGluc3RhbmNlIHRvIGNvbXBhcmUgdG8uXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYm90aCByZWN0YW5nbGVzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZXF1YWxzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVxdWFscyh0aGF0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lID09PSB0aGF0LmNvbnN0cnVjdG9yLm5hbWUgJiYgdGhpcy5fYS5lcXVhbHModGhhdC5fYikgJiYgdGhpcy5fYi5lcXVhbHModGhhdC5fYik7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHJlY3RhbmdsZSBpcyBkZWZpbmVkIGFuZCBmaW5pdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgcmVjdGFuZ2xlIGlzIHZhbGlkLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaXNWYWxpZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc1ZhbGlkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2EuaXNWYWxpZCgpICYmIHRoaXMuX2IuaXNWYWxpZCgpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdhJyxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gcG9pbnQgYEFgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtQb2ludH0gUG9pbnQgYEFgLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gcG9pbnQgYEJgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtQb2ludH0gUG9pbnQgYEJgLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYicsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2I7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIHRoZSBsZWZ0IHggY29vcmRpbmF0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfSBMZWZ0IHggY29vcmRpbmF0ZS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2xlZnQnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIC8vcmV0dXJuIE1hdGgubWluKHRoaXMuX2EuX3gsIHRoaXMuX2IuX3gpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2EuX3g7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIHRoZSByaWdodCB4IGNvb3JkaW5hdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn0gUmlnaHQgeCBjb29yZGluYXRlLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmlnaHQnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIC8vcmV0dXJuIE1hdGgubWF4KHRoaXMuX2EuX3gsIHRoaXMuX2IuX3gpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2IuX3g7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIHRoZSB0b3AgeSBjb29yZGluYXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRvcCB5IGNvb3JkaW5hdGUuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b3AnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIC8vcmV0dXJuIE1hdGgubWluKHRoaXMuX2EuX3ksIHRoaXMuX2IuX3kpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2EuX3k7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIHRoZSBib3R0b20geSBjb29yZGluYXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IEJvdHRvbSB5IGNvb3JkaW5hdGUuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdib3R0b20nLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIC8vcmV0dXJuIE1hdGgubWF4KHRoaXMuX2EuX3ksIHRoaXMuX2IuX3kpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2IuX3k7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIHRoZSB3aWR0aCBvZiB0aGlzIHJlY3RhbmdsZSwgd2hpY2ggaXMgdGhlIGRpZmZlcmVuY2UgYmV0d2VlblxuICAgICAgICAgKiBgdGhpcy5yaWdodGAgYW5kIGB0aGlzLmxlZnRgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFdpZHRoIG9mIHRoZSByZWN0YW5nbGUuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd3aWR0aCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmlnaHQgLSB0aGlzLmxlZnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIHRoZSBoZWlnaHQgb2YgdGhpcyByZWN0YW5nbGUsIHdoaWNoIGlzIHRoZSBkaWZmZXJlbmNlIGJldHdlZW5cbiAgICAgICAgICogYHRoaXMuYm90dG9tYCBhbmQgYHRoaXMudG9wYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfSBIZWlnaHQgb2YgdGhlIHJlY3RhbmdsZS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2hlaWdodCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm90dG9tIC0gdGhpcy50b3A7XG4gICAgICAgIH1cbiAgICB9XSwgW3tcbiAgICAgICAga2V5OiAnZnJvbUFycmF5JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21BcnJheShhcnJheSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpIHx8IGFycmF5Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhbiBhcnJheSB3aXRoIGF0IGxlYXN0IHR3byB2YWx1ZXMuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZShfUG9pbnQyLmRlZmF1bHQuZnJvbUFycmF5KGFycmF5WzBdKSwgX1BvaW50Mi5kZWZhdWx0LmZyb21BcnJheShhcnJheVsxXSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyByZWN0YW5nbGUgZnJvbSBhbiBvYmplY3QuIFRoZSBvYmplY3Qgc2hvdWxkIGhhdmUgYW4gYGFgIGFuZFxuICAgICAgICAgKiBgYmAgcHJvcGVydHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3QgSW5wdXQgb2JqZWN0IHdpdGggYGFgIGFuZCBgYmAgcHJvcGVydHkuXG4gICAgICAgICAqIEByZXR1cm4ge1JlY3RhbmdsZX0gUmVzdWx0aW5nIHJlY3RhbmdsZS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Zyb21PYmplY3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKCh0eXBlb2Ygb2JqZWN0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvYmplY3QpKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhbiBvYmplY3QuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZShfUG9pbnQyLmRlZmF1bHQuZnJvbU9iamVjdChvYmplY3QuYSksIF9Qb2ludDIuZGVmYXVsdC5mcm9tT2JqZWN0KG9iamVjdC5iKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IHJlY3RhbmdsZSBmcm9tIGEgKGNsaWVudCkgYm91bmRpbmcgcmVjdCBmcm9tIGFuIGVsZW1lbnQuXG4gICAgICAgICAqIEhvd2V2ZXIsIGl0IGFjY2VwdHMgYW55IG9iamVjdCB3aXRoIGEgYGxlZnRgLCBgdG9wLCBgd2lkdGhgIGFuZCBgaGVpZ2h0YFxuICAgICAgICAgKiBwcm9wZXJ0eS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGJvdW5kaW5nUmVjdCBJbnB1dCBib3VuZGluZyByZWN0YW5nbGUuXG4gICAgICAgICAqIEByZXR1cm4ge1JlY3RhbmdsZX1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Zyb21Cb3VuZGluZ1JlY3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUJvdW5kaW5nUmVjdChib3VuZGluZ1JlY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKG5ldyBfUG9pbnQyLmRlZmF1bHQoYm91bmRpbmdSZWN0LmxlZnQsIGJvdW5kaW5nUmVjdC50b3ApLCBuZXcgX1BvaW50Mi5kZWZhdWx0KGJvdW5kaW5nUmVjdC5sZWZ0ICsgYm91bmRpbmdSZWN0LndpZHRoLCBib3VuZGluZ1JlY3QudG9wICsgYm91bmRpbmdSZWN0LmhlaWdodCkpO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFJlY3RhbmdsZTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUmVjdGFuZ2xlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvUmVjdGFuZ2xlLmpzXG4gKiogbW9kdWxlIGlkID0gNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }
/******/ ]);