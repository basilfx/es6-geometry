/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/Circle.js":
/*!***********************!*\
  !*** ./src/Circle.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Point = __webpack_require__(/*! ./Point */ \"./src/Point.js\");\n\nvar _Point2 = _interopRequireDefault(_Point);\n\nvar _Rectangle = __webpack_require__(/*! ./Rectangle */ \"./src/Rectangle.js\");\n\nvar _Rectangle2 = _interopRequireDefault(_Rectangle);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Immutable circle class.\n */\n\n\n/**\n * Definition of an array representing a circle.\n */\n\n\n/**\n * Definition of an object representing a circle.\n */\nvar Circle = function () {\n\n    /**\n     * Construct a new circle using center point `A` and radius `r`.\n     *\n     * @param {Point} a Center point `A`.\n     * @param {number} r The radius `r`.\n     * @return {void}\n     */\n\n    /**\n     * Circle center point.\n     *\n     * @type {Point}\n     */\n    function Circle(a, r) {\n        _classCallCheck(this, Circle);\n\n        this._a = a;\n        this._r = r;\n    }\n\n    /**\n     * Create a new circle from an array. The first index should be point\n     * `A` and the second index should be the radius `r`.\n     *\n     * @param {CircleArray} array Input array with at least two values.\n     * @return {Circle} Resulting circle.\n     */\n\n\n    /**\n     * Circle radius.\n     *\n     * @type {number}\n     */\n\n\n    _createClass(Circle, [{\n        key: 'toRectangle',\n\n\n        /**\n         * Convert this circle to a rectangle that contains this circle exactly.\n         *\n         * @return {Rectangle} Converted rectangle.\n         */\n        value: function toRectangle() {\n            var a = new _Point2.default(this._a._x - this._r, this._a._y - this._r);\n            var b = new _Point2.default(this._a._x + this._r, this._a._y + this._r);\n\n            return new _Rectangle2.default(a, b);\n        }\n\n        /**\n         * Convert this circle into an object.\n         *\n         * @return {CircleObject} Object representation (a, r).\n         */\n\n    }, {\n        key: 'toObject',\n        value: function toObject() {\n            return {\n                a: this._a.toObject(),\n                r: this._r\n            };\n        }\n\n        /**\n         * Convert this circle into an array.\n         *\n         * @return {CircleArray} Array representation (a, r).\n         */\n\n    }, {\n        key: 'toArray',\n        value: function toArray() {\n            return [this._a.toArray(), this._r];\n        }\n\n        /**\n         * Convert this circle into a string representation.\n         *\n         * @return {string} String representation (a, r).\n         */\n\n    }, {\n        key: 'toString',\n        value: function toString() {\n            return '(' + this._a.toString() + ', ' + this._r + ')';\n        }\n\n        /**\n         * Create a shallow copy of this instance.\n         *\n         * @return {Circle} Cloned instance.\n         */\n\n    }, {\n        key: 'clone',\n        value: function clone() {\n            return new Circle(this._a, this._r);\n        }\n\n        /**\n         * Return true if this circle is equal to another circle. Two circles are\n         * equal if and only if the center point and radius are equal.\n         *\n         * @param {Object} that Other instance to compare to.\n         * @return {boolean} True if both circles are equal, false otherwise.\n         */\n\n    }, {\n        key: 'equals',\n        value: function equals(that) {\n            return this.constructor.name === that.constructor.name && this._a.equals(that._a) && this._r === that._r;\n        }\n\n        /**\n         * Return true if the circle is defined, finite and valid.\n         *\n         * @return {boolean} True if the circle is fully defined, finite and valid.\n         */\n\n    }, {\n        key: 'isValid',\n        value: function isValid() {\n            return this._a.isValid() && typeof this._r === 'number' && isFinite(this._r) && this._r >= 0;\n        }\n    }, {\n        key: 'a',\n\n\n        /**\n         * Get the circle center point.\n         *\n         * @return {Point} Center point.\n         */\n        get: function get() {\n            return this._a;\n        }\n\n        /**\n         * Get the circle center x coordinate. Shortcut for `this.a.x`.\n         *\n         * @return {number} Circle center x coordinate.\n         */\n\n    }, {\n        key: 'x',\n        get: function get() {\n            return this._a._x;\n        }\n\n        /**\n         * Get the circle center y coordinate. Shortcut for `this.a.y`.\n         *\n         * @return {number} Circle center y coordinate.\n         */\n\n    }, {\n        key: 'y',\n        get: function get() {\n            return this._a._y;\n        }\n\n        /**\n         * Get the circle radius.\n         *\n         * @return {number} Circle radius.\n         */\n\n    }, {\n        key: 'r',\n        get: function get() {\n            return this._r;\n        }\n\n        /**\n         * Get the diameter. This is a shortcut for `this.r * 2`.\n         *\n         * @return {number} The circle diameter.\n         */\n\n    }, {\n        key: 'd',\n        get: function get() {\n            return this._r * 2;\n        }\n    }], [{\n        key: 'fromArray',\n        value: function fromArray(array) {\n            if (true) {\n                if (!Array.isArray(array) || array.length < 2) {\n                    throw new Error('Expected an array with at least two values.');\n                }\n            }\n\n            return new Circle(_Point2.default.fromArray(array[0]), array[1]);\n        }\n\n        /**\n         * Create a new circle from an object. The object should have an `a` and\n         * `r` property.\n         *\n         * @param {CircleObject} object Input object with `a` and `b` property.\n         * @return {Circle} Resulting circle.\n         */\n\n    }, {\n        key: 'fromObject',\n        value: function fromObject(object) {\n            if (true) {\n                if ((typeof object === 'undefined' ? 'undefined' : _typeof(object)) !== 'object') {\n                    throw new Error('Expected an object.');\n                }\n            }\n\n            return new Circle(_Point2.default.fromObject(object.a), object.r);\n        }\n    }]);\n\n    return Circle;\n}();\n\nexports.default = Circle;\n\n//# sourceURL=webpack:///./src/Circle.js?");

/***/ }),

/***/ "./src/Line.js":
/*!*********************!*\
  !*** ./src/Line.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Point = __webpack_require__(/*! ./Point */ \"./src/Point.js\");\n\nvar _Point2 = _interopRequireDefault(_Point);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Immutable line class.\n *\n * A line is defined by two points, `a` and `b`. It has no thickness and its\n * length is inifite (e.g. it extends beyond point `a` and `b`).\n */\n\n\n/**\n * Definition of an array representing a line.\n */\n\n\n/**\n * Definition of an object representing a line.\n */\nvar Line = function () {\n\n    /**\n     * Construct a new immutable line out of two points.\n     *\n     * @param {Point} a The `A` point..\n     * @param {Point} b The `B` point.\n     * @return {void}\n     */\n\n    /**\n     * The `A` point.\n     *\n     * @type {Point}\n     */\n    function Line(a, b) {\n        _classCallCheck(this, Line);\n\n        this._a = a;\n        this._b = b;\n    }\n\n    /**\n     * Create a new line from an array. The first index should be point\n     * `A` and the second index should be point `B`.\n     *\n     * @param {LineArray} array Input array with at least two values.\n     * @return {Line} Resulting line.\n     */\n\n\n    /**\n     * The `B` point.\n     *\n     * @type {Point}\n     */\n\n\n    _createClass(Line, [{\n        key: 'toArray',\n\n\n        /**\n         * Return an array representation of this instance.\n         *\n         * @return {LineArray} Array representation [a, b].\n         */\n        value: function toArray() {\n            return [this._a.toArray(), this._b.toArray()];\n        }\n\n        /**\n         * Return an object representation of this instance.\n         *\n         * @return {LineObject} Object representation {a, b}.\n         */\n\n    }, {\n        key: 'toObject',\n        value: function toObject() {\n            return {\n                a: this._a.toObject(),\n                b: this._b.toObject()\n            };\n        }\n\n        /**\n         * Create a shallow copy of this instance.\n         *\n         * @return {Line} Cloned instance.\n         */\n\n    }, {\n        key: 'clone',\n        value: function clone() {\n            return new Line(this._a, this._b);\n        }\n\n        /**\n         * Return true if the line is defined and finite.\n         *\n         * @return {boolean} True if line is valid.\n         */\n\n    }, {\n        key: 'isValid',\n        value: function isValid() {\n            return this._a.isValid() && this._b.isValid();\n        }\n    }, {\n        key: 'a',\n\n\n        /**\n         * Return point `A`.\n         *\n         * @return {Point} Point `A`.\n         */\n        get: function get() {\n            return this._a;\n        }\n\n        /**\n         * Return point `B`.\n         *\n         * @return {Point} Point `B`.\n         */\n\n    }, {\n        key: 'b',\n        get: function get() {\n            return this._b;\n        }\n\n        /**\n         * Return the length.\n         *\n         * @return {number} length of line, which is infinity, per definition.\n         */\n\n    }, {\n        key: 'length',\n        get: function get() {\n            return Infinity;\n        }\n    }], [{\n        key: 'fromArray',\n        value: function fromArray(array) {\n            if (true) {\n                if (!Array.isArray(array) || array.length < 2) {\n                    throw new Error('Expected an array with at least two values.');\n                }\n            }\n\n            return new Line(_Point2.default.fromArray(array[0]), _Point2.default.fromArray(array[1]));\n        }\n\n        /**\n         * Create a new line from an object. The object should have an `a` and\n         * `b` property.\n         *\n         * @param {LineObject} object Input object with `a` and `b` property.\n         * @return {Line} Resulting line.\n         */\n\n    }, {\n        key: 'fromObject',\n        value: function fromObject(object) {\n            if (true) {\n                if ((typeof object === 'undefined' ? 'undefined' : _typeof(object)) !== 'object') {\n                    throw new Error('Expected an object.');\n                }\n            }\n\n            return new Line(_Point2.default.fromObject(object.a), _Point2.default.fromObject(object.b));\n        }\n    }]);\n\n    return Line;\n}();\n\nexports.default = Line;\n\n//# sourceURL=webpack:///./src/Line.js?");

/***/ }),

/***/ "./src/LineSegment.js":
/*!****************************!*\
  !*** ./src/LineSegment.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Point = __webpack_require__(/*! ./Point */ \"./src/Point.js\");\n\nvar _Point2 = _interopRequireDefault(_Point);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Immutable line segment class.\n *\n * A line is defined by two points, `a` and `b`. It has no thickness and its\n * length is defined by the absolute difference between `a` and `b`.\n */\n\n\n/**\n * Definition of an array representing a line segment.\n */\n\n/**\n * Definition of an object representing a line segment.\n */\nvar LineSegment = function () {\n\n    /**\n     * Construct a new immutable line segment out of two points.\n     *\n     * @param {Point} a The `A` point..\n     * @param {Point} b The `B` point.\n     * @return {void}\n     */\n\n    /**\n     * The `A` point.\n     *\n     * @type {Point}\n     */\n    function LineSegment(a, b) {\n        _classCallCheck(this, LineSegment);\n\n        this._a = a;\n        this._b = b;\n    }\n\n    /**\n     * Create a new line segment from an array. The first index should be point\n     * `A` and the second index should be point `B`.\n     *\n     * @param {LineSegmentArray} array Input array with at least two values.\n     * @return {LineSegment} Resulting line segment.\n     */\n\n\n    /**\n     * The `B` point.\n     *\n     * @type {Point}\n     */\n\n\n    _createClass(LineSegment, [{\n        key: 'intersection',\n\n\n        /**\n         * Calculate the intersection point of the two line segments. If there is\n         * no intersection, this method returns null.\n         *\n         * Algorithm is based on http://stackoverflow.com/a/35457290/1423623.\n         *\n         * @param {LineSegment} other The other line segment.\n         * @return {?Point} Point of intersection, if any.\n         */\n        value: function intersection(other) {\n            var dx1 = this._b._x - this._a._x;\n            var dy1 = this._b._y - this._a._y;\n\n            var dx2 = other._b._x - other._a._x;\n            var dy2 = other._b._y - other._a._y;\n\n            var dx3 = this._a._x - other._a._x;\n            var dy3 = this._a._y - other._a._y;\n\n            var d = dx1 * dy2 - dx2 * dy1;\n\n            if (d !== 0) {\n                var s = dx1 * dy3 - dx3 * dy1;\n\n                if (s <= 0 && d < 0 && s >= d || s >= 0 && d > 0 && s <= d) {\n                    var t = dx2 * dy3 - dx3 * dy2;\n\n                    if (t <= 0 && d < 0 && t > d || t >= 0 && d > 0 && t < d) {\n                        var u = t / d;\n\n                        return new _Point2.default(this._a._x + u * dx1, this._a._y + u * dy1);\n                    }\n                }\n            }\n\n            return null;\n        }\n\n        /**\n         * Return an array representation of this instance.\n         *\n         * @return {LineSegmentArray} Array representation [a, b].\n         */\n\n    }, {\n        key: 'toArray',\n        value: function toArray() {\n            return [this._a.toArray(), this._b.toArray()];\n        }\n\n        /**\n         * Return an object representation of this instance.\n         *\n         * @return {LineSegmentObject} Object representation {a, b}.\n         */\n\n    }, {\n        key: 'toObject',\n        value: function toObject() {\n            return {\n                a: this._a.toObject(),\n                b: this._b.toObject()\n            };\n        }\n\n        /**\n         * Create a shallow copy of this instance.\n         *\n         * @return {LineSegment} Cloned instance.\n         */\n\n    }, {\n        key: 'clone',\n        value: function clone() {\n            return new LineSegment(this._a, this._b);\n        }\n\n        /**\n         * Return true if the line segment is defined and finite.\n         *\n         * @return {boolean} True if line segment is valid.\n         */\n\n    }, {\n        key: 'isValid',\n        value: function isValid() {\n            return this._a.isValid() && this._b.isValid();\n        }\n    }, {\n        key: 'a',\n\n\n        /**\n         * Return point `A`.\n         *\n         * @return {Point} Point `A`.\n         */\n        get: function get() {\n            return this._a;\n        }\n\n        /**\n         * Return point `B`.\n         *\n         * @return {Point} Point `B`.\n         */\n\n    }, {\n        key: 'b',\n        get: function get() {\n            return this._b;\n        }\n\n        /**\n         * Return the length.\n         *\n         * @return {number} length of line, which is infinity, per definition.\n         */\n\n    }, {\n        key: 'length',\n        get: function get() {\n            return this._a.distance(this._b);\n        }\n    }], [{\n        key: 'fromArray',\n        value: function fromArray(array) {\n            if (true) {\n                if (!Array.isArray(array) || array.length < 2) {\n                    throw new Error('Expected an array with at least two values.');\n                }\n            }\n\n            return new LineSegment(_Point2.default.fromArray(array[0]), _Point2.default.fromArray(array[1]));\n        }\n\n        /**\n         * Create a new line segment from an object. The object should have an `a` and\n         * `b` property.\n         *\n         * @param {LineSegmentObject} object Input object with `a` and `b`\n         *                            property.\n         * @return {LineSegment} Resulting line segment.\n         */\n\n    }, {\n        key: 'fromObject',\n        value: function fromObject(object) {\n            if (true) {\n                if ((typeof object === 'undefined' ? 'undefined' : _typeof(object)) !== 'object') {\n                    throw new Error('Expected an object.');\n                }\n            }\n\n            return new LineSegment(_Point2.default.fromObject(object.a), _Point2.default.fromObject(object.b));\n        }\n    }]);\n\n    return LineSegment;\n}();\n\nexports.default = LineSegment;\n\n//# sourceURL=webpack:///./src/LineSegment.js?");

/***/ }),

/***/ "./src/Point.js":
/*!**********************!*\
  !*** ./src/Point.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Vector = __webpack_require__(/*! ./Vector */ \"./src/Vector.js\");\n\nvar _Vector2 = _interopRequireDefault(_Vector);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Immutable point class.\n *\n * A point is an absolute place in space, at a given x and y coordinate.\n *\n * The difference between a Point and a vector is explained in this source:\n * http://math.stackexchange.com/a/645827 and\n * http://geomalgorithms.com/points_and_vectors.html.\n */\n\n\n/**\n * Definition of an array representing a point.\n */\n\n\n/**\n * Definition of an object representing a point.\n */\nvar Point = function () {\n\n    /**\n     * Construct a new point, using a x and y coordinate.\n     *\n     * An point is immutable. All subsequent operations will return a new point\n     * instance.\n     *\n     * @param {number} x The x coordinate.\n     * @param {number} y The y coordinate.\n     * @return {void}\n     */\n\n    /**\n     * The x coordinate.\n     *\n     * @type {number}\n     */\n    function Point(x, y) {\n        _classCallCheck(this, Point);\n\n        this._x = x;\n        this._y = y;\n    }\n\n    /**\n     * Create a new point from an array. The first index is considered the x\n     * coordinate, the second index is considered the y coordinate.\n     *\n     * @param {PointArray} array Input array with at least two values.\n     * @return {Point} Resulting point.\n     */\n\n\n    /**\n     * The y coordinate.\n     *\n     * @type {number}\n     */\n\n\n    _createClass(Point, [{\n        key: 'add',\n\n\n        /**\n         * Add a vector to a point.\n         *\n         * Note that addition of two points is undefined.\n         *\n         * @param {Vector} vector Vector to add to this point.\n         * @return {Point} Point with the vector added to it.\n         */\n        value: function add(vector) {\n            if (true) {\n                // $FlowFixMe\n                if (vector instanceof Point) {\n                    throw new Error('Addition of two points is undefined.');\n                }\n            }\n\n            return new Point(this._x + vector._x, this._y + vector._y);\n        }\n\n        /**\n         * Subtract a Point from this point, to calculate the displacement.\n         *\n         * @param {Point} that Point to subtract.\n         * @return {Vector} The displacement as a Vector.\n         */\n\n    }, {\n        key: 'subtract',\n        value: function subtract(that) {\n            if (true) {\n                // $FlowFixMe\n                if (that instanceof _Vector2.default) {\n                    throw new Error('Cannot subract Vector. Use `subtractVector` instead.');\n                }\n            }\n\n            return new _Vector2.default(this._x - that._x, this._y - that._y);\n        }\n\n        /**\n         * Subtract a Vector from this Point.\n         *\n         * @param {Vector} vector Vector to subtract.\n         * @return {Point} If `that` is a Vector, it will return the new point.\n         */\n\n    }, {\n        key: 'subtractVector',\n        value: function subtractVector(vector) {\n            return new Point(this._x - vector._x, this._y - vector._y);\n        }\n\n        /**\n         * Snap a point to a fixed number.\n         *\n         * @param {number} to The number to fix to.\n         * @return {Point} New point snapped to the given number.\n         */\n\n    }, {\n        key: 'snap',\n        value: function snap(to) {\n            var round = function round(val) {\n                return Math.round(val / to) * to;\n            };\n\n            return new Point(round(this._x), round(this._y));\n        }\n\n        /**\n         * Calculate the squared distance between two points.\n         *\n         * If the exact distance doesn't matter, this method is slightly faster\n         * than `this.distance`.\n         *\n         * @param {Point} point The other point.\n         * @return {number} The distance between both points.\n         */\n\n    }, {\n        key: 'distanceSq',\n        value: function distanceSq(point) {\n            if (true) {\n                if (!(point instanceof Point)) {\n                    throw new Error('Must be a point.');\n                }\n            }\n\n            var dX = this._x - point._x;\n            var dY = this._y - point._y;\n\n            return dX * dX + dY * dY;\n        }\n\n        /**\n         * Calculate the distance between two points.\n         *\n         * @param {Point} point The other point.\n         * @return {number} The distance between both points.\n         */\n\n    }, {\n        key: 'distance',\n        value: function distance(point) {\n            return Math.sqrt(this.distanceSq(point));\n        }\n\n        /**\n         * Convert point into a vector.\n         *\n         * Note: this is an utility method. A mathematical definition of a\n         * conversion does not exist.\n         *\n         * @return {Vector} The point converted as vector.\n         */\n\n    }, {\n        key: 'toVector',\n        value: function toVector() {\n            return new _Vector2.default(this._x, this._y);\n        }\n\n        /**\n         * Convert this point into an array.\n         *\n         * @return {PointArray} Array representation (x, y).\n         */\n\n    }, {\n        key: 'toArray',\n        value: function toArray() {\n            return [this._x, this._y];\n        }\n\n        /**\n         * Convert this point into an object.\n         *\n         * @return {PointObject} Object representation (x, y).\n         */\n\n    }, {\n        key: 'toObject',\n        value: function toObject() {\n            return { x: this._x, y: this._y };\n        }\n\n        /**\n         * Convert this point into a string representation.\n         *\n         * @return {string} String representation (x, y).\n         */\n\n    }, {\n        key: 'toString',\n        value: function toString() {\n            return '(' + this._x + ', ' + this._y + ')';\n        }\n\n        /**\n         * Convert this point into a string representation, using a fixed number of\n         * digits for displaying.\n         *\n         * @param {number} digits Number of digits to use for representation.\n         * @return {string} String representation (x, y).\n         */\n\n    }, {\n        key: 'toFixed',\n        value: function toFixed(digits) {\n            if (true) {\n                if (typeof digits !== 'number') {\n                    throw new Error('Number of digits must be a number.');\n                }\n            }\n\n            return '(' + this._x.toFixed(digits) + ', ' + this._y.toFixed(digits) + ')';\n        }\n\n        /**\n         * Create a shallow copy of this instance.\n         *\n         * @return {Point} Cloned instance.\n         */\n\n    }, {\n        key: 'clone',\n        value: function clone() {\n            return new Point(this._x, this._y);\n        }\n\n        /**\n         * Return true if this point is equal to another point. Two points are\n         * equal when both x and y coordinates are equal.\n         *\n         * @param {Object} that Other instance to compare to.\n         * @return {boolean} True if both points are equal, false otherwise.\n         */\n\n    }, {\n        key: 'equals',\n        value: function equals(that) {\n            return this.constructor.name === that.constructor.name && this._x === that._x && this._y === that._y;\n        }\n\n        /**\n         * Return true if the point is defined and finite.\n         *\n         * @return {boolean} True if point is fully defined and valid.\n         */\n\n    }, {\n        key: 'isValid',\n        value: function isValid() {\n            return typeof this._x === 'number' && isFinite(this._x) && typeof this._y === 'number' && isFinite(this._y);\n        }\n    }, {\n        key: 'x',\n\n\n        /**\n         * Get the x coordinate.\n         *\n         * @return {number} The x coordinate.\n         */\n        get: function get() {\n            return this._x;\n        }\n\n        /**\n         * Get the y coordinate.\n         *\n         * @return {number} The y coordinate.\n         */\n\n    }, {\n        key: 'y',\n        get: function get() {\n            return this._y;\n        }\n    }], [{\n        key: 'fromArray',\n        value: function fromArray(array) {\n            if (true) {\n                if (!Array.isArray(array) || array.length < 2) {\n                    throw new Error('Expected an array with at least two values.');\n                }\n            }\n\n            return new Point(array[0], array[1]);\n        }\n\n        /**\n         * Create a new point from an object. The object should have an x and y\n         * property.\n         *\n         * @param {PointObject} object Input object with x and y property.\n         * @return {Point} Resulting point.\n         */\n\n    }, {\n        key: 'fromObject',\n        value: function fromObject(object) {\n            if (true) {\n                if ((typeof object === 'undefined' ? 'undefined' : _typeof(object)) !== 'object') {\n                    throw new Error('Expected an object.');\n                }\n            }\n\n            return new Point(object.x, object.y);\n        }\n    }]);\n\n    return Point;\n}();\n\nexports.default = Point;\n\n//# sourceURL=webpack:///./src/Point.js?");

/***/ }),

/***/ "./src/Rectangle.js":
/*!**************************!*\
  !*** ./src/Rectangle.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Point = __webpack_require__(/*! ./Point */ \"./src/Point.js\");\n\nvar _Point2 = _interopRequireDefault(_Point);\n\nvar _LineSegment = __webpack_require__(/*! ./LineSegment */ \"./src/LineSegment.js\");\n\nvar _LineSegment2 = _interopRequireDefault(_LineSegment);\n\nvar _Vector = __webpack_require__(/*! ./Vector */ \"./src/Vector.js\");\n\nvar _Vector2 = _interopRequireDefault(_Vector);\n\nvar _Circle = __webpack_require__(/*! ./Circle */ \"./src/Circle.js\");\n\nvar _Circle2 = _interopRequireDefault(_Circle);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Immutable rectangle class.\n */\n\n\n/**\n * Definition of an array representing a rectangle.\n */\n\n/**\n * Definition of an object representing a rectangle.\n */\n\n\n/**\n * Definition of an object representing a bounding box.\n */\nvar Rectangle = function () {\n\n    /**\n     * Construct a new immutable rectangle of two points.\n     *\n     * @param {Point} a The `A` point..\n     * @param {Point} b The `B` point.\n     * @return {void}\n     */\n\n    /**\n     * The `A` point.\n     *\n     * @type {Point}\n     */\n    function Rectangle(a, b) {\n        _classCallCheck(this, Rectangle);\n\n        this._a = a;\n        this._b = b;\n    }\n\n    /**\n     * Create a new rectangle from an array. The first index should be point\n     * `A` and the second index should be point `B`.\n     *\n     * @param {RectangleArray} array Input array with at least two values.\n     * @return {Rectangle} Resulting rectangle.\n     */\n\n\n    /**\n     * The `B` point.\n     *\n     * @type {Point}\n     */\n\n\n    _createClass(Rectangle, [{\n        key: 'center',\n\n\n        /**\n         * Calculate the center point of this rectangle.\n         *\n         * @return {Point} Center of this rectangle.\n         */\n        value: function center() {\n            var x = (this._a._x + this._b._x) / 2;\n            var y = (this._a._y + this._b._y) / 2;\n\n            return new _Point2.default(x, y);\n        }\n\n        /**\n         * Calculate the center point offset.\n         *\n         * @return {Vector} Relative center point offset of this rectangle.\n         */\n\n    }, {\n        key: 'centerOffset',\n        value: function centerOffset() {\n            var center = this.center();\n\n            return center.subtract(this._a);\n        }\n\n        /**\n         * Merge two rectangles, taking the bouding box that contains both\n         * rectangles.\n         *\n         * @param {Rectangle} rectangle Other rectangle to merge with.\n         * @return {Rectangle} New rectangle containing both rectangles.\n         */\n\n    }, {\n        key: 'merge',\n        value: function merge(rectangle) {\n            if (true) {\n                if (!(rectangle instanceof Rectangle)) {\n                    throw new Error('Must merge with another rectangle.');\n                }\n            }\n\n            var a = new _Point2.default(Math.min(this._a._x, this._b._x, rectangle._a._x, rectangle._b._x), Math.min(this._a._y, this._b._y, rectangle._a._y, rectangle._b._y));\n            var b = new _Point2.default(Math.max(this._a._x, this._b._x, rectangle._a._x, rectangle._b._x), Math.max(this._a._y, this._b._y, rectangle._a._y, rectangle._b._y));\n\n            return new Rectangle(a, b);\n        }\n\n        /**\n         * Move the rectangle by applying an offset to the points `a` and `b`.\n         *\n         * @param {Vector} vector Offset vector.\n         * @return {Rectangle} Moved rectangle.\n         */\n\n    }, {\n        key: 'move',\n        value: function move(vector) {\n            if (true) {\n                if (!(vector instanceof _Vector2.default)) {\n                    throw new Error('Offset must be a vector.');\n                }\n            }\n\n            return new Rectangle(this._a.add(vector), this._b.add(vector));\n        }\n\n        /**\n         * Move the `a` point and `b` point of this rectangle individually.\n         *\n         * @param {Vector} vectorA Offset vector for `a` point.\n         * @param {Vector} vectorB Offset vector for `b` point.\n         * @return {Rectangle} Moved rectangle.\n         */\n\n    }, {\n        key: 'moveAB',\n        value: function moveAB(vectorA, vectorB) {\n            if (true) {\n                if (!(vectorA instanceof _Vector2.default) || !(vectorB instanceof _Vector2.default)) {\n                    throw new Error('Offset must be a vector.');\n                }\n            }\n\n            return new Rectangle(this._a.add(vectorA), this._b.add(vectorB));\n        }\n\n        /**\n         * Similar to move, but moves `a` and `b` in opposite directions by\n         * inverting the vector for `a`.\n         *\n         * This method may shrink the rectangle if the vector is negative, or if\n         * points `a` and `b` have been swapped. Normalize the\n         *\n         * @param {Vector} vector The offset vector to expand with.\n         * @return {Rectangle} Expanded rectangle.\n         */\n\n    }, {\n        key: 'expand',\n        value: function expand(vector) {\n            return this.moveAB(vector.invert(), vector);\n        }\n\n        /**\n         * Returns true if a given point is on this rectangle.\n         *\n         * @param {Point} point Point to test with.\n         * @return {boolean} True if point is within rectangle.\n         */\n\n    }, {\n        key: 'containsPoint',\n        value: function containsPoint(point) {\n            if (true) {\n                if (!(point instanceof _Point2.default)) {\n                    throw new Error('Must be a point.');\n                }\n            }\n\n            return (point._x >= this._a._x && point._x <= this._b._x || point._x >= this._b._x && point._x <= this._a._x) && (point._y >= this._a._y && point._y <= this._b._y || point._y >= this._b._y && point._y <= this._a._y);\n        }\n\n        /**\n         * Returns true if a given rectangle is within this rectangle. That is,\n         * both point `A` and `B` are within this rectangle.\n         *\n         * @param {Rectangle} rectangle The rectangle to check for.\n         * @return {boolean} True if the rectangle is within this rectangle.\n         */\n\n    }, {\n        key: 'containsRectangle',\n        value: function containsRectangle(rectangle) {\n            if (true) {\n                if (!(rectangle instanceof Rectangle)) {\n                    throw new Error('Must be a rectangle.');\n                }\n            }\n\n            return this.containsPoint(rectangle.a) && this.containsPoint(rectangle.b);\n        }\n\n        /**\n         * Returns true if a given rectangle collides with this rectangle.\n         *\n         * @param {Rectangle} rectangle Other rectangle to compare with.\n         * @return {boolean} True if the given rectangle collides with this one.\n         */\n\n    }, {\n        key: 'collidesRectangle',\n        value: function collidesRectangle(rectangle) {\n            if (true) {\n                if (!(rectangle instanceof Rectangle)) {\n                    throw new Error('Must be a rectangle.');\n                }\n            }\n\n            return this._a._x < rectangle._b._x && this._b._x > rectangle._a._x && this._a._y < rectangle._b._y && this._b._y > rectangle._a._y;\n        }\n\n        /**\n         * Returns true if a given circle collides with this rectangle.\n         *\n         * @param {Circle} circle Other circle to compare with.\n         * @return {boolean} True if the given circles collides with this one.\n         */\n\n    }, {\n        key: 'collidesCircle',\n        value: function collidesCircle(circle) {\n            if (true) {\n                if (!(circle instanceof _Circle2.default)) {\n                    throw new Error('Must be a circle.');\n                }\n            }\n\n            var clamp = function clamp(value, min, max) {\n                return Math.max(min, Math.min(max, value));\n            };\n\n            var closest = new _Point2.default(clamp(circle._a._x, this._a._x, this._b._x), clamp(circle._a._y, this._a._y, this._b._y));\n\n            return closest.distanceSq(circle._a) < circle._r * circle._r;\n        }\n\n        /**\n         * Calculate the area of the given rectangle.\n         *\n         * @return {number} The rectangle area.\n         */\n\n    }, {\n        key: 'area',\n        value: function area() {\n            return (this._b._x - this._a._x) * (this._b._y - this._a._y);\n        }\n\n        /**\n         * Return an array representation of this instance.\n         *\n         * @return {RectangleArray} Array representation [a, b].\n         */\n\n    }, {\n        key: 'toArray',\n        value: function toArray() {\n            return [this._a.toArray(), this._b.toArray()];\n        }\n\n        /**\n         * Return an object representation of this instance.\n         *\n         * @return {RectangleObject} Object representation {a, b}.\n         */\n\n    }, {\n        key: 'toObject',\n        value: function toObject() {\n            return {\n                a: this._a.toObject(),\n                b: this._b.toObject()\n            };\n        }\n\n        /**\n         * Return an object representation of the bounding rectangle of this\n         * instance.\n         *\n         * @return {BoundingObject} Object representation { left, top, width, height }.\n         */\n\n    }, {\n        key: 'toBoundingRect',\n        value: function toBoundingRect() {\n            return {\n                left: this.left,\n                top: this.top,\n                width: this.width,\n                height: this.height\n            };\n        }\n\n        /**\n         * Return a string representation of this rectangle.\n         *\n         * @return {string} String representation.\n         */\n\n    }, {\n        key: 'toString',\n        value: function toString() {\n            return '(' + this._a.toString() + ', ' + this._b.toString() + ')';\n        }\n\n        /**\n         * Return an array of line segments of the four edges of this rectangle.\n         *\n         * @return {Array<LineSegment>} Array of line segments.\n         */\n\n    }, {\n        key: 'toLineSegments',\n        value: function toLineSegments() {\n            var c = new _Point2.default(this._a._x, this._b._y);\n            var d = new _Point2.default(this._b._x, this._a._y);\n\n            return [new _LineSegment2.default(this._a, d), new _LineSegment2.default(d, this._b), new _LineSegment2.default(this._b, c), new _LineSegment2.default(c, this._a)];\n        }\n\n        /**\n         * Create a shallow copy of this instance.\n         *\n         * @return {Rectangle} Cloned instance.\n         */\n\n    }, {\n        key: 'clone',\n        value: function clone() {\n            return new Rectangle(this._a, this._b);\n        }\n\n        /**\n         * Return a normalize rectangle, with the `A` point in the top-left\n         * position and the `B` point in the bottom-right position.\n         *\n         * @return {Rectangle} The normalized rectangle.\n         */\n\n    }, {\n        key: 'normalize',\n        value: function normalize() {\n            return new Rectangle(new _Point2.default(this.left, this.top), new _Point2.default(this.right, this.bottom));\n        }\n\n        /**\n         * Return true if this rectangle is equal to another rectangle. Two\n         * rectangles are equal if and only if both points are equal. This means\n         * if two rectangles have the same left, right, top and bottom, they\n         * may not be equal, because they may have been defined from different\n         * points.\n         *\n         * @param {Object} that Other instance to compare to.\n         * @return {boolean} True if both rectangles are equal, false otherwise.\n         */\n\n    }, {\n        key: 'equals',\n        value: function equals(that) {\n            return this.constructor.name === that.constructor.name && this._a.equals(that._b) && this._b.equals(that._b);\n        }\n\n        /**\n         * Return true if the rectangle is defined and finite.\n         *\n         * @return {boolean} True if rectangle is valid.\n         */\n\n    }, {\n        key: 'isValid',\n        value: function isValid() {\n            return this._a.isValid() && this._b.isValid();\n        }\n    }, {\n        key: 'a',\n\n\n        /**\n         * Return point `A`.\n         *\n         * @return {Point} Point `A`.\n         */\n        get: function get() {\n            return this._a;\n        }\n\n        /**\n         * Return point `B`.\n         *\n         * @return {Point} Point `B`.\n         */\n\n    }, {\n        key: 'b',\n        get: function get() {\n            return this._b;\n        }\n\n        /**\n         * Return the left x coordinate.\n         *\n         * @return {number} Left x coordinate.\n         */\n\n    }, {\n        key: 'left',\n        get: function get() {\n            // return Math.min(this._a._x, this._b._x);\n            return this._a._x;\n        }\n\n        /**\n         * Return the right x coordinate.\n         *\n         * @return {number} Right x coordinate.\n         */\n\n    }, {\n        key: 'right',\n        get: function get() {\n            // return Math.max(this._a._x, this._b._x);\n            return this._b._x;\n        }\n\n        /**\n         * Return the top y coordinate.\n         *\n         * @return {number} Top y coordinate.\n         */\n\n    }, {\n        key: 'top',\n        get: function get() {\n            // return Math.min(this._a._y, this._b._y);\n            return this._a._y;\n        }\n\n        /**\n         * Return the bottom y coordinate.\n         *\n         * @return {number} Bottom y coordinate.\n         */\n\n    }, {\n        key: 'bottom',\n        get: function get() {\n            // return Math.max(this._a._y, this._b._y);\n            return this._b._y;\n        }\n\n        /**\n         * Return the width of this rectangle, which is the difference between\n         * `this.right` and `this.left`.\n         *\n         * @return {number} Width of the rectangle.\n         */\n\n    }, {\n        key: 'width',\n        get: function get() {\n            return this.right - this.left;\n        }\n\n        /**\n         * Return the height of this rectangle, which is the difference between\n         * `this.bottom` and `this.top`.\n         *\n         * @return {number} Height of the rectangle.\n         */\n\n    }, {\n        key: 'height',\n        get: function get() {\n            return this.bottom - this.top;\n        }\n    }], [{\n        key: 'fromArray',\n        value: function fromArray(array) {\n            if (true) {\n                if (!Array.isArray(array) || array.length < 2) {\n                    throw new Error('Expected an array with at least two values.');\n                }\n            }\n\n            return new Rectangle(_Point2.default.fromArray(array[0]), _Point2.default.fromArray(array[1]));\n        }\n\n        /**\n         * Create a new rectangle from an object. The object should have an `a` and\n         * `b` property.\n         *\n         * @param {RectangleObject} object Input object with `a` and `b` property.\n         * @return {Rectangle} Resulting rectangle.\n         */\n\n    }, {\n        key: 'fromObject',\n        value: function fromObject(object) {\n            if (true) {\n                if ((typeof object === 'undefined' ? 'undefined' : _typeof(object)) !== 'object') {\n                    throw new Error('Expected an object.');\n                }\n            }\n\n            return new Rectangle(_Point2.default.fromObject(object.a), _Point2.default.fromObject(object.b));\n        }\n\n        /**\n         * Create a new rectangle from a (client) bounding rect from an element.\n         * However, it accepts any object with a `left`, `top, `width` and `height`\n         * property.\n         *\n         * @param {Object} boundingRect Input bounding rectangle.\n         * @return {Rectangle} Rectangle based on given bounding rectangle.\n         */\n\n    }, {\n        key: 'fromBoundingRect',\n        value: function fromBoundingRect(boundingRect) {\n            return new Rectangle(new _Point2.default(boundingRect.left, boundingRect.top), new _Point2.default(boundingRect.left + boundingRect.width, boundingRect.top + boundingRect.height));\n        }\n    }]);\n\n    return Rectangle;\n}();\n\nexports.default = Rectangle;\n\n//# sourceURL=webpack:///./src/Rectangle.js?");

/***/ }),

/***/ "./src/Vector.js":
/*!***********************!*\
  !*** ./src/Vector.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Point = __webpack_require__(/*! ./Point */ \"./src/Point.js\");\n\nvar _Point2 = _interopRequireDefault(_Point);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Immutable vector class.\n *\n * A vector represents a displacement, using a x an `y` component to represent\n * the length (magnitude) and direction.\n *\n * The difference between a Vector and a Point is explained in this source:\n * http://math.stackexchange.com/a/645827 and\n * http://geomalgorithms.com/points_and_vectors.html.\n */\n\n\n/**\n * Definition of an array representing a vector.\n */\n\n\n/**\n * Definition of an object representing a vector.\n */\nvar Vector = function () {\n\n    /**\n     * Construct a new vector, using a x and `y` component to represent the\n     * length (magnitude) and direction relative to (0, 0).\n     *\n     * An vector is immutable. All subsequent operations will return a new\n     * vector instance.\n     *\n     * @param {number} x The `x` component.\n     * @param {number} y The `y` component.\n     * @return {void}\n     */\n\n\n    /**\n     * The y coordinate.\n     *\n     * @type {number}\n     */\n    function Vector(x, y) {\n        _classCallCheck(this, Vector);\n\n        this._x = x;\n        this._y = y;\n    }\n\n    /**\n     * Create a new vector from an array. The first index is considered the x\n     * component, the second index is considered the `y` component.\n     *\n     * @param {VectorArray} array Input array with at least two values.\n     * @return {Vector} Resulting vector.\n     */\n\n\n    /**\n     * Definition of the unit vector.\n     */\n\n    /**\n     * The x coordinate.\n     *\n     * @type {number}\n     */\n\n\n    _createClass(Vector, [{\n        key: 'add',\n\n\n        /**\n         * Add another vector to this vector.\n         *\n         * @param {Vector} vector Vector to add.\n         * @return {Vector} A new Vector if adding vector.\n         */\n        value: function add(vector) {\n            if (true) {\n                // $FlowFixMe\n                if (vector instanceof _Point2.default) {\n                    throw new Error('Addition of point to a vector is undefined.');\n                }\n            }\n\n            return new Vector(this._x + vector._x, this._y + vector._y);\n        }\n\n        /**\n         * Subtract another vector from this vector.\n         *\n         * @param {Vector} that Vector to subtract.\n         * @return {Vector} New vector with other vector subtracted from this.\n         */\n\n    }, {\n        key: 'subtract',\n        value: function subtract(that) {\n            return new Vector(this._x - that._x, this._y - that._y);\n        }\n\n        /**\n         * Invert a vector, returning a copy with inverted magnitude and direction.\n         *\n         * @return {Vector} Inverted vector\n         */\n\n    }, {\n        key: 'invert',\n        value: function invert() {\n            return new Vector(-this._x, -this._y);\n        }\n\n        /**\n         * Scale a vector by a scalar value.\n         *\n         * @param {number} scalar The scalar value.\n         * @return {Vector} New vector multiplied by the scalar.\n         */\n\n    }, {\n        key: 'multiply',\n        value: function multiply(scalar) {\n            return new Vector(this._x * scalar, this._y * scalar);\n        }\n\n        /**\n         * Scale a vector by a `x` and `y` scalar value.\n         *\n         * @param {number} scalarX The scalar value for the `x` component.\n         * @param {number} scalarY The scalar value for the `y` component.\n         * @return {Vector} New vector multiplied by both scalars.\n         */\n\n    }, {\n        key: 'multiplyXY',\n        value: function multiplyXY(scalarX, scalarY) {\n            return new Vector(this._x * scalarX, this._y * scalarY);\n        }\n\n        /**\n         * Divide a vector by a scalar value.\n         *\n         * @param {number} scalar The scalar value.\n         * @return {Vector} New vector divided by the scalar.\n         */\n\n    }, {\n        key: 'divide',\n        value: function divide(scalar) {\n            return new Vector(this._x / scalar, this._y / scalar);\n        }\n\n        /**\n         * Divide a vector by a `x` and `y` scalar value.\n         *\n         * @param {number} scalarX The scalar value for the `x` component.\n         * @param {number} scalarY The scalar value for the `y` component.\n         * @return {Vector} New vector divided by both scalars.\n         */\n\n    }, {\n        key: 'divideXY',\n        value: function divideXY(scalarX, scalarY) {\n            return new Vector(this._x / scalarX, this._y / scalarY);\n        }\n\n        /**\n         * Mix this vector with another vector, with a given weight.\n         *\n         * @param {Vector} that The other vector to mix with.\n         * @param {number} amount The weight (between 0 and 1).\n         * @return {Vector} A new vector with a mix of both this vector and the\n         *                  given vector.\n         */\n\n    }, {\n        key: 'mix',\n        value: function mix(that) {\n            var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;\n\n            if (true) {\n                if (amount < 0 || amount > 1) {\n                    throw new Error('Amount must be between 0 and 1.');\n                }\n            }\n\n            return this.multiply(1 - amount).add(that.multiply(amount));\n        }\n\n        /**\n         * Calculate the vector that is perpendicular to this vector.\n         *\n         * @return {Vector} The perpendicular vector.\n         */\n\n    }, {\n        key: 'perpendicular',\n        value: function perpendicular() {\n            return new Vector(-this._y, this._x);\n        }\n\n        /**\n         * Snap a vector to a fixed number.\n         *\n         * @param {number} to The number to fix to.\n         * @return {Point} New vector snapped to the given number.\n         */\n\n    }, {\n        key: 'snap',\n        value: function snap(to) {\n            var round = function round(val) {\n                return Math.round(val / to) * to;\n            };\n\n            return new Vector(round(this._x), round(this._y));\n        }\n\n        /**\n         * Calculate the dot value.\n         *\n         * @param {Vector} that The other vector.\n         * @return {number} The dot value of both vectors.\n         */\n\n    }, {\n        key: 'dot',\n        value: function dot(that) {\n            return this._x * that._x + this._y * that._y;\n        }\n\n        /**\n         * Return the angle of this vector.\n         *\n         * @return {number} Angle of the vector.\n         */\n\n    }, {\n        key: 'angle',\n        value: function angle() {\n            return Math.atan2(this._y, this._x);\n        }\n\n        /**\n         * Return the angle (in degrees) of this vector.\n         *\n         * @return {number} Angle of the vector (in degrees).\n         */\n\n    }, {\n        key: 'angleDeg',\n        value: function angleDeg() {\n            return Math.atan2(this._y, this._x) * 180 / Math.PI;\n        }\n\n        /**\n         * Calculate the slope of this vector.\n         *\n         * @return {number} The slope of the vector.\n         */\n\n    }, {\n        key: 'slope',\n        value: function slope() {\n            return this._y / this._x;\n        }\n\n        /**\n         * Calculate the squared length of this vector.\n         *\n         * If the exact length doesn't matter, this method is slightly faster\n         * than `this.length`.\n         *\n         * @return {number} The squared length of this vector.\n         */\n\n    }, {\n        key: 'lengthSq',\n        value: function lengthSq() {\n            return this._x * this._x + this._y * this._y;\n        }\n\n        /**\n         * Calculate the length (magnitude) of the vector.\n         *\n         * @return {number} The length of the vector.\n         */\n\n    }, {\n        key: 'length',\n        value: function length() {\n            return Math.sqrt(this.lengthSq());\n        }\n\n        /**\n         * Return a vector with a minimum length of the given number. If the length\n         * is less, normalize it. Otherwise this instance is returned.\n         *\n         * @param {number} length The minimum length.\n         * @return {Vector} The normalized vector.\n         */\n\n    }, {\n        key: 'minLength',\n        value: function minLength(length) {\n            return this.length() < length ? this.normalize(length) : this;\n        }\n\n        /**\n         * Return a vector with a maximum length of the given number. If the length\n         * is less, normalize it. Otherwise this instance is returned.\n         *\n         * @param {number} length The maximum length.\n         * @return {Vector} The normalized vector.\n         */\n\n    }, {\n        key: 'maxLength',\n        value: function maxLength(length) {\n            return this.length() > length ? this.normalize(length) : this;\n        }\n\n        /**\n         * Normalize the vector to a given scalar.\n         *\n         * @param {number} scalar The number to scale this vector to.\n         * @return {Vector} The normalized vector\n         */\n\n    }, {\n        key: 'normalize',\n        value: function normalize() {\n            var scalar = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n            return this.divide(this.length()).multiply(scalar);\n        }\n\n        /**\n         * Project this vector onto another vector.\n         *\n         * @param {Vector} that The other vector to project onto.\n         * @return {Vector} The projected vector.\n         */\n\n    }, {\n        key: 'projectOnto',\n        value: function projectOnto(that) {\n            return that.multiply(this.dot(that) / that.lengthSq());\n        }\n\n        /**\n         * Convert vector into a point.\n         *\n         * Note: this is an utility method. A mathematical definition of a\n         * conversion does not exist.\n         *\n         * @return {Point} The vector converted as point.\n         */\n\n    }, {\n        key: 'toPoint',\n        value: function toPoint() {\n            return new _Point2.default(this._x, this._y);\n        }\n\n        /**\n         * Convert this vector into an array.\n         *\n         * @return {VectorArray} Array representation (x, y).\n         */\n\n    }, {\n        key: 'toArray',\n        value: function toArray() {\n            return [this._x, this._y];\n        }\n\n        /**\n         * Convert this vector into an object.\n         *\n         * @return {Object} Object representation (x, y).\n         */\n\n    }, {\n        key: 'toObject',\n        value: function toObject() {\n            return { x: this._x, y: this._y };\n        }\n\n        /**\n         * Convert this vector into a string representation.\n         *\n         * @return {string} String representation (x, y).\n         */\n\n    }, {\n        key: 'toString',\n        value: function toString() {\n            return '(' + this._x + ', ' + this._y + ')';\n        }\n\n        /**\n         * Convert this vector into a string representation, using a fixed number\n         * of digits for displaying.\n         *\n         * @param {number} digits Number of digits to use for representation.\n         * @return {string} String representation (x, y).\n         */\n\n    }, {\n        key: 'toFixed',\n        value: function toFixed(digits) {\n            if (true) {\n                if (typeof digits !== 'number') {\n                    throw new Error('Number of digits must be a number.');\n                }\n            }\n\n            return '(' + this._x.toFixed(digits) + ', ' + this._y.toFixed(digits) + ')';\n        }\n\n        /**\n         * Create a shallow copy of this instance.\n         *\n         * @return {Vector} Cloned instance.\n         */\n\n    }, {\n        key: 'clone',\n        value: function clone() {\n            return new Vector(this._x, this._y);\n        }\n\n        /**\n         * Return true if this vector is equal to another vector. Two vectors are\n         * equal when both x and `y` components are equal.\n         *\n         * @param {Object} that Other instance to compare to.\n         * @return {boolean} True if both points are equal, false otherwise.\n         */\n\n    }, {\n        key: 'equals',\n        value: function equals(that) {\n            return this.constructor.name === that.constructor.name && this._x === that._x && this._y === that._y;\n        }\n\n        /**\n         * Return true if the vector is defined and finite.\n         *\n         * @return {boolean} True if vector is fully defined and valid.\n         */\n\n    }, {\n        key: 'isValid',\n        value: function isValid() {\n            return typeof this._x === 'number' && isFinite(this._x) && typeof this._y === 'number' && isFinite(this._y);\n        }\n    }, {\n        key: 'x',\n\n\n        /**\n         * Get the `x` component.\n         *\n         * @return {number} The `x` component.\n         */\n        get: function get() {\n            return this._x;\n        }\n\n        /**\n         * Get the `y` component.\n         *\n         * @return {number} The `y` component.\n         */\n\n    }, {\n        key: 'y',\n        get: function get() {\n            return this._y;\n        }\n    }], [{\n        key: 'fromArray',\n        value: function fromArray(array) {\n            if (true) {\n                if (!Array.isArray(array) || array.length < 2) {\n                    throw new Error('Expected an array with at least two values.');\n                }\n            }\n\n            return new Vector(array[0], array[1]);\n        }\n\n        /**\n         * Create a new vector from an object. The object should have an x and y\n         * property.\n         *\n         * @param {VectorObject} object Input object with x and y property.\n         * @return {Vector} Resulting vector.\n         */\n\n    }, {\n        key: 'fromObject',\n        value: function fromObject(object) {\n            if (true) {\n                if ((typeof object === 'undefined' ? 'undefined' : _typeof(object)) !== 'object') {\n                    throw new Error('Expected an object.');\n                }\n            }\n\n            return new Vector(object.x, object.y);\n        }\n\n        /**\n         * Create a new vector form a single value. In that case, both the x and y\n         * property will have the same value.\n         *\n         * @param {number} number Input number for x and y property.\n         * @return {Vector} Resulting vector.\n         */\n\n    }, {\n        key: 'fromNumber',\n        value: function fromNumber(number) {\n            return new Vector(number, number);\n        }\n    }]);\n\n    return Vector;\n}();\n\nVector.Unit = new Vector(1, 1);\nexports.default = Vector;\n\n//# sourceURL=webpack:///./src/Vector.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Vector = exports.Rectangle = exports.Point = exports.LineSegment = exports.Line = exports.Circle = undefined;\n\nvar _Circle = __webpack_require__(/*! ./Circle */ \"./src/Circle.js\");\n\nvar _Circle2 = _interopRequireDefault(_Circle);\n\nvar _Line = __webpack_require__(/*! ./Line */ \"./src/Line.js\");\n\nvar _Line2 = _interopRequireDefault(_Line);\n\nvar _LineSegment = __webpack_require__(/*! ./LineSegment */ \"./src/LineSegment.js\");\n\nvar _LineSegment2 = _interopRequireDefault(_LineSegment);\n\nvar _Point = __webpack_require__(/*! ./Point */ \"./src/Point.js\");\n\nvar _Point2 = _interopRequireDefault(_Point);\n\nvar _Rectangle = __webpack_require__(/*! ./Rectangle */ \"./src/Rectangle.js\");\n\nvar _Rectangle2 = _interopRequireDefault(_Rectangle);\n\nvar _Vector = __webpack_require__(/*! ./Vector */ \"./src/Vector.js\");\n\nvar _Vector2 = _interopRequireDefault(_Vector);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.Circle = _Circle2.default;\nexports.Line = _Line2.default;\nexports.LineSegment = _LineSegment2.default;\nexports.Point = _Point2.default;\nexports.Rectangle = _Rectangle2.default;\nexports.Vector = _Vector2.default;\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ 0:
/*!****************************!*\
  !*** multi ./src/index.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./src/index.js */\"./src/index.js\");\n\n\n//# sourceURL=webpack:///multi_./src/index.js?");

/***/ })

/******/ });